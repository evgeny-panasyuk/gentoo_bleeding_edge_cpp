diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
index 6de2f1c..fdaf5d7 100644
--- a/gcc/c-family/c-common.c
+++ b/gcc/c-family/c-common.c
@@ -557,6 +557,18 @@ const struct c_common_resword c_common_reswords[] =
   { "volatile",		RID_VOLATILE,	0 },
   { "wchar_t",		RID_WCHAR,	D_CXXONLY },
   { "while",		RID_WHILE,	0 },
+
+  /* Concepts-related keywords */
+  { "assume",		RID_ASSUME,	D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "axiom",		RID_AXIOM,	D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "concept",		RID_CONCEPT,	D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "forall", 		RID_FORALL,	D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "requires", 	RID_REQUIRES,	D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "__is_same",        RID_IS_SAME,    D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "__is_valid_expr",  RID_IS_VALID_EXPR,   D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "__is_valid_type",  RID_IS_VALID_TYPE,   D_CXXONLY | D_CXX0X | D_CXXWARN },
+  { "__declval",        RID_DECLVAL,    D_CXXONLY | D_CXX0X | D_CXXWARN },
+
   /* These Objective-C keywords are recognized only immediately after
      an '@'.  */
   { "compatibility_alias", RID_AT_ALIAS,	D_OBJC },
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
index 9298e3d..050b3cb 100644
--- a/gcc/c-family/c-common.h
+++ b/gcc/c-family/c-common.h
@@ -151,6 +151,10 @@ enum rid
   /* C++11 */
   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,
 
+  /* Concepts-related extensions */
+  RID_ASSUME, RID_AXIOM, RID_CONCEPT, RID_FORALL, RID_REQUIRES, 
+  RID_IS_SAME, RID_IS_VALID_EXPR, RID_IS_VALID_TYPE, RID_DECLVAL,
+
   /* Objective-C ("AT" reserved words - they are only keywords when
      they follow '@')  */
   RID_AT_ENCODE,   RID_AT_END,
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
index 89a22a3..719de70 100644
--- a/gcc/c-family/c-cppbuiltin.c
+++ b/gcc/c-family/c-cppbuiltin.c
@@ -716,6 +716,8 @@ c_cpp_builtins (cpp_reader *pfile)
 	cpp_define (pfile, "__GXX_RTTI");
       if (cxx_dialect >= cxx0x)
         cpp_define (pfile, "__GXX_EXPERIMENTAL_CXX0X__");
+      if (cxx_dialect >= cxx1y)
+        cpp_define (pfile, "__GXX_EXPERIMENTAL_CXX1Y__");
     }
   /* Note that we define this for C as well, so that we know if
      __attribute__((cleanup)) will interface with EH.  */
diff --git a/gcc/cp/Make-lang.in b/gcc/cp/Make-lang.in
index 6233f06..b10d4ef 100644
--- a/gcc/cp/Make-lang.in
+++ b/gcc/cp/Make-lang.in
@@ -82,6 +82,7 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \
  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \
  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \
  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \
+ cp/std.o cp/constraint.o \
  cp/cp-gimplify.o $(CXX_C_OBJS)
 
 # Language-specific object files for C++.
@@ -347,3 +348,11 @@ cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
 
 cp/cxx-pretty-print.o: cp/cxx-pretty-print.c $(CXX_PRETTY_PRINT_H) \
   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h $(CXX_TREE_H) tree-pretty-print.h
+
+cp/std.o: cp/std.c $(CXX_TREE_H) toplev.h $(TREE_INLINE_H) gt-cp-pt.h
+
+cp/constraint.o: cp/constraint.c cp/std.h $(CXX_TREE_H) $(TM_H) \
+  cp/decl.h cp/cp-objcp-common.h \
+  toplev.h $(TREE_INLINE_H) gt-cp-pt.h vecprim.h intl.h \
+  c-family/c-objc.h
+
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
index 6f7e346..26d1849 100644
--- a/gcc/cp/call.c
+++ b/gcc/cp/call.c
@@ -451,6 +451,7 @@ enum rejection_reason_code {
   rr_arg_conversion,
   rr_bad_arg_conversion,
   rr_template_unification,
+  rr_constraint_failure,
   rr_invalid_copy
 };
 
@@ -497,6 +498,10 @@ struct rejection_reason {
       tree tmpl;
       tree targs;
     } template_instantiation;
+    /* Information about failed constraints. */
+    struct {
+      tree constraints; 
+    } template_constraints;
   } u;
 };
 
@@ -705,6 +710,14 @@ template_unification_error_rejection (void)
 }
 
 static struct rejection_reason *
+template_constraint_rejection (tree errs)
+{
+  struct rejection_reason *r = alloc_rejection (rr_constraint_failure);
+  r->u.template_constraints.constraints = errs;
+  return r;
+}
+
+static struct rejection_reason *
 invalid_copy_with_fn_template_rejection (void)
 {
   struct rejection_reason *r = alloc_rejection (rr_invalid_copy);
@@ -1753,6 +1766,7 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,
 	return build_aggr_conv (to, expr, flags, complain);
 
       cand = build_user_type_conversion_1 (to, expr, flags, complain);
+
       if (cand)
 	conv = cand->second_conv;
 
@@ -1839,6 +1853,7 @@ add_function_candidate (struct z_candidate **candidates,
      been found using argument dependent lookup.  */
   gcc_assert (!DECL_ANTICIPATED (fn) || DECL_HIDDEN_FRIEND_P (fn));
 
+
   /* The `this', `in_chrg' and VTT arguments to constructors are not
      considered in overload resolution.  */
   if (DECL_CONSTRUCTOR_P (fn))
@@ -1857,6 +1872,24 @@ add_function_candidate (struct z_candidate **candidates,
   len = VEC_length (tree, args) - skip + (first_arg != NULL_TREE ? 1 : 0);
   convs = alloc_conversions (len);
 
+
+  // If the syntactic of a function are not satisfied, then the function is not
+  // viable. Only previously instantiated non-template members have this field
+  // set.
+  //
+  // FIXME: Improve diagnostics.
+  //
+  // FIXME: This won't be a simple boolean value much longer.
+  if (tree result = DECL_CONSTRAINT (fn))
+    {
+      if (result != boolean_true_node)
+        {
+          reason = template_unification_error_rejection();
+          viable = false;
+          goto out;
+        }
+    }
+
   /* 13.3.2 - Viable functions [over.match.viable]
      First, to be a viable function, a candidate function shall have enough
      parameters to agree in number with the arguments in the list.
@@ -2867,6 +2900,7 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,
   struct rejection_reason *reason = NULL;
   int errs;
 
+
   /* We don't do deduction on the in-charge parameter, the VTT
      parameter or 'this'.  */
   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (tmpl))
@@ -2908,24 +2942,36 @@ add_template_candidate_real (struct z_candidate **candidates, tree tmpl,
     }
   gcc_assert (ia == nargs_without_in_chrg);
 
-  errs = errorcount+sorrycount;
-  fn = fn_type_unification (tmpl, explicit_targs, targs,
-			    args_without_in_chrg,
-			    nargs_without_in_chrg,
-			    return_type, strict, flags, false);
-
-  if (fn == error_mark_node)
-    {
-      /* Don't repeat unification later if it already resulted in errors.  */
-      if (errorcount+sorrycount == errs)
-	reason = template_unification_rejection (tmpl, explicit_targs,
-						 targs, args_without_in_chrg,
-						 nargs_without_in_chrg,
-						 return_type, strict, flags);
-      else
-	reason = template_unification_error_rejection ();
-      goto fail;
-    }
+  // Perform function type unification. The nested scope is used to manage
+  // errors occurring during unification.
+  {
+    constraint_errors cerrs;
+    errs = errorcount+sorrycount;
+    fn = fn_type_unification (tmpl, explicit_targs, targs,
+  			    args_without_in_chrg,
+  			    nargs_without_in_chrg,
+  			    return_type, strict, flags, false);
+
+    if (fn == error_mark_node)
+      {
+        // FIXME: Generate better error messages for constraint 
+        if (cerrs.has_errors())
+          {
+            reason = template_constraint_rejection (cerrs.get_errors());
+            goto fail;
+          }
+          
+        /* Don't repeat unification later if it already resulted in errors.  */
+        if (errorcount+sorrycount == errs)
+        	reason = template_unification_rejection (tmpl, explicit_targs,
+  						 targs, args_without_in_chrg,
+  						 nargs_without_in_chrg,
+  						 return_type, strict, flags);
+        else
+        	reason = template_unification_error_rejection ();
+        goto fail;
+      }
+  }
 
   /* In [class.copy]:
 
@@ -3178,6 +3224,7 @@ print_z_candidate (location_t loc, const char *msgstr,
     inform (cloc, "%s%#D <deleted>", msg, candidate->fn);
   else
     inform (cloc, "%s%#D", msg, candidate->fn);
+  
   /* Give the user some information about why this candidate failed.  */
   if (candidate->reason != NULL)
     {
@@ -3235,6 +3282,11 @@ print_z_candidate (location_t loc, const char *msgstr,
 		  "  a constructor taking a single argument of its own "
 		  "class type is invalid");
 	  break;
+
+  case rr_constraint_failure:
+    diagnose_constraint_errors (cloc, r->u.template_constraints.constraints);
+    break;
+
 	case rr_none:
 	default:
 	  /* This candidate didn't have any issues or we failed to
@@ -6921,6 +6973,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray,
   fn = fold_if_not_in_template (fn);
   optimize = optimize_sav;
 
+  // If the type is void_type don't require it to be complete.
   if (VOID_TYPE_P (TREE_TYPE (fn)))
     return fn;
 
@@ -7497,7 +7550,7 @@ build_new_method_call_1 (tree instance, tree fns, VEC(tree,gc) **args,
 		   "operator delete(~X(f()))" (rather than generating
 		   "t = f(), ~X(t), operator delete (t)").  */
 		call = build_nop (void_type_node, call);
-	    }
+            }
 	}
     }
 
@@ -8102,6 +8155,7 @@ add_warning (struct z_candidate *winner, struct z_candidate *loser)
   winner->warnings = cw;
 }
 
+
 /* Compare two candidates for overloading as described in
    [over.match.best].  Return values:
 
@@ -8299,24 +8353,34 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,
   else if (cand1->template_decl && !cand2->template_decl)
     return -1;
 
-  /* or, if not that,
-     F1 and F2 are template functions and the function template for F1 is
-     more specialized than the template for F2 according to the partial
-     ordering rules.  */
-
+  // If both are templates, the winner is the most specialized function.
   if (cand1->template_decl && cand2->template_decl)
     {
+  	 /* [temp.func.order]: The presence of unused ellipsis and default
+  	    arguments has no effect on the partial ordering of function
+  	    templates.   add_function_candidate() will not have
+  	    counted the "this" argument for constructors.  */
       winner = more_specialized_fn
-	(TI_TEMPLATE (cand1->template_decl),
-	 TI_TEMPLATE (cand2->template_decl),
-	 /* [temp.func.order]: The presence of unused ellipsis and default
-	    arguments has no effect on the partial ordering of function
-	    templates.   add_function_candidate() will not have
-	    counted the "this" argument for constructors.  */
-	 cand1->num_convs + DECL_CONSTRUCTOR_P (cand1->fn));
+        (TI_TEMPLATE (cand1->template_decl),
+         TI_TEMPLATE (cand2->template_decl),
+	       cand1->num_convs + DECL_CONSTRUCTOR_P (cand1->fn));
+
       if (winner)
-	return winner;
-    }
+	      return winner;
+    } 
+
+  // If either non-template candidates are constrained, the more constrained of
+  // the two is the winner. This handles the case where constrained non-
+  // template members are being ordered. They are not compared as templates by
+  // more_specialized_fn.
+  if (DECL_CONSTRAINED_P (cand1->fn) || DECL_CONSTRAINED_P (cand2->fn))
+  {
+    if (more_constrained_p (cand1->fn, cand2->fn))
+      return 1;
+    if (more_constrained_p (cand2->fn, cand1->fn))
+      return -1;
+  }
+
 
   /* Check whether we can discard a builtin candidate, either because we
      have two identical ones or matching builtin and non-builtin candidates.
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
index 8de1423..5d6b04b 100644
--- a/gcc/cp/class.c
+++ b/gcc/cp/class.c
@@ -935,6 +935,8 @@ modify_vtable_entry (tree t,
     }
 }
 
+
+
 
 /* Add method METHOD to class TYPE.  If USING_DECL is non-null, it is
    the USING_DECL naming METHOD.  Returns true if the method could be
@@ -1067,14 +1069,21 @@ add_method (tree type, tree method, tree using_decl)
 	      != cp_type_quals (TREE_TYPE (TREE_VALUE (parms2)))))
 	continue;
 
-      /* For templates, the return type and template parameters
-	 must be identical.  */
+      /* For templates, the return type, template parameters,
+	 and constraints must be identical.  
+
+         Extended this comparison to include constraints also.
+
+         FIXME: similarly_constrained_decls includes redundant checks
+         on TREE_CODE. We know that both are template decls, so we could
+         omit those checks. */
       if (TREE_CODE (fn) == TEMPLATE_DECL
 	  && (!same_type_p (TREE_TYPE (fn_type),
 			    TREE_TYPE (method_type))
 	      || !comp_template_parms (DECL_TEMPLATE_PARMS (fn),
-				       DECL_TEMPLATE_PARMS (method))))
-	continue;
+				       DECL_TEMPLATE_PARMS (method))
+              || !similarly_constrained_p (fn, method)))
+        continue;
 
       if (! DECL_STATIC_FUNCTION_P (fn))
 	parms1 = TREE_CHAIN (parms1);
@@ -1086,18 +1095,26 @@ add_method (tree type, tree method, tree using_decl)
 	      || same_type_p (TREE_TYPE (fn_type),
 			      TREE_TYPE (method_type))))
 	{
+
 	  if (using_decl)
 	    {
 	      if (DECL_CONTEXT (fn) == type)
 		/* Defer to the local function.  */
 		return false;
 	    }
+          else if (!similarly_constrained_p (method, fn))
+            {
+              // Everything is identical up til now. Try to differentiate based
+              // on constraints.
+              continue;
+            }
 	  else
 	    {
 	      error ("%q+#D cannot be overloaded", method);
 	      error ("with %q+#D", fn);
 	    }
 
+
 	  /* We don't call duplicate_decls here to merge the
 	     declarations because that will confuse things if the
 	     methods have inline definitions.  In particular, we
diff --git a/gcc/cp/constraint.c b/gcc/cp/constraint.c
new file mode 100644
index 0000000..98a6e17
--- /dev/null
+++ b/gcc/cp/constraint.c
@@ -0,0 +1,2001 @@
+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
+     2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "cp-tree.h"
+#include "c-family/c-common.h"
+#include "c-family/c-objc.h"
+#include "tree-inline.h"
+#include "intl.h"
+#include "toplev.h"
+#include "flags.h"
+#include "timevar.h"
+#include "diagnostic.h"
+#include "cgraph.h"
+#include "tree-iterator.h"
+#include "vec.h"
+#include "target.h"
+#include "gimple.h"
+#include "bitmap.h"
+
+#include "std.h"
+#include <cctype>
+#include <map>
+
+// -------------------------------------------------------------------------- //
+//                            Constraint Processing
+//
+// A small RAII facility that indicates when a constraint is being processed.
+
+process_constraint::process_constraint()
+{
+  ++value;
+}
+
+process_constraint::~process_constraint()
+{
+  --value;
+}
+
+int process_constraint::value;
+
+bool
+processing_constraint () { return process_constraint::value; }
+
+
+
+// -------------------------------------------------------------------------- //
+//                      Template Parameter Inference
+//
+// This facility is responsible for the deduction of template parameter
+// declarations from shorthand constraints. In the declaration:
+//
+//    template<Same<int> T>
+//      struct s { };
+//
+// The facility will lookup the declaration Same and, from its signature, deduce
+// that T should be a type parameter. This can also entail a limited form of
+// overload resolution. If there are multiple candidates for the predicate Same,
+// we deduce the one that best matches the given arguments.
+//
+// The entry point to this facility is the deduce_parameter_declaration
+// function.
+//
+// TODO: Extend this to support the deduction of multiple parameters from a
+// domain concept.
+//
+//    template<Search<I, T>>
+//
+// Deduce declarations of I and T from the constraint Search.
+
+
+// Returns true t is a checkable declaration. A checkable declaration is an
+// unconstrained, nullary function template returing true.
+static bool
+is_checkable (tree t)
+{
+  if (!DECL_FUNCTION_TEMPLATE_P (t))
+    return false;
+  tree f = DECL_TEMPLATE_RESULT (t);
+  return !DECL_CONSTRAINED_P (f)
+      && !DECL_ARGUMENTS (f);
+}
+
+static tree
+inference_args_from_identifier ()
+{
+  tree args = make_tree_vec (1);
+  TREE_VEC_ELT (args, 0) = make_node (PLACEHOLDER_EXPR);
+  return args;
+}
+
+static tree
+inference_args_from_template_id (tree id)
+{
+  tree targs = TREE_OPERAND (id, 1);
+  int n = TREE_VEC_LENGTH (targs);
+  tree args = make_tree_vec (n + 1);
+  TREE_VEC_ELT (args, 0) = make_node (PLACEHOLDER_EXPR);
+  for (int i = 0; i < n; ++i)
+    TREE_VEC_ELT (args, i + 1) = TREE_VEC_ELT (targs, i);
+  return args;
+}
+
+
+static tree
+inference_args_from_id_expr (tree id)
+{
+  gcc_assert (TREE_CODE (id) == IDENTIFIER_NODE || 
+              TREE_CODE (id) == TEMPLATE_ID_EXPR);
+
+  if (TREE_CODE (id) == IDENTIFIER_NODE)
+    return inference_args_from_identifier ();
+  else
+    return inference_args_from_template_id (id);
+}
+
+// Return the inferred template parameter.
+static tree
+get_inferred_parameter (tree subst)
+{
+  for (int i = 0; i < TREE_VEC_LENGTH (subst); ++i)
+    {
+      tree s = TREE_VEC_ELT (subst, i);
+      if (TREE_CODE (s) == PLACEHOLDER_EXPR)
+        return TREE_CHAIN (s);
+    }
+  return NULL_TREE;
+}
+
+
+// A helper function for describe_parameter. Match the given arguments against
+// the overloads template parameters (if ovl is actually a function template).
+// Returns a pair containing the inferred parameter declaration, otherwise
+// NULL_TREE.
+//
+// TODO: I also need to make the substitutions available so I can easily
+// recover the inferred parameter -- or maybe I should juist return a pair
+// containt the overload and the inferred parameter.
+static tree
+infer_template_parameter (tree args, tree fn)
+{
+  if (!is_checkable (fn))
+    return NULL_TREE;
+
+  // If we can deduce an assignment, compare the args to parms and
+  // figure out which parameter was substituted.
+  tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (fn));
+  tree subst = deduce_constraint_parameters (parms, args);
+  if (subst == error_mark_node)
+    return NULL_TREE;
+  else
+    return get_inferred_parameter (subst);
+}
+
+// Given a constraint-id and an overload set, infer a declaration describing the
+// parameter that will be declared. Return a pair containing the constraining
+// overload and the inferred description.
+static tree
+description_from_overload (tree id, tree ovl)
+{
+  gcc_assert (TREE_CODE (ovl) == OVERLOAD);
+
+  // Get the inference arguments.  
+  tree args = inference_args_from_id_expr (id);
+
+
+  // Collect candidates.
+  Tree_vector cands;
+  cands.reserve (4);
+  while (ovl) {
+    tree fn = OVL_FUNCTION (ovl);
+    if (tree parm = infer_template_parameter (args, fn))
+        cands.push_back (tree_cons (fn, parm, NULL_TREE));
+    ovl = OVL_NEXT (ovl);
+  }
+
+  // FIXME: Do actual overload resolution.
+  // I haven't yet because I'm not entirely sure I need to.
+
+  // Obviously, this is going to 
+  if (cands.empty())
+    return NULL_TREE;
+  else if (cands.size() == 1)
+    return cands.front();
+  else if (cands.size () > 1) 
+    sorry ("cannot determine most specialized candidate");
+  return NULL_TREE;
+}
+
+// Given a constraint id and a declaration, return a pair containing the
+// constraining declaration and the describing template parameter.
+tree
+deduce_parameter_declaration (tree id, tree decl)
+{
+  if (TREE_CODE (decl) == OVERLOAD) 
+    return description_from_overload (id, decl);
+  else
+    return NULL_TREE;
+}
+
+
+
+// -------------------------------------------------------------------------- //
+// Constraint Scrubbing
+//
+// This framework takes a constraint expression and removes any "unnecessary"
+// nodes, returning a simple expression containing only the conjunction and
+// disjunction of propositions and other constraints.
+
+namespace {
+
+// Misc. helper functions.
+
+inline location_t
+loc (tree t) { return EXPR_LOCATION (t); }
+
+inline tree
+operand (tree t, int n = 0) { return TREE_OPERAND (t, n); }
+
+inline tree 
+left (tree t) { return TREE_OPERAND (t, 0); }
+
+inline tree 
+right (tree t) { return TREE_OPERAND (t, 1); }
+
+inline tree
+cast_target (tree t) { return TREE_VALUE (operand (t)); }
+
+
+} // namespace
+
+// Return the conjunction of two expressions.
+static inline tree
+conjoin_constraint_exprs (tree l, tree r)
+{
+  return cp_build_binary_op (loc (l), TRUTH_ANDIF_EXPR, l, r, tf_none);
+}
+
+static tree
+conjoin_constraint_stmts (tree stmts)
+{
+  tree lhs = NULL_TREE;
+  tree_stmt_iterator i = tsi_start (stmts);
+  while (!tsi_end_p (i))
+    {
+      if (tree rhs = rebuild_constraints (tsi_stmt (i)))
+        {
+          if (!lhs)
+            lhs = rhs;
+          else
+            lhs = conjoin_constraint_exprs (lhs, rhs);
+        }
+      tsi_next (&i);
+    }
+
+  if (!lhs) 
+    error ("no constraints found in this scope");
+  return lhs;
+}
+
+
+// Modify the node by replacing its left and right branches. 
+//
+// TODO: Since only logical nodes are rebuilt, it would be probably be a good
+// idea if we could check that the operand types are bool or convertible to
+// bool.
+static inline tree
+rebuild_constraint_op (tree t, tree l, tree r)
+{
+  TREE_OPERAND (t, 0) = l;
+  TREE_OPERAND (t, 1) = r;
+  return t;
+}
+
+// Getting a template id is generally an error, but we can probably infer the
+// meaning. The user most likely forgot to call the template id as an
+// expression. Fix it, and continue.
+static tree
+rebuild_template_id (tree t)
+{
+  VEC(tree, gc)* args = NULL;
+  tree c = finish_call_expr (t, &args, true, false, 0);
+  warning (0, "invalid constraint");
+  inform (input_location, "did you mean %qE", c);
+  return c;
+}
+
+static tree
+rebuild_constraint_expr (tree t)
+{
+  switch (TREE_CODE (t))
+    {
+    // Nodes in the constraint language need to be rebuilt.
+    case TRUTH_ANDIF_EXPR: 
+    case TRUTH_ORIF_EXPR: 
+      {
+        tree l = rebuild_constraints (left (t));
+        tree r = rebuild_constraints (right (t));
+        if (l && r)
+          return rebuild_constraint_op (t, l, r);
+        else
+          return NULL_TREE;
+      }
+
+    // These nodes are atomic.
+    // NOTE: These are obviously subsumed by the default case.
+    case TRUTH_NOT_EXPR:      return t;
+    case VALID_EXPR:          return t;
+    case VALID_TYPE:          return t;
+    case EXPR_PACK_EXPANSION: return t;
+
+    // Special handling for template-ids.
+    case TEMPLATE_ID_EXPR:    return rebuild_template_id (t);
+
+    // These nodes are filtered from the language.
+    case CAST_EXPR: return rebuild_constraints (cast_target (t));
+    case BIND_EXPR: return rebuild_constraints (BIND_EXPR_BODY (t));
+
+    // These expresssions carry no constraints.
+    case TAG_DEFN: return NULL_TREE;
+
+    // Everything else is a proposition.
+    default: return t;
+    }
+}
+
+static tree
+rebuild_constraint_stmt (tree t)
+{
+  switch (TREE_CODE (t))
+    {
+    case RETURN_EXPR: return rebuild_constraints (operand (t));
+
+    // Declarations within constraints do not carry constraints.
+    case DECL_EXPR: return NULL_TREE;
+    case USING_STMT: return NULL_TREE;
+    
+    default:
+      // debug_tree (t);
+      sorry ("unhandled stmt in the constraint language");
+      return NULL_TREE;
+    }
+}
+
+// A declaration reference in the constraint language 
+static tree
+rebuild_constraint_decl (tree t)
+{
+  switch (TREE_CODE (t))
+    {
+    case VAR_DECL: return t;
+    default:
+      // debug_tree (t);
+      sorry ("unhandled decl in the constraint language");
+      return NULL_TREE;
+    }
+}
+
+static tree
+rebuild_constraint_misc (tree t)
+{
+  switch (TREE_CODE (t))
+    {
+    // Errors are allowed to propagate through the contraint language.
+    case ERROR_MARK: return t;
+
+    // Traits are atomic.
+    case TRAIT_EXPR: return t;
+
+    // Translate a list of statements into a conjunction of constraints.
+    case STATEMENT_LIST: return conjoin_constraint_stmts (t);
+    
+    default:
+      // debug_tree (t);
+      sorry ("unhandled node in the constraint language");
+      return NULL_TREE;
+    }
+}
+
+// Rebuild a constraint expression, by filtering any nodes that may be useful
+// for evaluation, but are not necessary for the constraint language.
+tree 
+rebuild_constraints (tree t)
+{
+  switch (TREE_CODE_CLASS (TREE_CODE (t))) {
+  
+  // For expressions in the constraint language, we need to restitch the
+  // exprssion to filter unneeded nodes.
+  case tcc_unary:
+  case tcc_binary:
+  case tcc_expression:
+    return rebuild_constraint_expr (t);
+  
+  // Codes in these classes always represent atomic propositions.
+  case tcc_vl_exp:
+  case tcc_constant:
+  case tcc_reference:
+  case tcc_comparison:
+    return t;
+  
+  case tcc_statement:
+    return rebuild_constraint_stmt (t);
+  
+  case tcc_declaration: 
+    return rebuild_constraint_decl (t);
+
+  case tcc_exceptional:
+    return rebuild_constraint_misc (t);
+  
+  default:
+    debug_tree (t);
+    fprintf (stderr, "code: %s\n", 
+      TREE_CODE_CLASS_STRING (TREE_CODE_CLASS (TREE_CODE (t))));
+    sorry ("unhandled code class in the constraint language");
+    return NULL_TREE;
+  }
+}
+
+
+
+// -------------------------------------------------------------------------- //
+// Constraint Overloading
+//
+// The following functions are used to translate a call expression into
+// a constraint check.
+
+
+// Populate the candidate vector with viable constraint overloads. A constraint
+// is a nullary function template whose result type is convertible to bool
+// and such that the given arguments match that declaration's parameters.
+//
+// Returns a vector of list nodes where the value is the function declaration
+// to be chosen and the purpose contains the substitution arguments.
+static void
+get_constraint_overload_candidates (tree t, tree args, Tree_vector& cands)
+{
+  for (tree p = t; p != NULL_TREE; p = OVL_NEXT (p))
+    {
+      // Get the overloaded function and its template parameters.
+      tree f = OVL_FUNCTION (p);
+
+      // A constraint is a function template.
+      if (TREE_CODE (f) != TEMPLATE_DECL)
+        continue;
+
+      // Get the template parameters and the underlying decl.
+      tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (f));
+      f = DECL_TEMPLATE_RESULT (f);
+
+      // A constraint is an *unconstrained* template.
+      if (DECL_CONSTRAINED_P (f))
+        continue;
+
+      // A constraint is a nullary function.
+      if (DECL_ARGUMENTS (f))
+        continue;
+
+      // Remember the candidate if we can deduce a substitution.
+      if (tree subst = deduce_constraint_parameters (parms, args))
+        {
+          if (subst != error_mark_node)
+            cands.push_back (tree_cons (subst, f, NULL_TREE));
+        }
+    }
+}
+
+
+
+// 3way comparison function for constraint candidates. The arguments
+// a and b are pairs (TREE_LIST nodes) containing the candidate declaration
+// and the template arguments used for specialization.
+class compare_constraint_candidates
+{
+public:
+  bool operator()(tree a, tree b) const
+  {
+    tree f1 = DECL_TI_TEMPLATE (TREE_VALUE (a));
+    tree f2 = DECL_TI_TEMPLATE (TREE_VALUE (b));
+    return more_specialized_fn (f1, f2, 0);
+  }
+};
+
+
+// Returns the best overload candidate if several have matched.
+//
+// Note that this is only possible when a constraint is variadic and also
+// has overloads. For example:
+//
+//    template<typename... Ts>
+//      constexpr bool Same()
+//
+//    template<typename T, typename U>
+//      constexpr bool Same()
+//
+//    template<Same<int>, T>
+//      void f();
+//
+// The resolution of Same<int, T> should choose the second overload. It is
+// a better match than the first.
+static tree
+best_constraint_overload (const Tree_vector& cands)
+{
+  typedef Tree_vector::const_iterator Iter;
+
+  if (cands.empty())
+    return NULL_TREE;
+  else if (cands.size() == 1)
+    return cands.front();
+  else
+    {
+      // for (size_t i = 0; i < cands.size(); ++i)
+      //   debug_tree (cands[i]);
+      sorry ("cannot resolve ambiguous constraint check");
+    }
+  return NULL_TREE;
+
+  // FIXME: I doubt that we're ever going to get here. It seems like we
+  // can't actually disambiguate the kinds of declarations like those
+  // above.
+  //
+  // compare_constraint_candidates comp;
+  // Iter i = best_element (cands.begin(), cands.end(), comp);
+  // if (i != cands.end())
+  //   return *i;
+  // else
+  //   error ("cannot resolve constraint overload");
+  // return NULL_TREE; 
+}
+
+
+// Find a function template candidate that best matches the given arguments.
+// This is not full-on overload resolution, we only match by type.
+tree
+resolve_constraint_overload (tree t, tree args)
+{
+  gcc_assert (TREE_CODE (t) == OVERLOAD);
+  Tree_vector cands;
+  cands.reserve (4);
+  get_constraint_overload_candidates (t, args, cands);
+  return best_constraint_overload (cands);
+}
+
+
+
+// If t is a check expression, return a pair (actually a tree list) containing
+// a function declaration representing checked predicate and the arguments
+// used to instantiate it. Otherwise, returns NULL_TREE.
+//
+// A call expression is a check expression if it refers to a unique, nullary
+// function template via lightweight overload resolution.
+//
+// FIXME: It would be great if we had an actual node corresponding to the
+// constraint check. I could either rebuild that during constraint 
+// reconstruction or during parsing, if I actually parsed a separate language.
+tree
+get_constraint_check (tree t)
+{
+  if (TREE_CODE (t) != CALL_EXPR)
+    return NULL_TREE;
+
+  // If the call is to a template-id expression, then get the called function
+  // from that expression. Get new template arguments for the function we
+  // are going to recurse into.
+  t = CALL_EXPR_FN (t);
+  if (TREE_CODE (t) != TEMPLATE_ID_EXPR)
+    return NULL_TREE;
+
+  // Get the template and arguments.  
+  tree tmpl = TREE_OPERAND (t, 0);
+  tree args = TREE_OPERAND (t, 1);
+
+  // If we've found an overload, try to find the one that best matches
+  // our arguments.
+  return resolve_constraint_overload (tmpl, args);
+}
+
+// Returns true if t is a constraint check expression for the given
+// arguments.
+static inline bool
+is_constraint_check (tree t)
+{
+  return get_constraint_check (t) != NULL_TREE;
+}
+
+// Return the template arguments used in a check expression. Note that t
+// must actually represent a check expression.
+static inline tree
+get_check_args (tree t)
+{
+  gcc_assert (TREE_CODE (t) == CALL_EXPR);
+  gcc_assert (TREE_CODE (CALL_EXPR_FN (t)) == TEMPLATE_ID_EXPR);
+  return TREE_OPERAND (CALL_EXPR_FN (t), 1);
+}
+
+
+
+// -------------------------------------------------------------------------- //
+//                          Constraint Decomposition
+//
+// The following declarations are responsible for the decomposition of
+// requirements into sequences of assumptions. This done through the application
+// of left-logical rules of sequent calculus to conjunctions and disjunctions
+// of propositions in a constraint.
+//
+// The primary result of decomposition (either left or right) is a sequence of
+// alternatives sets of propositions, a list of lists. The proopositions
+// in these lists are also woven into a tree so that the compiler can
+// recover top-level checks for error handling. That lets us write either
+// very general or very specific diagnostics.
+
+
+namespace {
+
+typedef std::list<Tree_vector> Branch_list;
+
+// The decomposition class provides support for the decomposition of expressions
+// according to the left and right logical rules of sequent calculus for
+// first order logic.
+class decomposition
+{
+public:
+  decomposition (const decomposition&);
+  decomposition (Branch_list& p, tree t);
+
+
+  // Return the proposition being decomposed.
+  tree&       current()       { return (*props)[index]; }
+  const tree& current() const { return (*props)[index]; }
+
+  // Replace the current node
+  void replace (tree t) { current () = node (t); }
+
+  // Append a new node.
+  void append (tree t) { props->push_back (node (t)); }
+
+  // Return the the source of an inlined constraint.
+  tree source () const { return TREE_PURPOSE (current ()); }
+
+  // Return the parent node of the current inlined constraint.
+  tree parent () const { return TREE_CHAIN (current ()); }
+
+  // Create a new node, linking to the current one.
+  tree node (tree t) const { return tree_cons (source (), t, parent ()); }
+
+  // Proposition loading.
+  void load      (tree, tree);
+  void assume    (tree);
+  void call      (tree);
+  void check     (tree, tree);
+
+  // Branching
+  static void branch (tree, decomposition&, decomposition&);
+
+  Branch_list& branches; // Lists of tree vectors
+  Tree_vector* props;    // The current list of propositions
+  size_t index;          // The current proposition
+};
+
+
+inline
+decomposition::decomposition (const decomposition& x)
+  : branches (x.branches), index (x.index)
+{
+  // Create a new branch that is a copy of x's. The index stays the same.
+  branches.push_back (*x.props);
+  props = &branches.back ();
+}
+
+inline
+decomposition::decomposition (Branch_list& bs, tree t)
+  : branches (bs), index (0)
+{
+  // Create an initial branch, containing an empty list.
+  branches.push_back (Tree_vector ());
+  props = &branches.back ();
+  props->push_back (tree_cons (NULL_TREE, t, NULL_TREE));
+}
+
+// Add the given tree as an assumption by instantiating the requirement using
+// the arguments of template being declared.
+void
+decomposition::assume (tree t) 
+{
+  // If we've already seen the constraint, just replace the current with
+  // true.
+  //
+  // FIXME: This is gives terrible performance. Create a legitimate 
+  // expression that can compute this efficiently.
+  //
+  // TODO: We can actually discharge these later, potentially making a
+  // smaller set of of constraints.
+  for (size_t i = 0; i < index; ++i) 
+    {
+      tree p = TREE_VALUE ((*props)[i]);
+      if (cp_tree_equal (t, p))
+        {
+          t = boolean_true_node;
+          break;
+        }
+    }
+
+  replace (t);
+  ++index;
+}
+
+// Save the left and right operands into the list being constructed so they
+// can be visited in due course. Independently of side, the operation has
+// this effect.
+//
+//    G, A, B
+//    --------
+//    G, A x B
+void
+decomposition::load (tree l, tree r)
+{
+  replace (l);
+  append (r);
+}
+
+// Partial support for branching. Replacing the current element in both branches
+// with the operands of t. Cloning and recursion must be done by the derived
+// visitor. Independent of side, the operation has this effect.
+//
+//    G, A ; G, B
+//    -----------
+//     G, A x B
+void
+decomposition::branch (tree t, decomposition& l, decomposition& r)
+{
+  l.replace (left (t));
+  r.replace (right (t));
+}
+
+// Call decomposition is the same on the left and the right, and is essentially
+// an expansion of the the constraint P into its nested constraints.
+//
+//    G, P' |- D
+//    --------------- L-call
+//    G, check P |- D
+//
+//    G |- P', D
+//    ---------------- R-call
+//    G |- check P, D
+//
+// A check expression is a call to a constraint: a nullary function template.
+// For example:
+//
+//    Equality_comparable<X>()   // refers to Equality_comparable<T>
+//    Equality_comparable<X,Y>() // refers to Equality_comparable<T, U>
+//
+// Save the constraints of s into the proposition list.
+void
+decomposition::call (tree t)
+{
+  if (tree c = get_constraint_check (t))
+    check (t, c);
+  else
+    assume (t);
+}
+
+// Emit the error and assume a contradiction. This is a hard error. and we're
+// going to get real problems.
+//
+// FIXME: This is emitted twice. Once for left, once for right. Be sure to
+// polish this before shipping.
+//
+// FIXME: This isn't right. We actually have to look at the overload set and the
+// arguments to determine if the expression will resolve to a recursive call.
+// This may be more difficult to solve, besides.
+static bool
+check_recursive (tree, tree)
+{
+  /*
+  tree fn1 = OVL_FUNCTION (TREE_OPERAND (CALL_EXPR_FN (t), 0));
+  while (p) {
+    tree fn2 = OVL_FUNCTION (TREE_OPERAND (CALL_EXPR_FN (TREE_VALUE (p)), 0));
+    if (fn1 == fn2)
+      {
+        error ("%qE is a recursive constraint check", t);
+        return true;
+      }
+    p = TREE_CHAIN (p);
+  }
+  */
+  return false;
+}
+
+// Instantiate the body of a checked constraint, c, replacing the current
+// proposition. The argument t is the initial expression from which c
+// was derived.
+void
+decomposition::check (tree t, tree c)
+{
+  // DO NOT RECURSE! If this is recursive, replace the current node
+  // with a contradiction, just to force more errors. We could actually
+  // insert a special token to indicate an improper definition and thus
+  // improve the diagnostics.
+  if (check_recursive (t, parent ()))
+    {
+      assume (boolean_false_node);
+      return;
+    }
+
+  // Make sure we can inline the check.
+  tree fn = TREE_VALUE (c);
+  tree body = DECL_SAVED_TREE (fn);
+  if (body == error_mark_node) {
+    error ("checked constraint %q#D has no defnition", t);
+    return;
+  }
+
+  // Inline the nested requirements.
+  tree cons = rebuild_constraints (body);
+  tree args = TREE_PURPOSE (c);
+  tree prop = instantiate_proposition (cons, args);
+
+  // Replace the current proposition with the inlined version. 
+  current () = tree_cons (t, prop, current ());
+}
+
+
+// The left decomposition class implements left decomposition rules for
+// constraint expressoins.
+class left_decomposition : public decomposition
+{
+public:
+  left_decomposition (Branch_list&, tree);
+
+  // Main entry point.
+  void operator() ();
+
+  // Visit functions.
+  void visit      (tree);
+  void visit_and  (tree);
+  void visit_or   (tree);
+  void visit_call (tree);
+};
+
+inline
+left_decomposition::left_decomposition (Branch_list& bs, tree t)
+  : decomposition (bs, t)
+{ }
+
+
+inline void
+left_decomposition::operator() ()
+{
+  while (index != props->size()) 
+    visit (current ());
+}
+
+void
+left_decomposition::visit (tree t)
+{
+  t = TREE_VALUE (t);
+  switch (TREE_CODE (t))
+    {
+    // Constraint expressions
+    case TRUTH_ANDIF_EXPR: visit_and (t); break;
+    case TRUTH_ORIF_EXPR:  visit_or (t); break;
+    case CALL_EXPR:        visit_call (t); break;
+
+    // Atomic propositions
+    default: assume (t);
+    }
+}
+
+// Left-and decomposition.
+//
+//     G,A,B |- C
+//    ---------------
+//    G, A and B |- C
+//
+// Load the operands into the proposition list.
+inline void
+left_decomposition::visit_and (tree t)
+{
+  load (left (t), right (t));
+}
+
+// Left-or decomposition.
+//
+//    G,A |- C ; G,B |- C
+//    -------------------
+//       G, A or B |- C
+//
+// Branch the decomposition into two sub-problems.
+inline void
+left_decomposition::visit_or (tree t)
+{
+  left_decomposition& lhs = *this;
+  left_decomposition  rhs = *this;
+  branch (t, lhs, rhs);
+  rhs ();
+}
+
+// Exapnd the nested constraints into the proposition list.
+//
+//    G, P' |- D
+//    --------------- L-call
+//    G, check P |- D
+//
+// Here, P' denotes the constraints owned by the checked constraint.
+inline void
+left_decomposition::visit_call (tree t)
+{
+  call (t);
+}
+
+
+// The right decomposition class implements right-decomposition rules
+// for constraint expressions.
+class right_decomposition : public decomposition
+{
+public:
+  right_decomposition (Branch_list&, tree);
+
+  // Main entry point.
+  void operator() ();
+
+  // Visit functions.
+  void visit      (tree);
+  void visit_and  (tree);
+  void visit_or   (tree);
+  void visit_call (tree);
+};
+
+inline
+right_decomposition::right_decomposition (Branch_list& bs, tree t)
+  : decomposition (bs, t)
+{ }
+
+inline void
+right_decomposition::operator() ()
+{
+  while (index != props->size())
+      visit (current ());
+}
+
+void
+right_decomposition::visit (tree t)
+{
+  t = TREE_VALUE (t);
+  switch (TREE_CODE (t))
+    {
+    // Connectives and operators
+    case TRUTH_ANDIF_EXPR: visit_and (t); break;
+    case TRUTH_ORIF_EXPR:  visit_or (t); break;
+    case CALL_EXPR:        visit_call (t); break;
+
+    // Atomic propositions
+    default: assume (t);
+    }
+}
+
+// Right-and decomposition.
+//
+//    G |- P ; G |- Q
+//    ---------------
+//    G |- P and Q
+//
+// Branch the decomposition into two sub-problems.
+inline void
+right_decomposition::visit_and (tree t)
+{
+  right_decomposition& lhs = *this;
+  right_decomposition  rhs = *this;
+  branch (t, lhs, rhs);
+  rhs ();
+}
+
+// Right-or decomposition
+//
+//     G |- P, Q
+//    -----------
+//    G |- P or Q
+//
+// Load the operands into the proposition list.
+inline void
+right_decomposition::visit_or (tree t)
+{
+  load (left (t), right(t));
+}
+
+// Exapnd the nested constraints into the proposition list.
+//
+//    G |- P', D
+//    ---------------- R-call
+//    G |- check P, D
+//
+// Here, P' denotes the constraints owned by the checked constraint.
+inline void
+right_decomposition::visit_call (tree t)
+{
+  call (t);
+}
+
+
+// Copy the list of branches into a vector of vectors, representing the
+// assumptions or conclusions of a constrained declaration.
+tree
+finish_decomposition (const Branch_list& branches)
+{
+  tree result = make_tree_vec (branches.size());
+  Branch_list::const_iterator i = branches.begin();
+  Branch_list::const_iterator e = branches.end();
+  size_t n = 0;
+  while (i != e)
+    {
+      TREE_VEC_ELT (result, n) = to_tree_vec (*i);
+      ++i;
+      ++n;
+    }
+  return result;
+}
+
+} // namespace
+
+
+
+// Left-decompose a constraint expression into a set of assumptions.
+tree 
+left_decompose_constraints (tree t)
+{
+  Branch_list branches;
+  left_decomposition vis (branches, t);
+  vis ();
+  return finish_decomposition (branches);
+}
+
+// Right-decompose a constraint expression into a set of conclusions.
+tree
+right_decompose_constraints (tree t)
+{
+  Branch_list branches;
+  right_decomposition vis (branches, t);
+  vis ();
+  return finish_decomposition (branches);
+}
+
+
+
+// -------------------------------------------------------------------------- //
+// Constraint Satisfaction
+
+// Evaluate the entire conjunction of constraints. Do not short-circuit the
+// evaluate when a check fails. This will let us report all of the reasons
+// that this alternative could not be satisfied.
+//
+// Note that diagnostics are not reported whenever we're evaluating constraints.
+// This prevents duplicate errors from being accumulated in the same context.
+static tree
+evaluate_constraint_conjunction (tree props, tree args)
+{
+  tree result = boolean_true_node;
+  for (int i = 0; i < TREE_VEC_LENGTH (props); ++i)
+    {
+      tree info = TREE_VEC_ELT (props, i);
+      tree prop = TREE_VALUE (info);
+
+
+      // Instantiate the proposition. If there is a substitution failure, then
+      // the constraints are not satisfied.
+      tree expr = instantiate_proposition (prop, args);
+      if (expr == error_mark_node)
+        {
+          if (!processing_constraint ())
+            constraint_errors::substitution_failure (info);
+          result = boolean_false_node;
+        }
+
+      // Evaluate the resulting expression. If the result is anything other
+      // than true, then the evaluation of this conjunction will also fail.
+      //
+      // NOTE: When template constraints are checked inside templates the
+      // expressions may not be fully reduced. So, we reduce them even more
+      // usign maybe_constant_value, and then fold them to (hopefully) get
+      // true or false.
+      tree eval = fold (maybe_constant_value (expr));
+      if (eval != boolean_true_node)
+        {
+          if (!processing_constraint ())
+            constraint_errors::unsatisfied_proposition (info);
+          result = boolean_false_node;
+        }
+    }
+
+  return result;
+}
+
+// Instantiate and evaluate a set of constraints for a over a sequence of 
+// template arguments.
+//
+// Disjunctions are short-circuited. We return true when the first is true
+// alternative is found.
+bool
+evaluate_constraints (tree info, tree args)
+{
+  // Are the constraints dependent?
+  // tree e = TREE_VEC_ELT (info, 3);
+  // if (value_dependent_expression_p (e))
+  //   return true;
+
+  // NOTE: This is "quick and dirty" evaluation.
+  // {
+  //   tree e = instantiate_proposition (TREE_VEC_ELT (info, 3), args);
+  //   return cxx_constant_value (e);
+  // }
+
+  // Constraints are defined by a disjunction of conjunctions. Instantiate and
+  // evaluate each separately.
+  tree probs = TREE_VEC_ELT (info, 2);
+  for (int i = 0; i < TREE_VEC_LENGTH (probs); ++i)
+    {
+      tree conjuncts = TREE_VEC_ELT (probs, i);
+
+      // Evaluate the constraints. If they are all satisfied, then
+      // ignore any previous errors and return.
+      tree result = evaluate_constraint_conjunction (conjuncts, args);
+      if (result == boolean_true_node)
+        {
+          constraint_errors::ignore();
+          return true;
+        }
+    }
+  return false;
+}
+
+// Actually evaluate constraints.
+static bool
+evaluate_decl_constraints (tree decl, tree parms, tree args)
+{
+  if (tree info = DECL_CONSTRAINT (decl))
+    {
+      if (!processing_constraint ())
+        constraint_errors::bind_parameters (parms, args);
+      return evaluate_constraints (info, args);
+    }
+  else
+    return true;
+}
+
+// If constrained, instantiated the declaration's constraints.
+bool
+evaluate_decl_constraints (tree tmpl, tree args)
+{
+  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);
+  tree parms = DECL_TEMPLATE_PARMS (tmpl);
+  tree decl = DECL_TEMPLATE_RESULT (tmpl);
+  return evaluate_decl_constraints (decl, parms, args);
+}
+
+// If constrained, evaluate the type's constraints. This is used to
+// evaulate constraints for partial specializations, which are apparently
+// not quite the same as primary template declarations.
+//
+// TODO: This function exists entirely for the reason that I can't figure
+// out how to get the template declaration for a partial specialization.
+bool
+evaluate_type_constraints (tree type, tree args)
+{
+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);
+  tree parms = CLASSTYPE_TI_ARGS (type);
+  tree decl = TYPE_MAIN_DECL (type);
+  return evaluate_decl_constraints (decl, parms, args);
+}
+
+
+// -------------------------------------------------------------------------- //
+// Constraint Equivalence
+//
+// Determine whether two constraints are equivalent. 
+
+
+
+// Return constraints for a type or template, or declaration.
+tree
+get_constraints (tree t)
+{
+  // Make sure that t is actually a template decl. Map types to their
+  // declarations, and specializations to their describing templates.
+  if (TYPE_P (t))
+    t = TYPE_MAIN_DECL (t);
+  else if (DECL_USE_TEMPLATE (t))
+    t = DECL_TI_TEMPLATE (t);
+
+  if (TREE_CODE (t) == TEMPLATE_DECL)
+    t = DECL_TEMPLATE_RESULT (t);
+  return DECL_CONSTRAINT (t);
+}
+
+
+// Returns true when A and B are the same constraints. A and B are the same
+// constraints when A subsumes B and B subsumes A.
+bool
+same_constraints_p (tree a, tree b)
+{
+ if (a == b)
+    return true;
+
+  if (!a != !b)
+    return false;
+
+  // Constraints are of different kinds.
+  if (TREE_CODE (a) != TREE_CODE (b))
+    return false;
+
+  // Sometimes, we compare template parameters, which do not have fully
+  // decomposed constraints. In those cases, we compare names.
+  //
+  // FIXME: We need to compare actual constraints on template parameters in
+  // order for this definition to be consistent.
+  //
+  // FIXME: This could be made more effecient with a real tree set.
+  if (TREE_CODE (a) == TREE_VEC)
+    return subsumes_constraints_p (a, b) && subsumes_constraints_p (b, a);
+  else
+    return cp_tree_equal (a, b);
+}
+
+// Returns true when A and B are declarations (possibly templates) that have
+// equivalent constraints. The constraints compared are always those specified
+// by the original template definition.
+//
+// Note that the arguments A and B can be types, templates, templated
+// declarations, or template specializations.
+bool
+similarly_constrained_p (tree a, tree b)
+{
+  tree p = get_constraints (a);
+  tree q = get_constraints (b);
+  return same_constraints_p (p, q);
+}
+
+
+// -------------------------------------------------------------------------- //
+// Constraint Ordering
+//
+// Determine the ordering of two constraints. This is computed on the
+// subsumption of one set of constraints by the other.
+
+
+// True when the validexpr requirement p is subsumed by the validexpr
+// requirement q.
+static bool
+subsumes_valid_expr (tree p, tree q)
+{
+  // If the syntax is different, then these are not the same.
+  tree e1 = TREE_OPERAND (p, 0);
+  tree e2 = TREE_OPERAND (q, 0);
+  if (!cp_tree_equal (e1, e2))
+    return false;
+
+  // If the p's result type requirement is unspecified (implicitly true),
+  // then p is subsumed by q. Otherwise, one subsumes the other when
+  // the requirements compare equal.
+  tree r1 = TREE_OPERAND (p, 1);
+  tree r2 = TREE_OPERAND (q, 1);
+  if (r1 == boolean_true_node)
+    return true;
+  else
+    return cp_tree_equal (r1, r2);
+}
+
+// True when we can match __is_same(T, U) => __trait(T, U) where q is the
+// same-type constraint and p is a conversion/derivation requirement.
+static bool
+subsumes_same_type (tree p, tree q)
+{
+  tree t1 = TRAIT_EXPR_TYPE1 (p);
+  tree t2 = TRAIT_EXPR_TYPE2 (p);
+  tree u1 = TRAIT_EXPR_TYPE1 (q);
+  tree u2 = TRAIT_EXPR_TYPE2 (q);
+  return same_type_p (t1, u1) && same_type_p(t2, u2);
+}
+
+// True when we can match __is_base_of(T, U) => __is_convertible(U, T) where
+// q is the derivation requirement and p is the conversion requirement.
+static bool
+subsumes_base_type (tree p, tree q)
+{
+  tree t1 = TRAIT_EXPR_TYPE1 (p);
+  tree t2 = TRAIT_EXPR_TYPE2 (p);
+  tree u1 = TRAIT_EXPR_TYPE1 (q);
+  tree u2 = TRAIT_EXPR_TYPE2 (q);
+  return same_type_p (t1, u2) && same_type_p(t2, u1);
+}
+
+// True if q is any of the traits on the left, and p matches a constraint
+// on the right.
+//
+//    __is_same(T, U)    => __is_convertible(T, U)
+//    __is_same(T, U)    => __is_base_of(T, U)
+//    __is_base_of(T, U) => __is_convertible(U, T)
+//
+static bool
+subsumes_trait_expr (tree p, tree q)
+{
+  cp_trait_kind pk = TRAIT_EXPR_KIND (p);
+  cp_trait_kind qk = TRAIT_EXPR_KIND (q);
+  if (qk == CPTK_IS_SAME)
+    {
+      if (pk == CPTK_IS_CONVERTIBLE_TO || pk == CPTK_IS_BASE_OF)
+        return subsumes_same_type (p, q);
+    }
+  else if (qk == CPTK_IS_BASE_OF)
+    {
+      if (pk == CPTK_IS_CONVERTIBLE_TO)
+        return subsumes_base_type (p, q);
+    }
+
+  // In all other cases, we match if the trees are the same.
+  return cp_tree_equal (p, q);
+}
+
+// True when p is subsumed by q. This is generally the case when p matches
+// q, with some specific extensions.
+static inline bool
+subsumes_prop (tree p, tree q)
+{
+  // Specifically match non-matching codes.
+  if (TREE_CODE (p) != TREE_CODE (q))
+    return false;
+
+  // Special handling for specific nodes.
+  if (TREE_CODE (p) == VALID_EXPR)
+    return subsumes_valid_expr (p, q);
+  else if (TREE_CODE (p) == TRAIT_EXPR)
+    return subsumes_trait_expr (p, q);
+  else
+    return cp_tree_equal (p, q);
+}
+
+// Returns true when the assumptions A subsumes the constraints C. This is
+// true when any proposition P in C can be matched to a proposition in A.
+bool
+subsumes_overlap (tree a, tree c)
+{
+  for (int i = 0; i < TREE_VEC_LENGTH (c); ++i)
+    for (int j = 0; j < TREE_VEC_LENGTH (a); ++j)
+      {
+        // Note that constraints a leaf nodes in trees. We only want to
+        // compare their values. 
+        //
+        // NOTE: when p == true, it can be immediately discharged. This is
+        // part of a larger pattern where we can effectively ignore 
+        // constraints written as "true".
+        tree p = TREE_VALUE (TREE_VEC_ELT (c, i));
+        tree q = TREE_VALUE (TREE_VEC_ELT (a, j));
+        if (subsumes_prop (p, q))
+          return true;
+      }
+  return false;
+}
+
+// Returns true if the the assumptions in A (a proposition list) subsumes the
+// conclusions CS (a list of proposition lists). This is true when the
+// intersection of each c in cs with a is non-empty. 
+bool
+subsumes_right (tree a, tree cs)
+{
+  for (int i = 0; i < TREE_VEC_LENGTH (cs); ++i)
+    {
+      tree c = TREE_VEC_ELT (cs, i);
+      if (!subsumes_overlap (a, c))
+        return false;
+    }
+  return true;
+}
+
+// Returns true when the assumptions AS (a list of proposition lists), subsume
+// or overlap CS (a list of proposition lists). This is true when the 
+// intersections of each a in as with each c in cs is non-empty.
+static bool
+subsumes_left (tree as, tree cs)
+{
+  gcc_assert(TREE_CODE (as) == TREE_VEC && TREE_CODE (cs) == TREE_VEC);
+  for (int i = 0; i < TREE_VEC_LENGTH (as); ++i)
+    {
+      tree a = TREE_VEC_ELT (as, i);
+      if (!subsumes_right (a, cs))
+        return false;
+    }
+  return true;
+}
+
+// Return true the constraints A subsume the the constraints B. This is the
+// conceptually the case when B is a subset of A. 
+bool
+subsumes_constraints_p (tree a, tree b)
+{
+  if (!a)
+    return !b;
+  else if (!b)
+    return true;
+  else
+    {
+      tree as = TREE_VEC_ELT (a, 2);
+      tree cs = TREE_VEC_ELT (b, 3);
+      return subsumes_left (as, cs);
+    }
+}
+
+
+// Returns true if the declaration A is more constrained than the declaration B,
+// which happens only when the requirements of TMPL1 subsume the requirements of
+// TMPL2. Note a constrained template is always more constrained than an
+// unconstrained template.
+bool
+more_constrained_p (tree a, tree b)
+{
+  tree p = get_constraints (a);
+  tree q = get_constraints (b);
+  return subsumes_constraints_p (p, q);
+}
+
+
+
+// -------------------------------------------------------------------------- //
+// Error Handling
+//
+// The constraint error handler is a small class that manages a couple of
+// global resources. 
+
+// Return the top-most expression from which t was inlined.
+static inline tree
+topmost_constraint (tree t)
+{
+  while (TREE_CHAIN (t))
+    t = TREE_CHAIN (t);
+  return TREE_VALUE (t);
+}
+
+// The reporting context for constraint errors.
+class constraint_errors::context
+{
+public:
+  context () : binding (NULL_TREE) { }
+
+  tree binding;     // The current template's parameters
+  Tree_vector errs; // The list of errors
+};
+
+std::vector<constraint_errors::context> constraint_errors::stack;
+
+// Push an empty vector to receive constraint errors.
+constraint_errors::constraint_errors ()
+{
+  stack.push_back (context ());
+}
+
+// Pop the current error stack.
+constraint_errors::~constraint_errors ()
+{
+  stack.pop_back ();
+}
+
+// There are errors when there are no errors reported in the current
+// reporting context.
+bool
+constraint_errors::has_errors () const
+{
+  return !current ().errs.empty ();
+}
+
+// Build a list of errors that is amenable to error reporting.
+// The result is a list node whose purpose contains the instantiation
+// arguments and whose value is a list of specific errors.
+//
+// FIXME: This will change. Soon, the value will be list of pairs
+// containing a top-level check and its specific failures.
+tree
+constraint_errors::get_errors () const
+{
+  typedef std::map<tree, Tree_vector> Error_map;
+  typedef Error_map::iterator         Map_iter;
+  typedef std::pair<Map_iter, bool>   Map_result;
+  typedef Tree_vector::const_iterator Vec_iter;
+
+  // Create a set of top-level failures for the constraint. Associate, with
+  // each top-level failure, the specific failures that occurred.
+  const context& cxt = current ();
+  const Tree_vector& errs = cxt.errs;
+  Error_map map;
+  for (Vec_iter i = errs.begin(); i != errs.end(); ++i) {
+    tree err = TREE_VALUE (*i);
+    tree top = topmost_constraint (*i);
+    Map_result r = map.insert (std::make_pair(top, Tree_vector ()));
+    r.first->second.push_back (err);
+  }
+
+  tree r = make_tree_vec (map.size());
+  int n = 0;
+  for (Error_map::iterator i = map.begin (); i != map.end (); ++i)
+    {
+      // Create a vector of sepecifc failures.
+      Tree_vector& v = i->second;
+      tree tv = make_tree_vec (v.size ());
+      for (size_t j = 0; j < v.size (); ++j)
+        TREE_VEC_ELT (tv, j) = v[j];
+
+      // Add a pair to the result vector, where the purpose is the top
+      // level failure, and specific errors are found ion the value.
+      TREE_VEC_ELT (r, n++) = tree_cons (i->first, tv, NULL_TREE);
+    }
+
+  // Return a pair containing arguments and error vector.
+  return tree_cons (cxt.binding, r, NULL_TREE);
+}
+
+void
+constraint_errors::print_errors (location_t loc)
+{
+  diagnose_constraint_errors (loc, get_errors ());
+}
+
+void
+constraint_errors::bind_parameters (tree parms, tree args)
+{
+  if (!active ())
+    return;
+  current ().binding = tree_cons (parms, args, NULL_TREE);
+}
+
+// Indicate that the proposition t is not satisfied.
+void
+constraint_errors::unsatisfied_proposition (tree t)
+{
+  if (!active ())
+    return;
+
+  // FIXME: Attach something to T indicating the kind of error.
+  Tree_vector& errs = current ().errs;
+  errs.push_back (t);
+}
+
+// Indicate that a substitution failure occurred when instantiating t.
+void
+constraint_errors::substitution_failure (tree t)
+{
+  if (!active ())
+    return;
+
+  // FIXME: Attach something to T indicating the kind of error.
+  Tree_vector& errs = current ().errs;
+  errs.push_back (t);
+}
+
+// Ignore any errors caught during constraint evaluation.
+void
+constraint_errors::ignore ()
+{
+  if (!active ())
+    return;
+
+  // FIXME: Attach something to T indicating the kind of error.
+  Tree_vector& errs = current ().errs;
+  errs.clear ();
+}
+
+// The error handler is active when there is a context on the stack.
+inline bool
+constraint_errors::active ()
+{
+  return !stack.empty();
+}
+
+// Returns the current reporting context. Behavior is undefined when
+// the error hander is inactive.
+inline constraint_errors::context&
+constraint_errors::current()
+{
+  gcc_assert (active ());
+  return stack.back();
+}
+
+
+
+// -------------------------------------------------------------------------- //
+//                            Constraint Dianostics
+//
+// 
+
+
+
+// FIXME: Diagnostics look awful with the article in parentheses. A real
+// attempt to determine parts of speech would make the diagnostics much
+// at the expense of the declarations themselves. But still...
+//
+//    template<typename T>
+//      [[pos("noun")]] constexpr bool Graph() { ... }
+//
+//    template<typename T>
+//      [[pos("adjective")]] constexpr bool Iterable() { ... }
+//
+//    template<typename T>
+//      [[pos("noun"), article("an")]] 
+//      constexpr bool Unsigned_integer() { ... }
+//
+// In fact, there are lots of other little things we could do with this.
+// Customize the entire diagnostic?
+
+
+class constraint_diagnostics
+{
+public:
+  constraint_diagnostics (location_t, tree);
+
+  void operator ()();
+
+  void diagnose                (tree);
+  void diagnose_valid_type     (tree);
+  void diagnose_valid_expr     (tree);
+  void diagnose_trait          (tree);
+  void diagnose_prop           (tree);
+
+  void diagnose_basic_check       ();
+  void diagnose_unary_check       ();
+  void diagnose_nary_check        ();
+  void diagnose_variadic_check    ();
+  void diagnose_distributed_check ();
+  void diagnose_causes            ();
+
+  int count_causes ();
+
+private:
+  // Contextual data.
+  location_t loc_;      // Diagnostic location
+  tree       binding_;  // Parameter/argument binding
+  tree       errors_;   // Error lists
+  tree       parms_;    // Template parameters
+  tree       args_;     // Template arguments
+  
+  // Current state.
+  // FIXME: Actually use the indendation in diagnostics.
+  int        indent_;   // The current indentation level.
+  tree       error_;    // Current primary error.
+  tree       causes_;   // The causes of a failure
+  tree       tfunc_;    // The checked template
+  tree       targs_;    // Check arguments
+};
+
+constraint_diagnostics::constraint_diagnostics (location_t loc, tree cxt)
+  : loc_ (loc)
+  , binding_ (TREE_PURPOSE (cxt))
+  , errors_ (TREE_VALUE (cxt))
+  , parms_ (TREE_PURPOSE (binding_))
+  , args_ (TREE_VALUE (binding_))
+{ }
+
+
+void 
+constraint_diagnostics::operator() ()
+{
+  // Controls some diagnostic issues.
+  process_constraint p; 
+  
+  inform (loc_, "template constraints not satisfied because");
+  for (int i = 0; i < TREE_VEC_LENGTH (errors_); ++i)
+    diagnose (TREE_VEC_ELT (errors_, i));
+}
+
+void
+constraint_diagnostics::diagnose (tree t)
+{
+  indent_ = 0;
+  error_ = TREE_PURPOSE (t);
+  causes_ = TREE_VALUE (t);
+  switch (TREE_CODE (error_))
+    {
+    case CALL_EXPR:           diagnose_basic_check ();    break;
+    case EXPR_PACK_EXPANSION: diagnose_variadic_check (); break;
+    default:                  diagnose_prop (t);          break;
+    }
+}
+
+void
+constraint_diagnostics::diagnose_prop (tree t)
+{
+  switch (TREE_CODE (t))
+  {
+  case TREE_LIST:  diagnose_prop (TREE_PURPOSE (t)); break;
+  case VALID_EXPR: diagnose_valid_expr (t);           break;
+  case VALID_TYPE: diagnose_valid_type (t);           break;
+  case TRAIT_EXPR: diagnose_trait (t);               break;
+  default:
+    inform (loc_, "    %qE evaluated to %qE", t, boolean_false_node);
+    break;
+  }
+}
+
+void
+constraint_diagnostics::diagnose_valid_type (tree t)
+{
+  tree type = TREE_OPERAND (t, 0);
+  inform (loc_, "    %qT is not a valid typename", type);
+}
+
+void
+constraint_diagnostics::diagnose_valid_expr (tree t)
+{
+  // We don't know which branch caused the error, so check again.
+  tree syntax = TREE_OPERAND (t, 0);
+  tree r = instantiate_proposition (syntax, args_);
+  if (r == error_mark_node) 
+    {
+      inform (loc_, "    %qE is not valid syntax", syntax);
+      return;
+    }
+  else
+    {
+      diagnose_trait (TREE_OPERAND (t, 1));
+    }
+}
+
+// Generate a diagnostic for the constraint expression t.
+void
+constraint_diagnostics::diagnose_trait (tree t)
+{
+  // TODO: Improve the reporting of these diagnostics. 
+  tree t1 = TRAIT_EXPR_TYPE1 (t);
+  tree t2 = TRAIT_EXPR_TYPE2 (t);
+  switch (TRAIT_EXPR_KIND (t))
+  {
+  case CPTK_HAS_NOTHROW_ASSIGN:
+    inform (loc_, "    %qT is not nothrow copy assignable", t1);
+    break;
+  case CPTK_HAS_NOTHROW_CONSTRUCTOR:
+    inform (loc_, "    %qT is not nothrow default constructible", t1);
+    break;
+  case CPTK_HAS_NOTHROW_COPY:
+    inform (loc_, "    %qT is not nothrow copy constructible", t1);
+    break;
+  case CPTK_HAS_TRIVIAL_ASSIGN:
+    inform (loc_, "    %qT is not trivially copy assignable", t1);
+    break;
+  case CPTK_HAS_TRIVIAL_CONSTRUCTOR:
+    inform (loc_, "    %qT is not trivially default constructible", t1);
+    break;
+  case CPTK_HAS_TRIVIAL_COPY:
+    inform (loc_, "    %qT is not trivially copy copyable", t1);
+    break;
+  case CPTK_HAS_TRIVIAL_DESTRUCTOR:
+    inform (loc_, "    %qT is not trivially destructible", t1);
+    break;
+  case CPTK_HAS_VIRTUAL_DESTRUCTOR:
+    inform (loc_, "    %qT does not have a virtual descructor", t1);
+    break;
+  case CPTK_IS_ABSTRACT:
+    inform (loc_, "    %qT is not an abstract base class", t1);
+    break;
+  case CPTK_IS_BASE_OF:
+    inform (loc_, "    %qT is not a base of %qT", t1, t2);
+    break;
+  case CPTK_IS_CLASS:
+    inform (loc_, "    %qT is not a class", t1);
+    break;
+  case CPTK_IS_CONVERTIBLE_TO: 
+    {
+      tree r = tsubst (t1, args_, tf_none, NULL_TREE);
+      inform (loc_, "    %qT (aka %qT) is not convertible to %qT", t1, r, t2);
+    }
+    break;
+  case CPTK_IS_EMPTY:
+    inform (loc_, "    %qT is not an empty class", t1);
+    break;
+  case CPTK_IS_ENUM:
+    inform (loc_, "    %qT is not an enum", t1);
+    break;
+  case CPTK_IS_FINAL:
+    inform (loc_, "    %qT is not a final class", t1);
+    break;
+  case CPTK_IS_LITERAL_TYPE:
+    inform (loc_, "    %qT is not a literal type", t1);
+    break;
+  case CPTK_IS_POD:
+    inform (loc_, "    %qT is not a pod type", t1);
+    break;
+  case CPTK_IS_POLYMORPHIC:
+    inform (loc_, "    %qT is not a polymorphic type", t1);
+    break;
+  case CPTK_IS_STD_LAYOUT:
+    inform (loc_, "    %qT is not a standard layout type", t1);
+    break;
+  case CPTK_IS_TRIVIAL:
+    inform (loc_, "    %qT is not a trivial type", t1);
+    break;
+  case CPTK_IS_UNION:
+    inform (loc_, "    %qT is not a union", t1);
+    break;
+  case CPTK_IS_SAME:
+    {
+      tree r = tsubst (t1, args_, tf_none, NULL_TREE);
+      inform (loc_, "    %qT (aka %qT) is not the same as %qT", t1, r, t2);
+      break;
+    }
+  default:
+    gcc_unreachable ();
+    break;
+  };
+}
+
+
+// Decide how to print failed constraint check. We print diagnostics for
+// unary constraints in a more readable way than just writing expression.
+void
+constraint_diagnostics::diagnose_basic_check ()
+{
+  // Unpack information associated with the check.
+  tree tid = CALL_EXPR_FN (error_);
+  targs_ = TREE_OPERAND (tid, 1);
+  tfunc_ = OVL_FUNCTION (TREE_OPERAND (tid, 0));
+  
+  if (TREE_VEC_LENGTH (targs_) == 1)
+    diagnose_unary_check ();
+  else
+    diagnose_nary_check ();
+}
+
+void
+constraint_diagnostics::diagnose_unary_check ()
+{
+  tree arg = TREE_VEC_ELT (targs_, 0);
+
+  // Are there going to be additional messages?
+  const char* since = count_causes () > 0 ? " since" : "";
+
+  // Write a different message based on the kind of element expected.
+  // TODO: This is gross. Can we clean it up?
+  if (TYPE_P (arg))
+    {
+      inform (loc_, "  %qT is not a/an %qE type [with %B]%s", 
+              arg, tfunc_, binding_, since);
+    }
+  else if (TREE_CODE (arg) == TEMPLATE_PARM_INDEX)
+    {
+      arg = TEMPLATE_PARM_DECL (arg);
+      inform (loc_, "  %qD is not a/an %qE value [with %B]%s", 
+              arg, tfunc_, binding_, since);
+    }
+  else if (TREE_CODE (arg) == TEMPLATE_DECL)
+    {
+      inform (loc_, "  %qD is not a/an %qE template [with %B]%s", 
+              arg, tfunc_, binding_, since);
+    }
+  else
+    gcc_unreachable ();
+
+  // Print specific causes.
+  diagnose_causes ();
+}
+
+void
+constraint_diagnostics::diagnose_nary_check ()
+{
+  // Are there going to be additional messages?
+  const char* since = count_causes () > 0 ? " since" : "";
+
+  // Write the message.
+  inform (loc_, "  %qE was not satisfied [with %B]%s", error_, binding_, since);
+  
+  // Print specific causes.
+  diagnose_causes ();
+}
+
+void
+constraint_diagnostics::diagnose_variadic_check ()
+{
+  // Unpack information from the context.
+  tree expand = TREE_OPERAND (error_, 0);
+  tree tid = CALL_EXPR_FN (expand);
+  targs_ = TREE_OPERAND (tid, 1);
+  tfunc_ = OVL_FUNCTION (TREE_OPERAND (tid, 0));
+
+  if (TREE_VEC_LENGTH (targs_) == 1)
+    diagnose_distributed_check ();
+  else
+    diagnose_nary_check ();
+}
+
+
+
+// Print diagnostics for "distributed" variadic checks. That is, a unary
+// check applied to all elements of a sequence.
+void
+constraint_diagnostics::diagnose_distributed_check ()
+{
+  tree arg = TREE_VEC_ELT (targs_, 0);
+
+  // Are there going to be additional messages?
+  const char* since = count_causes () > 0 ? " since" : "";
+
+  if (TYPE_P (arg))
+    {
+      inform (loc_, "  some %qT are not %qE types [with %B]%s", 
+              arg, tfunc_, binding_, since);
+    }
+  else if (TREE_CODE (arg) == TEMPLATE_PARM_INDEX)
+    {
+      arg = TEMPLATE_PARM_DECL (arg);
+      inform (loc_, "  some %qD are not %qE values [with %B]%s", 
+              arg, tfunc_, binding_, since);
+    }
+  else if (TREE_CODE (arg) == TEMPLATE_DECL)
+    {
+      inform (loc_, "  some %qD are not %qE templates [with %B]%s", 
+              arg, tfunc_, binding_, since);
+    }
+  else
+    gcc_unreachable ();
+
+  diagnose_causes ();
+}
+
+
+// Print specific reasons for failure.
+void
+constraint_diagnostics::diagnose_causes ()
+{
+  const int MAX_ERROR = 5;
+  int result = 0;
+  int nerrs = TREE_VEC_LENGTH (causes_);
+  int nmsgs = std::min (nerrs, MAX_ERROR);
+  for (int i = 0; i < nmsgs; ++i)
+    {
+      tree cause = TREE_VEC_ELT (causes_, i);
+
+      // Don't be redundant.
+      if (cause == error_)
+        continue;
+
+      // Don't be verbose.
+      if (result == MAX_ERROR)
+        {
+          inform (loc_, "    ... and %d more reason(s)", nerrs - nmsgs);
+          break;
+        }
+
+      diagnose_prop (cause);
+      // ++result;
+    }
+}
+
+
+// Count the number of failure causes that are not duplicates of the primary.
+int
+constraint_diagnostics::count_causes ()
+{
+  int m = 0;
+  int n = TREE_VEC_LENGTH (causes_);
+  for (int i = 0; i < n; ++i) 
+    {
+      tree t = TREE_VEC_ELT (causes_, i);
+      if (t != error_)
+        ++m;
+    }
+  return m;
+}
+
+// Non-zero whenever we're diagnosign constraints.
+// FIXME: I don't think this is being used any more.
+int diagnose_constraints;
+
+void
+diagnose_constraint_errors (location_t loc, tree cxt)
+{
+  ++cp_unevaluated_operand;
+  ++diagnose_constraints;
+  constraint_diagnostics diag (loc, cxt);
+  diag ();
+  --diagnose_constraints;
+  --cp_unevaluated_operand;
+}
+
+bool
+diagnosing_constraint ()
+{
+  return diagnose_constraints > 0;
+}
+
diff --git a/gcc/cp/cp-objcp-common.c b/gcc/cp/cp-objcp-common.c
index 9b7d361..1bd8424 100644
--- a/gcc/cp/cp-objcp-common.c
+++ b/gcc/cp/cp-objcp-common.c
@@ -233,6 +233,7 @@ cp_common_init_ts (void)
   MARK_TS_DECL_NON_COMMON (NAMESPACE_DECL);
   MARK_TS_DECL_NON_COMMON (USING_DECL);
   MARK_TS_DECL_NON_COMMON (TEMPLATE_DECL);
+  MARK_TS_DECL_NON_COMMON (CONCEPT_DECL);
 
   MARK_TS_COMMON (TEMPLATE_TEMPLATE_PARM);
   MARK_TS_COMMON (TEMPLATE_TYPE_PARM);
@@ -274,6 +275,8 @@ cp_common_init_ts (void)
   MARK_TS_TYPED (ARROW_EXPR);
   MARK_TS_TYPED (SIZEOF_EXPR);
   MARK_TS_TYPED (ALIGNOF_EXPR);
+  MARK_TS_TYPED (VALID_EXPR);
+  MARK_TS_TYPED (VALID_TYPE);
   MARK_TS_TYPED (AT_ENCODE_EXPR);
   MARK_TS_TYPED (UNARY_PLUS_EXPR);
   MARK_TS_TYPED (TRAIT_EXPR);
diff --git a/gcc/cp/cp-tree.def b/gcc/cp/cp-tree.def
index b5ed167..4c6428b 100644
--- a/gcc/cp/cp-tree.def
+++ b/gcc/cp/cp-tree.def
@@ -125,6 +125,7 @@ DEFTREECODE (BASELINK, "baselink", tcc_exceptional, 0)
  */
 DEFTREECODE (TEMPLATE_DECL, "template_decl", tcc_declaration, 0)
 
+
 /* Index into a template parameter list.  The TEMPLATE_PARM_IDX gives
    the index (from 0) of the parameter, while the TEMPLATE_PARM_LEVEL
    gives the level (from 1) of the parameter.
@@ -474,6 +475,20 @@ DEFTREECODE (BASES, "bases", tcc_type, 0)
    instantiation time.  */
 DEFTREECODE (TEMPLATE_INFO, "template_info", tcc_exceptional, 0)
 
+/* Concepts-related nodes. */
+
+/* Nodes for testing the validity of syntactic constructs. The VALID_EXPR
+   node checks the validity of an expression and a trait describing constraints
+   on its result type. The VALID_TYPE node checks whether a typename is valid.
+*/
+DEFTREECODE (VALID_EXPR, "valid_expr", tcc_expression, 2)
+DEFTREECODE (VALID_TYPE, "valid_type", tcc_expression, 1)
+
+
+/* A concept definition. A concept is a declaration context containing a
+   set (sequence?) of constraints. */
+DEFTREECODE (CONCEPT_DECL, "concept_decl", tcc_declaration, 0)
+
 /*
 Local variables:
 mode:c
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
index ded247d..9f4064b 100644
--- a/gcc/cp/cp-tree.h
+++ b/gcc/cp/cp-tree.h
@@ -46,6 +46,9 @@ c-common.h, not after.
 
 #include "name-lookup.h"
 
+#include "std.h"
+#include <stack>
+
 /* Usage of TREE_LANG_FLAG_?:
    0: IDENTIFIER_MARKED (IDENTIFIER_NODEs)
       NEW_EXPR_USE_GLOBAL (in NEW_EXPR).
@@ -598,6 +601,7 @@ typedef enum cp_trait_kind
   CPTK_IS_STD_LAYOUT,
   CPTK_IS_TRIVIAL,
   CPTK_IS_UNION,
+  CPTK_IS_SAME,
   CPTK_UNDERLYING_TYPE
 } cp_trait_kind;
 
@@ -984,6 +988,7 @@ struct GTY(()) saved_scope {
   VEC(tree,gc) *lang_base;
   tree lang_name;
   tree template_parms;
+  tree constraints;
   cp_binding_level *x_previous_class_level;
   tree x_saved_tree;
 
@@ -1044,6 +1049,12 @@ struct GTY(()) saved_scope {
 
 #define current_template_parms scope_chain->template_parms
 
+/* Refers to the constraints in the current socpe. We can find
+   the cumulative constraints of any scope by walking up the 
+   scope chain and concatenating constraint vectors. */
+
+#define current_constraints scope_chain->constraints
+
 #define processing_template_decl scope_chain->x_processing_template_decl
 #define processing_specialization scope_chain->x_processing_specialization
 #define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation
@@ -3860,6 +3871,15 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)
 #define DECL_REALLY_EXTERN(NODE) \
   (DECL_EXTERNAL (NODE) && ! DECL_NOT_REALLY_EXTERN (NODE))
 
+// Nonzero if a VAR_DECL is both external and artificial, signifying that
+// it is purely a declared value, and not really an external variable.
+//
+// This is a bit of a hack and should be removed when we get a real
+// constraints language.
+#define DECL_DECLARED_VALUE(NODE) \
+  (DECL_EXTERNAL (NODE) && DECL_ARTIFICIAL (NODE))
+
+
 /* A thunk is a stub function.
 
    A thunk is an alternate entry point for an ordinary FUNCTION_DECL.
@@ -4229,6 +4249,10 @@ extern int function_depth;
 extern int cp_unevaluated_operand;
 extern tree cp_convert_range_for (tree, tree, tree);
 
+// More globals use for concepts.
+extern int cp_constrained_parameter;
+
+
 /* in pt.c  */
 
 /* These values are used for the `STRICT' parameter to type_unification and
@@ -4711,6 +4735,8 @@ typedef struct cp_decl_specifier_seq {
   BOOL_BITFIELD explicit_int128_p : 1;
   /* True iff "char" was explicitly provided.  */
   BOOL_BITFIELD explicit_char_p : 1;
+  /* True iff "__declval" was provided. */
+  BOOL_BITFIELD declval_specifier_p : 1;
 } cp_decl_specifier_seq;
 
 /* The various kinds of declarators.  */
@@ -4756,6 +4782,7 @@ struct cp_declarator {
   location_t id_loc; /* Currently only set for cdk_id and cdk_function. */
   /* Attributes that apply to this declarator.  */
   tree attributes;
+
   /* For all but cdk_id and cdk_error, the contained declarator.  For
      cdk_id and cdk_error, guaranteed to be NULL.  */
   cp_declarator *declarator;
@@ -5325,7 +5352,7 @@ extern tree maybe_update_decl_type		(tree, tree);
 extern bool check_default_tmpl_args             (tree, tree, bool, bool, int);
 extern tree push_template_decl			(tree);
 extern tree push_template_decl_real		(tree, bool);
-extern bool redeclare_class_template		(tree, tree);
+extern bool redeclare_class_template		(tree, tree, tree);
 extern tree lookup_template_class		(tree, tree, tree, tree,
 						 int, tsubst_flags_t);
 extern tree lookup_template_function		(tree, tree);
@@ -5674,6 +5701,124 @@ extern tree nonlambda_method_basetype		(void);
 extern void maybe_add_lambda_conv_op            (tree);
 extern bool is_lambda_ignored_entity            (tree);
 
+// Incremented to indicate that a template's constraints are
+// being compared to those of a template template parameter.
+// This entails a slight modification of the same_type_p
+// protocol.
+extern int checking_template_compatability;
+
+
+// An RAII class that declares when the compiler is processing
+// a constraint in some capacity: parsing, instantiating, 
+// comparing, or evaluating.
+class process_constraint
+{
+public:
+  process_constraint();
+  ~process_constraint();
+
+  static int value;
+};
+
+extern bool processing_constraint               ();
+
+
+// Methods for building and manipulating constraints.
+//
+// FIXME: These names of these functions need to be drastically improved.
+// Consider the following definitions:
+// - proposition -- an atomic term in the constraint language
+// - constraints -- lists of propositions that must be satisfied
+// - requirement -- a logical formula introducing constraints
+extern tree deduce_parameter_declaration        (tree, tree);
+extern tree build_constrained_parameter         (tree, tree, tree);
+extern tree build_shorthand_constraints         (tree);
+
+extern tree conjoin_constraints                 (tree, tree);
+extern tree conjoin_requirements                 (tree, tree);
+
+extern tree left_decompose_constraints          (tree);
+extern tree right_decompose_constraints         (tree);
+extern tree finish_template_constraints         (tree);
+extern tree build_constraint_info               (tree);
+
+extern void constrain_decl                      (tree);
+extern tree take_constraints                    ();
+
+// Constraint satisfaction
+extern tree get_constraints                     (tree);
+extern tree rebuild_constraints                 (tree);
+extern tree deduce_constraint_parameters        (tree, tree);
+extern tree instantiate_proposition             (tree, tree);
+extern tree instantiate_constraint_fn           (tree, tree);
+
+// Constraint evaluation.
+extern bool evaluate_constraints                (tree, tree);
+extern bool evaluate_decl_constraints           (tree, tree);
+extern bool evaluate_type_constraints           (tree, tree);
+
+// Compare constraints
+extern bool same_constraints_p                  (tree, tree);
+extern bool subsumes_constraints_p              (tree, tree);
+
+// Compare declarations
+extern bool similarly_constrained_p             (tree, tree);
+extern bool more_constrained_p                  (tree, tree);
+
+// Argument/parameter matching
+extern bool arguments_match_p                   (tree, tree);
+
+// Misc helper functions
+extern bool is_member_fn                        (tree);
+extern bool is_member_fn_template               (tree);
+extern bool is_non_template_member_fn           (tree);
+
+
+
+// An RAII class that provide support for catching any constraint evaluation 
+// errors. Objects of this type should be created in any context where a
+// constraint is evaluated.
+class constraint_errors
+{
+  class context;
+  static std::vector<context> stack;
+public:
+  constraint_errors ();
+  ~constraint_errors ();
+
+  // Returns true if any errors have occurred.
+  bool has_errors() const;
+
+  // Return the errors for reporting.
+  tree get_errors() const;
+
+  // Print the current errors as diagnostics.
+  void print_errors (location_t);
+
+  // Manage errors
+  static void bind_parameters (tree, tree);
+  static void unsatisfied_proposition (tree);
+  static void substitution_failure (tree);
+  static void ignore ();
+
+private:
+  static bool active ();
+  static context& current ();
+};
+
+extern void diagnose_constraint_errors          (location_t, tree);
+extern bool diagnosing_constraint               ();
+
+
+// Valid expr/type
+extern tree finish_valid_type                   (tree);
+extern tree finish_valid_expr                   (tree, tree);
+extern tree build_is_convertible                (tree, tree);
+extern tree build_is_same                       (tree, tree);
+
+// Concepts
+extern tree build_concept                       (tree, tree, tree);
+
 /* in tree.c */
 extern int cp_tree_operand_length		(const_tree);
 void cp_free_lang_data 				(tree t);
diff --git a/gcc/cp/cxx-pretty-print.c b/gcc/cp/cxx-pretty-print.c
index 03d9149..c8cb6d4 100644
--- a/gcc/cp/cxx-pretty-print.c
+++ b/gcc/cp/cxx-pretty-print.c
@@ -2103,6 +2103,11 @@ static void
 pp_cxx_template_parameter (cxx_pretty_printer *pp, tree t)
 {
   tree parameter =  TREE_VALUE (t);
+
+  // FIXME: Why won't think work!
+  if (tree c = DECL_CONSTRAINT (t))
+    debug_tree (c);
+
   switch (TREE_CODE (parameter))
     {
     case TYPE_DECL:
@@ -2398,6 +2403,9 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)
     case CPTK_IS_LITERAL_TYPE:
       pp_cxx_ws_string (pp, "__is_literal_type");
       break;
+    case CPTK_IS_SAME:
+      pp_cxx_ws_string (pp, "__is_same");
+      break;
 
     default:
       gcc_unreachable ();
@@ -2406,7 +2414,9 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)
   pp_cxx_left_paren (pp);
   pp_cxx_type_id (pp, TRAIT_EXPR_TYPE1 (t));
 
-  if (kind == CPTK_IS_BASE_OF || kind == CPTK_IS_CONVERTIBLE_TO)
+  if (kind == CPTK_IS_BASE_OF || 
+      kind == CPTK_IS_CONVERTIBLE_TO || 
+      kind == CPTK_IS_SAME)
     {
       pp_cxx_separate_with (pp, ',');
       pp_cxx_type_id (pp, TRAIT_EXPR_TYPE2 (t));
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 6b5b986..75e9098 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -930,6 +930,8 @@ push_local_name (tree decl)
   VEC_safe_push (tree, gc, local_names, decl);
   timevar_stop (TV_NAME_LOOKUP);
 }
+
+
 
 /* Subroutine of duplicate_decls: return truthvalue of whether
    or not types of these decls match.
@@ -1038,10 +1040,13 @@ decls_match (tree newdecl, tree olddecl)
 	  != TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)))
 	return 0;
 
+      /* If the templates have different parameter lists, then they
+         do not match. */
       if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),
 				DECL_TEMPLATE_PARMS (olddecl)))
 	return 0;
 
+      /* Compare the underlying declarations. */
       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)
 	types_match = same_type_p (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl)),
 				   TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl)));
@@ -1177,6 +1182,66 @@ validate_constexpr_redeclaration (tree old_decl, tree new_decl)
   return false;
 }
 
+
+/* Returns true if NEWDECL is a class template declaration that
+   conflicts with OLDDECL. */
+
+static bool
+is_conflicting_class_template (tree newdecl, tree olddecl)
+{
+  return TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL
+      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL;
+}
+
+
+/* Returns true if NEWDECL is a function template declaration
+   that conflicts with OLDDECL. */
+
+static inline bool
+is_ambiguous_function_template (tree newdecl, tree olddecl)
+{
+  return TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL
+      && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL
+
+      /* The function argument types are the same. */
+      && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),
+                    TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))))
+
+      /* The template arguments are the same. */
+      && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),
+                              DECL_TEMPLATE_PARMS (olddecl))
+
+      /* Template functions can be disambiguated by return type.  */
+      && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),
+                      TREE_TYPE (TREE_TYPE (olddecl)));
+}
+
+
+/* Returns true when NEWDECL is a function or function template that 
+   is constrained differently from OLDDECL. */
+static inline bool
+are_constrained_overloads (tree newdecl, tree olddecl) 
+{
+  // Don't look at templates. Look at their declarations.
+  if (TREE_CODE (newdecl) == TEMPLATE_DECL)
+    {
+      newdecl = DECL_TEMPLATE_RESULT (newdecl);
+      olddecl = DECL_TEMPLATE_RESULT (olddecl);
+    }
+
+  // They have to be the same kind of decl.
+  if (TREE_CODE (olddecl) != TREE_CODE (newdecl))
+    return false;
+
+  // Non-functions are not overloads.
+  if (TREE_CODE (olddecl) != FUNCTION_DECL)
+    return false;
+
+  // Two functions are constrained overloads when their constraints are
+  // different.
+  return !similarly_constrained_p (olddecl, newdecl);
+}
+
 #define GNU_INLINE_P(fn) (DECL_DECLARED_INLINE_P (fn)			\
 			  && lookup_attribute ("gnu_inline",		\
 					       DECL_ATTRIBUTES (fn)))
@@ -1458,23 +1523,13 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)
 	  /* The name of a class template may not be declared to refer to
 	     any other template, class, function, object, namespace, value,
 	     or type in the same scope.  */
-	  if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL
-	      || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)
+          if (is_conflicting_class_template (newdecl, olddecl))
 	    {
 	      error ("declaration of template %q#D", newdecl);
 	      error ("conflicts with previous declaration %q+#D", olddecl);
 	      return error_mark_node;
 	    }
-	  else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL
-		   && TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL
-		   && compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),
-				 TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))))
-		   && comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),
-					   DECL_TEMPLATE_PARMS (olddecl))
-		   /* Template functions can be disambiguated by
-		      return type.  */
-		   && same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),
-				   TREE_TYPE (TREE_TYPE (olddecl))))
+	  else if (is_ambiguous_function_template (newdecl, olddecl))
 	    {
 	      error ("new declaration %q#D", newdecl);
 	      error ("ambiguates old declaration %q+#D", olddecl);
@@ -1511,6 +1566,11 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)
 	  return error_mark_node;
 	}
     }
+  else if (are_constrained_overloads(newdecl, olddecl))
+    /* If olddecl and newdecl have the same type and are constrained
+       functions or function templates, then newdecl is a viable and
+       non-ambiguous declaration. */
+    return NULL;
   else if (TREE_CODE (newdecl) == FUNCTION_DECL
 	    && ((DECL_TEMPLATE_SPECIALIZATION (olddecl)
 		 && (!DECL_TEMPLATE_INFO (newdecl)
@@ -4519,6 +4579,12 @@ start_decl (const cp_declarator *declarator,
 
   was_public = TREE_PUBLIC (decl);
 
+  /* Take the current constraints and attach them to the 
+     new declaration (which is hopefully just an alias decl). */
+  if (current_constraints)
+    DECL_CONSTRAINT (decl) = take_constraints ();
+
+
   /* Enter this declaration into the symbol table.  */
   decl = maybe_push_decl (decl);
 
@@ -4574,6 +4640,7 @@ start_decl_1 (tree decl, bool initialized)
      (Scalars are always complete types, so there is nothing to
      check.)  This code just sets COMPLETE_P; errors (if necessary)
      are issued below.  */
+  constraint_errors cerrs;
   if ((initialized || aggregate_definition_p) 
       && !complete_p
       && COMPLETE_TYPE_P (complete_type (type)))
@@ -4618,6 +4685,10 @@ start_decl_1 (tree decl, bool initialized)
       type = TREE_TYPE (decl) = error_mark_node;
     }
 
+  // If there were constraint errors, print them.
+  if (type == error_mark_node && cerrs.has_errors ())
+    cerrs.print_errors (input_location);
+
   /* Create a new scope to hold this declaration if necessary.
      Whether or not a new scope is necessary cannot be determined
      until after the type has been completed; if the type is a
@@ -7188,6 +7259,10 @@ grokfndecl (tree ctype,
 
   decl = build_lang_decl (FUNCTION_DECL, declarator, type);
 
+  // Take the current constraints and attach them to the new function
+  // declaration.
+  DECL_CONSTRAINT (decl) = take_constraints ();
+
   /* If we have an explicit location, use it, otherwise use whatever
      build_lang_decl used (probably input_location).  */
   if (location != UNKNOWN_LOCATION)
@@ -7503,7 +7578,6 @@ grokfndecl (tree ctype,
 				      > template_class_depth (ctype))
 				     ? current_template_parms
 				     : NULL_TREE);
-
       if (old_decl == error_mark_node)
 	return NULL_TREE;
 
@@ -7664,6 +7738,10 @@ grokvardecl (tree type,
     {
       DECL_THIS_EXTERN (decl) = 1;
       DECL_EXTERNAL (decl) = !initialized;
+
+      // A declval specified-variable is also "artificial".
+      if (declspecs->declval_specifier_p)
+        DECL_ARTIFICIAL (decl) = true;
     }
 
   if (DECL_CLASS_SCOPE_P (decl))
@@ -8453,6 +8531,7 @@ grokdeclarator (const cp_declarator *declarator,
   explicit_int128 = declspecs->explicit_int128_p;
   thread_p = decl_spec_seq_has_spec_p (declspecs, ds_thread);
 
+
   if (decl_context == FUNCDEF)
     funcdef_flag = true, decl_context = NORMAL;
   else if (decl_context == MEMFUNCDEF)
@@ -11742,7 +11821,9 @@ xref_tag_1 (enum tag_types tag_code, tree name,
     {
       if (template_header_p && MAYBE_CLASS_TYPE_P (t))
         {
-	  if (!redeclare_class_template (t, current_template_parms))
+	  if (!redeclare_class_template (t, 
+                                         current_template_parms, 
+                                         current_constraints))
             return error_mark_node;
         }
       else if (!processing_template_decl
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
index 0df4613..4438f5d 100644
--- a/gcc/cp/decl2.c
+++ b/gcc/cp/decl2.c
@@ -602,7 +602,8 @@ check_classfn (tree ctype, tree function, tree template_parms)
   int ix;
   bool is_template;
   tree pushed_scope;
-  
+
+
   if (DECL_USE_TEMPLATE (function)
       && !(TREE_CODE (function) == TEMPLATE_DECL
 	   && DECL_TEMPLATE_SPECIALIZATION (function))
@@ -674,9 +675,12 @@ check_classfn (tree ctype, tree function, tree template_parms)
 	  if (is_template != (TREE_CODE (fndecl) == TEMPLATE_DECL))
 	    continue;
 
+    // Does the function declaration match a previous declaration in
+    // the class?
 	  if (same_type_p (TREE_TYPE (TREE_TYPE (function)),
 			   TREE_TYPE (TREE_TYPE (fndecl)))
 	      && compparms (p1, p2)
+        && similarly_constrained_p (function, fndecl)
 	      && (!is_template
 		  || comp_template_parms (template_parms,
 					  DECL_TEMPLATE_PARMS (fndecl)))
@@ -685,7 +689,7 @@ check_classfn (tree ctype, tree function, tree template_parms)
 	      && (!DECL_TEMPLATE_SPECIALIZATION (function)
 		  || (DECL_TI_TEMPLATE (function)
 		      == DECL_TI_TEMPLATE (fndecl))))
-	    break;
+            break;
 	}
       if (fndecls)
 	{
@@ -801,6 +805,7 @@ grokfield (const cp_declarator *declarator,
   int flags;
   tree name;
 
+
   if (init
       && TREE_CODE (init) == TREE_LIST
       && TREE_VALUE (init) == error_mark_node
@@ -829,7 +834,6 @@ grokfield (const cp_declarator *declarator,
     return value;
 
   name = DECL_NAME (value);
-
   if (name != NULL_TREE)
     {
       if (TREE_CODE (name) == TEMPLATE_ID_EXPR)
diff --git a/gcc/cp/error.c b/gcc/cp/error.c
index 30fa018..951c453 100644
--- a/gcc/cp/error.c
+++ b/gcc/cp/error.c
@@ -51,6 +51,7 @@ static cxx_pretty_printer scratch_pretty_printer;
 # define NEXT_CODE(T) (TREE_CODE (TREE_TYPE (T)))
 
 static const char *args_to_string (tree, int);
+static const char* bindings_to_string (tree);
 static const char *assop_to_string (enum tree_code);
 static const char *code_to_string (enum tree_code);
 static const char *cv_to_string (tree, int);
@@ -916,6 +917,10 @@ dump_global_iord (tree t)
 static void
 dump_simple_decl (tree t, tree type, int flags)
 {
+  // Don't print scope names for extern declarations encountered wen
+  // diagnosing constraint. 
+  bool constraint_parm_p = DECL_EXTERNAL (t) && DECL_ARTIFICIAL (t);
+ 
   if (flags & TFF_DECL_SPECIFIERS)
     {
       if (TREE_CODE (t) == VAR_DECL
@@ -925,8 +930,9 @@ dump_simple_decl (tree t, tree type, int flags)
       pp_maybe_space (cxx_pp);
     }
   if (! (flags & TFF_UNQUALIFIED_NAME)
-      && TREE_CODE (t) != PARM_DECL
-      && (!DECL_INITIAL (t)
+      && !constraint_parm_p
+      && (TREE_CODE (t) != PARM_DECL)
+      && (!DECL_INITIAL (t) 
 	  || TREE_CODE (DECL_INITIAL (t)) != TEMPLATE_PARM_INDEX))
     dump_scope (CP_DECL_CONTEXT (t), flags);
   flags &= ~TFF_UNQUALIFIED_NAME;
@@ -2486,6 +2492,21 @@ dump_expr (tree t, int flags)
       dump_expr (resolve_virtual_fun_from_obj_type_ref (t), flags);
       break;
 
+    case VALID_EXPR:
+      pp_string (cxx_pp, "__is_valid_expr (");
+      dump_expr (TREE_OPERAND (t, 0), flags);
+      pp_string (cxx_pp, ", ");
+      dump_expr (TREE_OPERAND (t, 1), flags);
+      pp_string (cxx_pp, ")");
+      break;
+    
+    case VALID_TYPE:
+      pp_string (cxx_pp, "__is_valid_type (");
+      dump_expr (TREE_OPERAND (t, 0), flags);
+      pp_string (cxx_pp, ")");
+      break;
+
+
       /*  This list is incomplete, but should suffice for now.
 	  It is very important that `sorry' does not call
 	  `report_error_function'.  That could cause an infinite loop.  */
@@ -2493,7 +2514,6 @@ dump_expr (tree t, int flags)
       pp_unsupported_tree (cxx_pp, t);
       /* fall through to ERROR_MARK...  */
     case ERROR_MARK:
-      pp_string (cxx_pp, M_("<expression error>"));
       break;
     }
 }
@@ -2825,6 +2845,19 @@ args_to_string (tree p, int verbose)
   return pp_formatted_text (cxx_pp);
 }
 
+// Pretty print template bindings, given in a list node T. The purpose contains
+// the parameters and the value contains the arguments.
+static const char *
+bindings_to_string (tree t)
+{
+  tree parms = TREE_PURPOSE (t);
+  tree args = TREE_VALUE (t);
+
+  reinit_cxx_pp ();
+  dump_template_bindings (parms, args, NULL);
+  return pp_formatted_text (cxx_pp);
+}
+
 /* Pretty-print a deduction substitution (from deduction_tsubst_fntype).  P
    is a TREE_LIST with purpose the TEMPLATE_DECL, value the template
    arguments.  */
@@ -3229,6 +3262,7 @@ maybe_print_constexpr_context (diagnostic_context *context)
 /* Called from output_format -- during diagnostic message processing --
    to handle C++ specific format specifier with the following meanings:
    %A   function argument-list.
+   %B   template bindings
    %C	tree code.
    %D   declaration.
    %E   expression.
@@ -3259,6 +3293,7 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,
   switch (*spec)
     {
     case 'A': result = args_to_string (next_tree, verbose);	break;
+    case 'B': result = bindings_to_string (next_tree);          break;
     case 'C': result = code_to_string (next_tcode);		break;
     case 'D':
       {
diff --git a/gcc/cp/lex.c b/gcc/cp/lex.c
index d4aebf7..5866163 100644
--- a/gcc/cp/lex.c
+++ b/gcc/cp/lex.c
@@ -615,7 +615,7 @@ tree
 copy_decl (tree decl)
 {
   tree copy;
-
+  
   copy = copy_node (decl);
   cxx_dup_lang_specific_decl (copy);
   return copy;
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
index e4e9827..0162191 100644
--- a/gcc/cp/name-lookup.c
+++ b/gcc/cp/name-lookup.c
@@ -5523,7 +5523,19 @@ lookup_arg_dependent_1 (tree name, tree fns, VEC(tree,gc) *args,
       gcc_assert (DECL_NAMESPACE_SCOPE_P (OVL_CURRENT (fns)));
       k.fn_set = pointer_set_create ();
       for (ovl = fns; ovl; ovl = OVL_NEXT (ovl))
-	pointer_set_insert (k.fn_set, OVL_CURRENT (ovl));
+        {
+          tree fn = OVL_CURRENT (ovl);
+	  pointer_set_insert (k.fn_set, fn);
+
+          // Associate functions in the candidate's namespace so 
+          // that we can guarantee the inclusion of constrained 
+          // functions defined after the point of instantiation 
+          // (when the arguments are primitive  types).
+          //
+          // FIXME: This might go away.
+          arg_assoc_namespace (&k, decl_namespace_context (fn));
+
+        }
     }
   else
     k.fn_set = NULL;
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
index e8c0378..f43f3ad 100644
--- a/gcc/cp/parser.c
+++ b/gcc/cp/parser.c
@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "plugin.h"
 #include "tree-pretty-print.h"
 #include "parser.h"
+#include "std.h"
 
 
 /* The lexer.  */
@@ -168,6 +169,13 @@ typedef enum required_token {
   RT_AT_SYNCHRONIZED, /* @synchronized */
   RT_AT_THROW, /* @throw */
 
+  /* Concept-related keywords */
+  RT_ASSUME,    /* assume */
+  RT_AXIOM,     /* axiom */
+  RT_CONCEPT,   /* concept */
+  RT_FORALL,    /* forall */
+  RT_REQUIRES,  /* requires */
+
   RT_SELECT,  /* selection-statement */
   RT_INTERATION, /* iteration-statement */
   RT_JUMP, /* jump-statement */
@@ -245,6 +253,13 @@ static FILE *cp_lexer_debug_stream;
    sizeof, typeof, or alignof.  */
 int cp_unevaluated_operand;
 
+
+// Nonzero if we are parsing a constained parameter. This is
+// used to prevent some early type checking against partially
+// constrained parameters in cp_parser_template_id.
+int cp_constrained_parameter;
+
+
 /* Dump up to NUM tokens in BUFFER to FILE starting with token
    START_TOKEN.  If START_TOKEN is NULL, the dump starts with the
    first token in BUFFER.  If NUM is 0, dump all the tokens.  If
@@ -2108,6 +2123,43 @@ static bool cp_parser_extension_opt
 static void cp_parser_label_declaration
   (cp_parser *);
 
+// Constraints
+static void cp_parser_begin_unevaluated
+  (void);
+static void cp_parser_end_unevaluated
+  (void);
+static tree cp_parser_current_requirements 
+  ();
+static tree cp_parser_template_requirements
+  (cp_parser *);
+static tree cp_parser_function_requirements
+  (cp_parser *);
+static tree cp_parser_requirement_list
+  (cp_parser *, bool);
+static tree cp_parser_shorthand_constraint_expression 
+  (cp_parser *parser);
+static tree cp_parser_constrained_parameter
+  (cp_parser *, bool *, bool *);
+
+// Valid expressions and types
+static tree cp_parser_valid_expr
+  (cp_parser *);
+static tree cp_parser_valid_expr_requirement
+  (cp_parser *);
+static tree cp_parser_valid_expr_conversion
+  (cp_parser *, tree);
+static tree cp_parser_valid_expr_equivalence
+  (cp_parser *, tree);
+static tree cp_parser_valid_expr_syntax
+  (cp_parser *);
+static tree cp_parser_valid_type
+  (cp_parser *);
+
+
+// Concepts
+static tree cp_parser_concept_definition
+  (cp_parser *);
+
 /* Transactional Memory Extensions */
 
 static tree cp_parser_transaction
@@ -2310,6 +2362,7 @@ static tree cp_parser_make_typename_type
 static cp_declarator * cp_parser_make_indirect_declarator
   (enum tree_code, tree, cp_cv_quals, cp_declarator *);
 
+
 /* Returns nonzero if we are parsing tentatively.  */
 
 static inline bool
@@ -3830,6 +3883,9 @@ cp_parser_translation_unit (cp_parser* parser)
      __is_trivial ( type-id )
      __is_union ( type-id )
 
+  Concept Extensions:
+     __is_same (type-id, type-id)
+
    Objective-C++ Extension:
 
    primary-expression:
@@ -4177,6 +4233,7 @@ cp_parser_primary_expression (cp_parser *parser,
 	case RID_IS_STD_LAYOUT:
 	case RID_IS_TRIVIAL:
 	case RID_IS_UNION:
+        case RID_IS_SAME:
 	  return cp_parser_trait_expr (parser, token->keyword);
 
 	/* Objective-C++ expressions.  */
@@ -5744,7 +5801,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,
 					/*disallow_virtual=*/false,
 					/*koenig_p=*/false,
 					tf_warning_or_error);
-	      }
+              }
 	    else if (TREE_CODE (postfix_expression) == OFFSET_REF
 		     || TREE_CODE (postfix_expression) == MEMBER_REF
 		     || TREE_CODE (postfix_expression) == DOTSTAR_EXPR)
@@ -5825,6 +5882,27 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,
 	default:
 	  if (pidk_return != NULL)
 	    * pidk_return = idk;
+
+          // The constraint language allows the expansion of postfix 
+          // expressions as propositions. 
+          //
+          // TODO: This isn't quite right... I can only apply ellipses to
+          // top-level terms in the constraint language. This, for example,
+          // is not allowed:
+          //
+          //    requires (a == b...)
+          //
+          // That clearly has no meaning. This is strong motivation for 
+          // building by own parser for this language.
+          if (processing_constraint ())
+            {
+              if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))
+                {
+                  cp_lexer_consume_token (parser->lexer);
+                  postfix_expression = make_pack_expansion (postfix_expression);
+                }
+            }
+
           if (member_access_only_p)
             return is_member_access? postfix_expression : error_mark_node;
           else
@@ -6385,7 +6463,9 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,
 	    tree operand;
 	    enum tree_code op;
 
-	    op = keyword == RID_ALIGNOF ? ALIGNOF_EXPR : SIZEOF_EXPR;
+            // Derive the expression type from the parsed keyword.
+            op = keyword == RID_ALIGNOF ? ALIGNOF_EXPR : SIZEOF_EXPR;
+
 	    /* Consume the token.  */
 	    cp_lexer_consume_token (parser->lexer);
 	    /* Parse the operand.  */
@@ -6496,6 +6576,11 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,
 	    return finish_noexcept_expr (expr, tf_warning_or_error);
 	  }
 
+        case RID_IS_VALID_EXPR:
+          return cp_parser_valid_expr (parser);
+        case RID_IS_VALID_TYPE:
+          return cp_parser_valid_type (parser);
+
 	default:
 	  break;
 	}
@@ -7907,6 +7992,10 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)
       kind = CPTK_IS_CONVERTIBLE_TO;
       binary = true;
       break;
+    case RID_IS_SAME:
+      kind = CPTK_IS_SAME;
+      binary = true;
+      break;
     case RID_IS_EMPTY:
       kind = CPTK_IS_EMPTY;
       break;
@@ -10120,7 +10209,10 @@ cp_parser_declaration_seq_opt (cp_parser* parser)
    GNU extension:
 
    declaration:
-      __extension__ declaration */
+      __extension__ declaration 
+
+   Concept extension:
+      concept-definition */
 
 static void
 cp_parser_declaration (cp_parser* parser)
@@ -10177,6 +10269,11 @@ cp_parser_declaration (cp_parser* parser)
       else
 	cp_parser_explicit_instantiation (parser);
     }
+  else if (token1.keyword == RID_CONCEPT && cxx_dialect >= cxx1y)
+    {
+      // Parse a concept definition.
+      cp_parser_concept_definition (parser);
+    }
   /* If the next token is `export', then we have a template
      declaration.  */
   else if (token1.keyword == RID_EXPORT)
@@ -10678,6 +10775,11 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
 	    found_decl_spec = false;
           break;
 
+        case RID_DECLVAL:
+          // This essentially an alias for extern, but a little different.
+          decl_specs->declval_specifier_p = true;
+          token->keyword = RID_EXTERN;
+
 	case RID_REGISTER:
 	case RID_STATIC:
 	case RID_EXTERN:
@@ -10687,6 +10789,7 @@ cp_parser_decl_specifier_seq (cp_parser* parser,
           cp_parser_set_storage_class (parser, decl_specs, token->keyword,
 				       token->location);
 	  break;
+
 	case RID_THREAD:
 	  /* Consume the token.  */
 	  ds = ds_thread;
@@ -12068,6 +12171,21 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,
 	return cp_parser_type_parameter (parser, is_parameter_pack);
     }
 
+  // Try to parse this as a constrained template parameter before
+  // anything else.
+  if (cxx_dialect >= cxx1y)
+    {
+      bool pack = false;
+      bool nontype = false;
+      tree parm = cp_parser_constrained_parameter (parser, &pack, &nontype); 
+      if (parm != NULL_TREE)
+        {
+          *is_parameter_pack = pack;
+          *is_non_type = nontype;
+           return parm;
+        }
+    }
+
   /* Otherwise, it is a non-type parameter.
 
      [temp.param]
@@ -12078,7 +12196,8 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,
      operator.  */
   *is_non_type = true;
   parameter_declarator
-     = cp_parser_parameter_declaration (parser, /*template_parm_p=*/true,
+     = cp_parser_parameter_declaration (parser, 
+                                        /*template_parm_p=*/true,
 					/*parenthesized_p=*/NULL);
 
   /* If the parameter declaration is marked as a parameter pack, set
@@ -12103,7 +12222,6 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,
       /* Consume the `...'.  */
       cp_lexer_consume_token (parser->lexer);
       maybe_warn_variadic_templates ();
-      
       *is_parameter_pack = true;
     }
   /* We might end up with a pack expansion as the type of the non-type
@@ -12147,6 +12265,7 @@ cp_parser_template_parameter (cp_parser* parser, bool *is_non_type,
 			 &parameter_declarator->decl_specifiers,
 			 TPARM, /*initialized=*/0,
 			 /*attrlist=*/NULL);
+
   if (parm == error_mark_node)
     return error_mark_node;
 
@@ -12261,6 +12380,31 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)
 	cp_parser_template_parameter_list (parser);
 	/* Look for the `>'.  */
 	cp_parser_require (parser, CPP_GREATER, RT_GREATER);
+
+        // Build the constraints for the parameter list and then parse any
+        // subsequent requirements.
+        //
+        // Save and reset the current constraints. Those given for a template
+        // template parameter are independent of the rest of the class.
+        tree saved_constraints = current_constraints;
+        current_constraints = NULL_TREE;
+
+        // Extract any shorthand constraints.
+        tree tmpl_parms = TREE_VALUE (current_template_parms);
+        tree short_reqs = build_shorthand_constraints (tmpl_parms);
+
+        // Parse and analyze a requires clause.
+        if (cxx_dialect >= cxx1y)
+          {
+            tree tmpl_reqs = NULL_TREE;
+            if (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES))
+                tmpl_reqs = cp_parser_template_requirements (parser);
+
+            // Join those requiremens, and build the constraint info.
+            tree cons = conjoin_requirements (short_reqs, tmpl_reqs);
+            current_constraints = finish_template_constraints (cons);
+          }
+
 	/* Look for the `class' keyword.  */
 	cp_parser_require_keyword (parser, RID_CLASS, RT_CLASS);
         /* If the next token is an ellipsis, we have a template
@@ -12289,10 +12433,14 @@ cp_parser_type_parameter (cp_parser* parser, bool *is_parameter_pack)
 	else
 	  identifier = NULL_TREE;
 
+
 	/* Create the template parameter.  */
 	parameter = finish_template_template_parm (class_type_node,
 						   identifier);
 
+        // Restore the current constraints.
+        current_constraints = saved_constraints;
+
 	/* If the next token is an `=', then there is a
 	   default-argument.  */
 	if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))
@@ -12449,6 +12597,12 @@ cp_parser_template_id (cp_parser *parser,
       return templ;
     }
 
+  // Some irony here... Turns off the rules for constraint checking when we
+  // parse arguments of a (potentially) constrained template argument. We want
+  // everything other than the outermost argument to be handled in the usual
+  // way.
+  --cp_constrained_parameter;
+
   /* If we find the sequence `[:' after a template-name, it's probably
      a digraph-typo for `< ::'. Substitute the tokens and check if we can
      parse correctly the argument list.  */
@@ -12507,25 +12661,52 @@ cp_parser_template_id (cp_parser *parser,
       arguments = cp_parser_enclosed_template_argument_list (parser);
     }
 
-  /* Build a representation of the specialization.  */
+  // Re-enable the parsing of the constraint.
+  ++cp_constrained_parameter;
+
+
+  /* Build a representation of the specialization. 
+
+     FIXME [Concetps]: This might cause problems if we want to allow weird 
+     scoped concept definitions like this:
+
+        template <typename T, typename U, C1<T>::C2<U> V>
+
+     where C1 is a class template. If we don't try to fully resolve the
+     name C1<T>, then the parser won't enter the scope and we won't be able
+     to find C2. The better solution might be to hand a flag off to 
+     finish_template_type and allow that (actually lookup_template_class) to
+     handle this weirdness.
+     */
   if (TREE_CODE (templ) == IDENTIFIER_NODE)
     template_id = build_min_nt_loc (next_token->location,
-				    TEMPLATE_ID_EXPR,
+                                    TEMPLATE_ID_EXPR,
 				    templ, arguments);
-  else if (DECL_TYPE_TEMPLATE_P (templ)
-	   || DECL_TEMPLATE_TEMPLATE_PARM_P (templ))
-    {
-      bool entering_scope;
-      /* In "template <typename T> ... A<T>::", A<T> is the abstract A
-	 template (rather than some instantiation thereof) only if
-	 is not nested within some other construct.  For example, in
-	 "template <typename T> void f(T) { A<T>::", A<T> is just an
-	 instantiation of A.  */
-      entering_scope = (template_parm_scope_p ()
-			&& cp_lexer_next_token_is (parser->lexer,
-						   CPP_SCOPE));
-      template_id
-	= finish_template_type (templ, arguments, entering_scope);
+  else if (DECL_TYPE_TEMPLATE_P (templ) || DECL_TEMPLATE_TEMPLATE_PARM_P (templ))
+    {
+      if (cp_constrained_parameter > 0)
+        {
+          // If we're parsing a constrained parameter, we don't want to do the
+          // full template type -- that checks arguments, etc. We simply want a
+          // template id consisting of the declaration and a set of arguments.
+          // We resolve those in build_constraint_expression.
+          template_id = build_min_nt_loc (next_token->location,
+                                          TEMPLATE_ID_EXPR,
+                                          templ, arguments);
+        }
+      else
+        {
+          /* In "template <typename T> ... A<T>::", A<T> is the abstract A
+             template (rather than some instantiation thereof) only if
+    	       is not nested within some other construct.  For example, in
+    	       "template <typename T> void f(T) { A<T>::", A<T> is just an
+    	       instantiation of A.  */
+          bool entering_scope = (template_parm_scope_p ()
+    			         && cp_lexer_next_token_is (parser->lexer,
+    				                            CPP_SCOPE));
+
+          template_id = finish_template_type (templ, arguments, entering_scope);
+        }
     }
   else
     {
@@ -13590,6 +13771,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,
       break;
 
     case RID_DECLTYPE:
+
       /* Since DR 743, decltype can either be a simple-type-specifier by
 	 itself or begin a nested-name-specifier.  Parsing it will replace
 	 it with a CPP_DECLTYPE, so just rewind and let the CPP_DECLTYPE
@@ -13614,6 +13796,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,
 
       return type;
 
+
     case RID_UNDERLYING_TYPE:
       type = cp_parser_trait_expr (parser, RID_UNDERLYING_TYPE);
       if (decl_specs)
@@ -13649,6 +13832,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,
       return type;
     }
 
+
   /* If the type-specifier was for a built-in type, we're done.  */
   if (type)
     {
@@ -16052,6 +16236,7 @@ cp_parser_direct_declarator (cp_parser* parser,
 	  if (!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)
 	    {
 	      tree params;
+              tree function_req;
 	      unsigned saved_num_template_parameter_lists;
 	      bool is_declarator = false;
 	      tree t;
@@ -17832,6 +18017,7 @@ cp_parser_class_name (cp_parser *parser,
       identifier_token = cp_lexer_peek_token (parser->lexer);
       ambiguous_p = identifier_token->ambiguous_p;
       identifier = cp_parser_identifier (parser);
+
       /* If the next token isn't an identifier, we are certainly not
 	 looking at a class-name.  */
       if (identifier == error_mark_node)
@@ -17888,6 +18074,7 @@ cp_parser_class_name (cp_parser *parser,
 	return error_mark_node;
     }
 
+
   decl = cp_parser_maybe_treat_template_as_class (decl, class_head_p);
 
   /* If this is a typename, create a TYPENAME_TYPE.  */
@@ -17965,6 +18152,7 @@ cp_parser_class_specifier_1 (cp_parser* parser)
   /* Parse the class-head.  */
   type = cp_parser_class_head (parser,
 			       &nested_name_specifier_p);
+
   /* If the class-head was a semantic disaster, skip the entire body
      of the class.  */
   if (!type)
@@ -18391,11 +18579,13 @@ cp_parser_class_head (cp_parser* parser,
       cp_parser_parse_tentatively (parser);
       /* Check for a template-id.  */
       type_start_token = cp_lexer_peek_token (parser->lexer);
+
       id = cp_parser_template_id (parser,
 				  /*template_keyword_p=*/false,
 				  /*check_dependency_p=*/true,
 				  class_key,
 				  /*is_declaration=*/true);
+
       /* If that didn't work, it could still be an identifier.  */
       if (!cp_parser_parse_definitely (parser))
 	{
@@ -18520,6 +18710,7 @@ cp_parser_class_head (cp_parser* parser,
       ++parser->num_template_parameter_lists;
       begin_specialization ();
     }
+
   /* There must be no "return" statements between this point and the
      end of this function; set "type "to the correct return value and
      use "goto done;" to return.  */
@@ -18822,6 +19013,27 @@ cp_parser_member_declaration (cp_parser* parser)
       return;
     }
 
+  // Constraints on non-template members include the constraints on the
+  // enclosing class.
+  tree saved_constraints = current_constraints;
+  if (cxx_dialect >= cxx1y)
+    {
+      if (current_template_parms)
+        {
+          // Get the constraints for this member.
+          tree cons = NULL_TREE;
+          if (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES))
+              cons = cp_parser_template_requirements (parser);
+
+          // Build the total constraints on the member
+          current_constraints = finish_template_constraints (cons);
+
+          // Template or using declarations cannot be constrained.
+          if (cons)
+            goto declspec_seq;
+        }
+    }
+
   /* Check for a template-declaration.  */
   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TEMPLATE))
     {
@@ -18888,6 +19100,11 @@ cp_parser_member_declaration (cp_parser* parser)
   if (cp_parser_using_declaration (parser, /*access_declaration=*/true))
       goto out;
 
+  // Added so we can skip tests for non-"requirable" declarations (e.g.,
+  // templates).
+declspec_seq:
+
+
   /* Parse the decl-specifier-seq.  */
   decl_spec_token_start = cp_lexer_peek_token (parser->lexer);
   cp_parser_decl_specifier_seq (parser,
@@ -18896,6 +19113,7 @@ cp_parser_member_declaration (cp_parser* parser)
 				&declares_class_or_enum);
   prefix_attributes = decl_specifiers.attributes;
   decl_specifiers.attributes = NULL_TREE;
+
   /* Check for an invalid type-name.  */
   if (!decl_specifiers.any_type_specifiers_p
       && cp_parser_parse_and_diagnose_invalid_type_name (parser))
@@ -19175,9 +19393,11 @@ cp_parser_member_declaration (cp_parser* parser)
 							      &decl_specifiers,
 							      declarator,
 							      attributes);
+
 		  /* If the member was not a friend, declare it here.  */
 		  if (!friend_p)
 		    finish_member_declaration (decl);
+
 		  /* Peek at the next token.  */
 		  token = cp_lexer_peek_token (parser->lexer);
 		  /* If the next token is a semicolon, consume it.  */
@@ -19188,7 +19408,7 @@ cp_parser_member_declaration (cp_parser* parser)
 	      else
 		if (declarator->kind == cdk_function)
 		  declarator->id_loc = token->location;
-		/* Create the declaration.  */
+                /* Create the declaration.  */
 		decl = grokfield (declarator, &decl_specifiers,
 				  initializer, /*init_const_expr_p=*/true,
 				  asm_specification,
@@ -19249,6 +19469,9 @@ cp_parser_member_declaration (cp_parser* parser)
 
   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
  out:
+  // Restore any constraints on the class.
+  current_constraints = saved_constraints;
+
   parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;
 }
 
@@ -20318,6 +20541,622 @@ cp_parser_label_declaration (cp_parser* parser)
   cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);
 }
 
+
+// Return the requiremetns for the current scope or NULL tree if no requirments
+// have been assumed.
+tree
+cp_parser_current_requirements ()
+{
+  if (current_constraints)
+    return TREE_VEC_ELT (current_constraints, 4);
+  else
+    return NULL_TREE;
+}
+
+
+
+
+/* Enter into an unevaluated context. Any expressions parsed after calling this
+   will not be evaluated and will not generate evaluation warnings. The
+   function cp_parser_end_unevaluated must called once for each corresponding
+   call of this function. */
+
+static void
+cp_parser_begin_unevaluated (void)
+{
+  ++cp_unevaluated_operand;
+  ++c_inhibit_evaluation_warnings;
+}
+
+/* Leave an unevaluated context. This must be called to exit a previously
+   entered unevaluated context. */
+
+static void
+cp_parser_end_unevaluated (void)
+{
+  --c_inhibit_evaluation_warnings;
+  --cp_unevaluated_operand;
+}
+
+
+// Parse a template requirement of the form:
+// 
+//   template-requirement:
+//     requires constant-expression
+// 
+// Returns a tree containing the parsed requirement.
+static tree
+cp_parser_template_requirements (cp_parser* parser)
+{
+  return cp_parser_requirement_list (parser, true);
+}
+
+/* Parse a function requirement of the form:
+
+   function-requirement:
+     requires expression
+
+   The expression following the 'requires' keyword is parsed in an unevaluated
+   context (like decltype). Evaluation of requirements is not the same as
+   evaluation by the abstract machine.
+
+   Returns a vector containing the parsed requirement expressions. 
+
+   TOOD: See notes on cp_parser_template_requirements. */
+
+static tree
+cp_parser_function_requirements (cp_parser* parser)
+{
+  // Parse the sequence of requirements in an unevaluated context. 
+  // Note that the requirments are not parsed as constant expressions.
+  cp_parser_begin_unevaluated ();
+  tree reqs = cp_parser_requirement_list (parser, false);
+  cp_parser_end_unevaluated ();
+  return reqs;
+}
+
+
+/* Parse a sequence of requirements. That is:
+
+   requirement-list:
+     expression
+     requirement-list, expression
+
+   Returns a vector of trees.  Each element is a representation of an
+   expression.  NULL is returned if the expression cannot be parsed. 
+
+   If AS_CONSTANT_EXPR is true, the requirement list is parsed as a constant
+   expression. If it is not true, then the requirement list is parsed in an
+   unevaluated context.
+   */
+static tree
+cp_parser_requirement_list (cp_parser* parser, bool as_constant_expr)
+{
+  process_constraint guard;
+  cp_parser_require_keyword (parser, RID_REQUIRES, RT_REQUIRES);
+  tree reqs = cp_parser_binary_expression (parser, false, true, PREC_NOT_OPERATOR, 0);
+  if (!reqs)
+    return NULL_TREE;
+  
+  if (!potential_rvalue_constant_expression (reqs))
+    require_potential_rvalue_constant_expression (reqs);
+
+  // Force the type of the expression to be bool.
+  // FIXME: This may be (is probably?) not the right thing to do.
+  TREE_TYPE (reqs) = boolean_type_node;
+  return reqs;
+}
+
+
+/* Parse a shorthand constraint expresson. A shorthand constraint is an
+   id-expression.
+
+   TODO: Will an id expression also include template arguments? We're going
+   to need for this to happen so I can constrain parameters using this
+   notation:
+
+   C<X> T -- which becomes -- C<T, X> 
+*/
+static tree
+cp_parser_constraint_id (cp_parser *parser)
+{
+  ++cp_constrained_parameter;
+  tree t =  cp_parser_id_expression (parser, /*template_keyword_p*/false,
+                                             /*check_dependency_p*/false,
+                                             /*template_p*/NULL,
+                                             /*declarator_p*/false,
+                                             /*optional_p*/false);
+  --cp_constrained_parameter;
+  return t;
+}
+
+/* Returns the identifier naming the constraining template or concept. If
+   EXPR is an identifier, then this returns the same name. If EXPR is
+   a template id expression, we return the 1ast argument of that expression,
+   the template name. */
+
+static tree
+cp_parser_constraint_name (tree expr)
+{
+  switch (TREE_CODE (expr))
+    {
+    case IDENTIFIER_NODE:
+      return expr;
+    case TEMPLATE_ID_EXPR:
+      return cp_parser_constraint_name (TREE_OPERAND (expr, 0));
+    case OVERLOAD:
+      /* A template id expression can refer to a function. */
+      return cp_parser_constraint_name (OVL_FUNCTION (expr));
+    case TEMPLATE_DECL:
+      /* An overload refers to function template decls (hopefully). */
+      return DECL_NAME (expr);
+    default:
+      /* This should never be the case. */
+      gcc_assert (false);
+    }
+}
+
+static void
+cp_parser_default_parameter_packs (tree identifier)
+{
+  if (identifier)
+    error_at (EXPR_LOCATION (identifier),
+              "template parameter pack %qD cannot have a "
+              "default argument", identifier);
+  else
+    error_at (EXPR_LOCATION (identifier),
+              "template parameter packs cannot have "
+              "default arguments");
+}
+
+
+// TODO: Unify this implementation with that in cp_parser_type_parameter.
+static tree
+cp_parser_default_type_argument (cp_parser *parser, 
+                                 tree identifier,
+                                 bool is_parameter_pack)
+{
+  tree arg;
+
+  /* Parse the default-argument.  */
+  push_deferring_access_checks (dk_no_deferred);
+  arg = cp_parser_type_id (parser);
+
+  /* Template parameter packs cannot have default arguments. */
+  if (is_parameter_pack)
+    {
+      cp_parser_default_parameter_packs (identifier);
+      arg = NULL_TREE;
+    }
+  pop_deferring_access_checks ();
+  
+  return arg;
+}
+
+// TODO: Unify this implementation with that in cp_parser_type_parameter.
+static tree
+cp_parser_default_template_argument (cp_parser *parser, 
+                                     tree identifier,
+                                     bool is_parameter_pack)
+{
+  tree arg;
+  bool is_template;
+
+  /* Parse the id-expression.  */
+  push_deferring_access_checks (dk_no_deferred);
+
+  /* Parse the default argument. */  
+  arg = cp_parser_id_expression (parser,
+                                 /*template_keyword_p=*/false,
+                                 /*check_dependency_p=*/true,
+                                 /*template_p=*/&is_template,
+                                 /*declarator_p=*/false,
+                                 /*optional_p=*/false);
+
+    /* If the id-expression was a template-id that refers to
+       a template-class, we already have the declaration here,
+       so no further lookup is needed.  */
+  if (TREE_CODE (arg) != TYPE_DECL)
+    arg = cp_parser_lookup_name (parser, arg, none_type,
+                                 /*is_template=*/is_template,
+                                 /*is_namespace=*/false,
+                                 /*check_dependency=*/true,
+                                 /*ambiguous_decls=*/NULL,
+                                 EXPR_LOCATION (identifier));
+
+  
+  /* See if the default argument is valid.  */
+  // TODO: This function is where we check for "subtle" constraints
+  // on template template parameters.
+  arg = check_template_template_default_arg (arg);
+
+  /* Template parameter packs cannot have default arguments. */
+  if (is_parameter_pack)
+    {
+      cp_parser_default_parameter_packs (identifier);
+      arg = NULL_TREE;
+    }
+  pop_deferring_access_checks ();
+
+  return arg;
+}
+
+static tree
+cp_parser_default_non_type_argument (cp_parser *parser)
+{
+  tree init;
+  bool saved_greater = parser->greater_than_is_operator_p;
+  bool saved_locals = parser->local_variables_forbidden_p;
+  bool non_constant_p;
+
+  // FIXME: Use RAII for '>' operator/punctuator switching and also for
+  // forbidding local variables.
+  parser->greater_than_is_operator_p = false;
+  parser->local_variables_forbidden_p = true;
+  init = cp_parser_initializer_clause (parser, &non_constant_p);
+  parser->greater_than_is_operator_p = saved_greater;
+  parser->local_variables_forbidden_p = saved_locals;
+  return init;
+}
+
+
+// Lookup an id used as a template constraint. The lookup is performed in
+// the current scope.
+static tree
+cp_parser_lookup_constraint_id (cp_parser *parser, tree id)
+{
+  return cp_parser_lookup_name (parser,
+                                /*name=*/id, 
+                                /*tag_type=*/none_type, 
+                                /*is_template=*/false, 
+                                /*is_namespace=*/false, 
+                                /*check_dependency=*/false, 
+                                /*ambiguous decls*/NULL, 
+                                EXPR_LOCATION (id));
+}
+
+
+// Return the declaration associated with the template id.
+static inline tree
+cp_parser_lookup_constraint_template_id (cp_parser *, tree id)
+{
+  return TREE_OPERAND (id, 0);
+}
+
+
+// ID is the result of parsing an id-expression. If ID is an identifier, then
+// we need to perform a lookup. If ID is a template-id, then the constraint
+// declaration is simply the first argument.
+//
+// Any lookup is performed in the current scope.
+static tree
+cp_parser_lookup_constraint (cp_parser *parser, tree id)
+{
+  switch (TREE_CODE (id))
+    {
+      case ERROR_MARK:
+        return NULL_TREE;
+      case IDENTIFIER_NODE: 
+        return cp_parser_lookup_constraint_id (parser, id);
+      case TEMPLATE_ID_EXPR: 
+        return cp_parser_lookup_constraint_template_id (parser, id);
+      default:
+        debug_tree (id);
+        sorry ("unhandled constraint id");
+        return NULL_TREE;
+      }
+}
+
+
+// Try to parse a parameter declaration as a constrained template parameter.
+// Unlike a non-type template parameter, its "type" is actually a class
+// template (satisfying the requirements of a type trait), a constexpr function 
+// template taking no arguments and returning bool, or an alias template
+// referring to a type trait.
+static tree
+cp_parser_constrained_parameter (cp_parser *parser, 
+                                 bool *is_parameter_pack,
+                                 bool *is_non_type)
+{
+  cp_parser_parse_tentatively (parser);
+
+  // Parse the potential constraint id and save the parser's scope in case
+  // the name was qualified.
+  tree saved_scope = parser->scope;
+  tree cid = cp_parser_constraint_id(parser);
+  tree cdecl = cp_parser_lookup_constraint (parser, cid);
+  parser->scope = saved_scope;
+  if (!cdecl)
+    {
+      cp_parser_abort_tentative_parse (parser);
+      return NULL;
+    }
+
+  // If we're looking at an overload, try to find a single declaration 
+  // that best matches what's been given. If we get past here, we can
+  // commit to parsing a constraint.
+  tree p = deduce_parameter_declaration (cid, cdecl);
+  if (!p)
+    {
+      cp_parser_abort_tentative_parse (parser);
+      return NULL_TREE;
+    }
+  else
+    cp_parser_commit_to_tentative_parse (parser);
+
+  // Unpack the constraint and prototype.
+  tree constraint = TREE_PURPOSE (p);
+  tree proto = TREE_VALUE (p);
+
+  // Are we declaring a non-type argument?
+  if (TREE_CODE (proto) == PARM_DECL)
+    *is_non_type = true;
+
+
+  // Look to see if we're declaring a parameter pack.
+  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS)) 
+    {
+      cp_lexer_consume_token (parser->lexer);
+      *is_parameter_pack = true;
+    }
+
+  // Parse the parameter name (or leave it unnamed) if not present).
+  tree identifier = NULL_TREE;
+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))
+    identifier = cp_parser_identifier (parser);
+  
+  // Build the constraint described by the declaration.
+  // We can't actually build a constraint expression until we've built a proper
+  // template parameter, which happens a little bit later in the parse process.
+  // For now, chain the constraint id and corresponding declaration to the 
+  // parameter specification.
+  tree parm = build_constrained_parameter (identifier, constraint, proto);
+  TREE_CHAIN (parm) = build_tree_list (cid, constraint);
+
+  /* Parse an initializer if one is given. The actual parsing of the 
+     initializer depends on the kind of parameter. */
+  tree init = NULL_TREE;
+  if (cp_lexer_next_token_is (parser->lexer, CPP_EQ)) 
+    { 
+      cp_lexer_consume_token (parser->lexer);
+      switch (TREE_CODE (proto)) 
+        {
+        case TYPE_DECL:
+          init = cp_parser_default_type_argument (parser, identifier, *is_parameter_pack);
+          break;
+        case PARM_DECL:
+          init = cp_parser_default_non_type_argument (parser);
+          break;
+        case TEMPLATE_DECL:
+          init = cp_parser_default_template_argument (parser, identifier, *is_parameter_pack);
+          break;
+        default:
+          gcc_unreachable ();
+        }
+    }
+
+  return build_tree_list (init, parm);
+}
+
+
+//
+//    __is_valid (type-id)
+//
+tree
+cp_parser_valid_type (cp_parser *parser)
+{
+  cp_lexer_consume_token (parser->lexer);
+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
+    return NULL_TREE;
+  tree t = cp_parser_type_id (parser);
+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
+    return NULL_TREE;
+  return finish_valid_type(t);
+}
+
+
+// Returns true if e is a modop_expr whose first argument is an error, and
+// whose second argument is an untyped constructor taking an initializer list.
+// This construct is parsed from an expression of the form:
+//
+//    (T = {e})
+//
+// where T is a type name. Clearly, this is wrong.
+static inline bool 
+validexpr_needs_fixup (tree e)
+{
+  if (TREE_CODE (e) == MODOP_EXPR && TREE_OPERAND (e, 0) == error_mark_node)
+    return true;
+  return false;
+}
+
+// Tentatively parse a valid_expr requirement, returning the required
+// expression if successfull or NULL_TREE otherwise.
+static tree
+cp_parser_maybe_valid_expr (cp_parser *parser)
+{
+  // Tentatively parse the expression a sizeof operand, covering the cases
+  // of expressions and type ids.
+  cp_parser_parse_tentatively (parser);
+  tree e = cp_parser_expression (parser, true, NULL);
+  if (e == error_mark_node || validexpr_needs_fixup (e)) 
+    {
+      cp_parser_abort_tentative_parse (parser);
+      return NULL_TREE;
+    }
+  else
+    {
+      cp_parser_commit_to_tentative_parse (parser);
+      return e;
+    }
+}
+
+// Parse a valid-expr expression which can have any of the following forms:
+//
+//    __is_valid (expression)
+//    __is_valid (type-id = {expression}).
+//    __is_valid (type-id == {expression}).
+//
+tree
+cp_parser_valid_expr (cp_parser *parser)
+{
+  cp_lexer_consume_token (parser->lexer);
+
+  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
+    {
+      cp_parser_error (parser, "expected %(");
+      return error_mark_node;
+    }
+  
+  // If we can parse an expression then just return that. Otherwise, try
+  // to parse a full requirement, with result type included.
+  tree r;
+  if (tree e = cp_parser_maybe_valid_expr (parser))
+    r = finish_valid_expr (e, boolean_true_node);
+  else
+    r = cp_parser_valid_expr_requirement (parser);
+
+  if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))
+    {
+      cp_parser_error (parser, "expected %)");
+      return error_mark_node;
+    }
+
+  return r;
+}
+
+
+// Parse a valid expression that also includes a same-type requirement having
+// the following form:
+//
+//    __is_valid (type-id = {})
+//    __is_valid (type-id == {})
+//
+// TODO: Error handling of this parsing suite must be improved.
+tree 
+cp_parser_valid_expr_requirement (cp_parser *parser)
+{
+  // Parse the leading type-id.
+  tree t = cp_parser_type_id (parser);
+
+  // Determine whether we are parsing a conversion or same-type requirement
+  // on the target expression, and parse that.
+  tree r = NULL_TREE;
+  if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))
+    r = cp_parser_valid_expr_conversion (parser, t);
+  else if (cp_lexer_next_token_is (parser->lexer, CPP_EQ_EQ))
+    r = cp_parser_valid_expr_equivalence (parser, t);
+  else
+    {
+      cp_parser_error (parser, "invalid type requirement specifier");
+      r = error_mark_node;
+    }
+
+  return r;
+}
+
+// Parse a required expression whose result is convertible to T.
+tree
+cp_parser_valid_expr_conversion (cp_parser *parser, tree t)
+{
+  tree e = cp_parser_valid_expr_syntax (parser);
+  if (e != error_mark_node)
+    return finish_valid_expr (e, build_is_convertible (e, t));
+  else
+    return e;
+}
+
+// Parse a required expression whose result is the same as T.
+tree
+cp_parser_valid_expr_equivalence (cp_parser *parser, tree t)
+{
+  tree e = cp_parser_valid_expr_syntax (parser);
+  if (e != error_mark_node)
+    return finish_valid_expr (e, build_is_same (e, t));
+  else
+    return e;
+}
+
+// Parse an assignment expression enclosed in braces.
+tree
+cp_parser_valid_expr_syntax (cp_parser *parser)
+{
+  cp_lexer_consume_token (parser->lexer);
+  if (!cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE))
+    {
+      cp_parser_error (parser, "expected %{");
+      return error_mark_node;
+    }
+
+  tree e = cp_parser_assignment_expression (parser, false, NULL);
+
+  if (!cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE))
+    {
+      cp_parser_error (parser, "expected %}");
+      return error_mark_node;
+    }
+  return e;
+}
+
+
+
+// Parse a concept definition, returning the parsed definition.
+//
+//   concept-definition:
+//     concept-head { concept-body }
+//
+//   concept-head:
+//     concept identifier template-parameter-list[opt]
+
+static tree
+cp_parser_concept_definition (cp_parser *parser)
+{
+  /*
+  cp_parser_require_keyword (parser, RID_CONCEPT, RT_CONCEPT);
+
+  // Parse the concept-id.
+  tree identifier = cp_parser_identifier (parser);
+  if (identifier == error_mark_node)
+    return NULL_TREE;
+
+  // Parse the optional template parameter list.
+  tree parameter_list = NULL_TREE;
+  if (cp_lexer_next_token_is (parser->lexer, CPP_LESS))
+    {
+      cp_lexer_consume_token (parser->lexer);
+      parameter_list = cp_parser_template_parameter_list (parser);
+      if (!cp_parser_require (parser, CPP_GREATER, RT_GREATER))
+        return NULL_TREE;
+    }
+
+  // ... and build the associated constraints (if any).
+  if (parameter_list)
+    {
+      current_constraints = build_constraints (parameter_list);
+    }
+
+  // Create the declared concept and its associated type.
+  tree decl = build_concept (identifier, parameter_list, current_constraints);
+
+  // "Parse" the body of the concept.
+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_BRACE))
+    {
+      cp_parser_error (parser, "expected %<{%>");
+      return NULL_TREE;
+    }
+  cp_lexer_consume_token (parser->lexer);
+  cp_parser_skip_to_closing_brace(parser);
+  cp_lexer_consume_token (parser->lexer);
+
+
+  if (parameter_list)
+    finish_template_decl (parameter_list);
+  */
+  return NULL_TREE;
+}
+
+
+
 /* Support Functions */
 
 /* Looks up NAME in the current scope, as given by PARSER->SCOPE.
@@ -21175,6 +22014,24 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)
 
   /* Look for the `>'.  */
   cp_parser_skip_to_end_of_template_parameter_list (parser);
+
+
+  // Translate shorthand constraints into a requirement and conjoin that with
+  // current requirements.
+  tree saved_constraints = current_constraints;
+  if (cxx_dialect >= cxx1y)
+    {
+      // Get shorthand constraints.
+      tree parm_reqs = build_shorthand_constraints (parameter_list);
+
+      // Parse the requires clause after the template parameters.
+      tree tmpl_reqs = NULL_TREE;
+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_REQUIRES))
+        tmpl_reqs = cp_parser_template_requirements (parser);
+      tmpl_reqs = conjoin_requirements (parm_reqs, tmpl_reqs);
+      current_constraints = finish_template_constraints (tmpl_reqs);
+    }
+
   /* We just processed one more parameter list.  */
   ++parser->num_template_parameter_lists;
   /* If the next token is `template', there are more template
@@ -21220,6 +22077,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)
 
   /* Finish up.  */
   finish_template_decl (parameter_list);
+  current_constraints = saved_constraints;
 
   /* Check the template arguments for a literal operator template.  */
   if (decl
@@ -21352,6 +22210,16 @@ cp_parser_single_declaration (cp_parser* parser,
 	  else
 	    decl = error_mark_node;
 
+          // Attach constraints to the type decl (if it's not an error) at this
+          // point. It would be nice if there was a more central or obvious
+          // place to do this (as with grokfndecl).
+          //
+          // To make matters worse, we initialize partial specializations in
+          // a different place, too (hence the "&& current_constraints"). We
+          // don't want to erase a decl's existing constraints.
+          if (decl != error_mark_node && current_constraints)
+            DECL_CONSTRAINT (decl) = take_constraints ();
+
 	  /* Perform access checks for template parameters.  */
 	  cp_parser_perform_template_parameter_access_checks (checks);
 	}
@@ -21386,6 +22254,7 @@ cp_parser_single_declaration (cp_parser* parser,
 				        &function_definition_p,
 					NULL);
 
+
     /* 7.1.1-1 [dcl.stc]
 
        A storage-class-specifier shall not be specified in an explicit
@@ -22145,7 +23014,9 @@ cp_parser_set_decl_spec_type (cp_decl_specifier_seq *decl_specs,
 	}
     }
   else if (decl_specs->type)
-    decl_specs->multiple_types_p = true;
+    {
+      decl_specs->multiple_types_p = true;
+    }
   else
     {
       decl_specs->type = type_spec;
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 7924dff..1a08693 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -128,7 +128,7 @@ static int unify (tree, tree, tree, tree, int, bool);
 static void add_pending_template (tree);
 static tree reopen_tinst_level (struct tinst_level *);
 static tree tsubst_initializer_list (tree, tree);
-static tree get_class_bindings (tree, tree, tree, tree);
+static tree get_class_bindings (tree, tree, tree, tree, tree);
 static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t,
 				   bool, bool);
 static void tsubst_enum	(tree, tree, tree);
@@ -206,6 +206,10 @@ static bool arg_from_parm_pack_p (tree, tree);
 static tree current_template_args (void);
 static tree tsubst_template_parm (tree, tree, tsubst_flags_t);
 
+static bool instantiating_class ();
+static tree tsubst_constraints (tree, tree, tsubst_flags_t, tree);
+
+
 /* Make the current scope suitable for access checking when we are
    processing T.  T can be FUNCTION_DECL for instantiated function
    template, or VAR_DECL for static member variable (need by
@@ -819,6 +823,7 @@ maybe_process_partial_specialization (tree type)
 	  && DECL_LANG_SPECIFIC (TYPE_NAME (type))
 	  && DECL_USE_TEMPLATE (TYPE_NAME (type))))
     {
+
       /* This is for ordinary explicit specialization and partial
 	 specialization of a template class such as:
 
@@ -1003,8 +1008,6 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)
   if (args == error_mark_node)
     return NULL_TREE;
 
-  gcc_assert (TREE_CODE (tmpl) == TEMPLATE_DECL);
-
   /* There should be as many levels of arguments as there are
      levels of parameters.  */
   gcc_assert (TMPL_ARGS_DEPTH (args)
@@ -3590,12 +3593,20 @@ process_template_parm (tree list, location_t parm_loc, tree parm,
 {
   tree decl = 0;
   tree defval;
+  tree constraint = NULL_TREE;
   tree err_parm_list;
   int idx = 0;
 
   gcc_assert (TREE_CODE (parm) == TREE_LIST);
   defval = TREE_PURPOSE (parm);
 
+  /* Grab the constraint from the parameter so we can build a
+     real constraint expression later. Note that the constraint 
+     is currently anonymously hung on the parameter declaration 
+     (the value of parm). */
+  constraint = TREE_CHAIN (TREE_VALUE (parm));
+  
+  /* Compute the index of the template parameter being created. */
   if (list)
     {
       tree p = tree_last (list);
@@ -3624,7 +3635,7 @@ process_template_parm (tree list, location_t parm_loc, tree parm,
         {
           err_parm_list = build_tree_list (defval, parm);
           TREE_VALUE (err_parm_list) = error_mark_node;
-	   return chainon (list, err_parm_list);
+	  return chainon (list, err_parm_list);
         }
       else
       {
@@ -3651,6 +3662,9 @@ process_template_parm (tree list, location_t parm_loc, tree parm,
 	  }
       }
 
+      /* Attach the constraint to the param decl. */
+      DECL_CONSTRAINT (parm) = constraint;
+
       /* A template parameter is not modifiable.  */
       TREE_CONSTANT (parm) = 1;
       TREE_READONLY (parm) = 1;
@@ -3688,6 +3702,9 @@ process_template_parm (tree list, location_t parm_loc, tree parm,
 			     TYPE_DECL, parm, t);
 	}
 
+      /* Attach the constraint to the type decl. */
+      DECL_CONSTRAINT (decl) = constraint;
+
       TYPE_NAME (t) = decl;
       TYPE_STUB_DECL (t) = decl;
       parm = decl;
@@ -3698,9 +3715,11 @@ process_template_parm (tree list, location_t parm_loc, tree parm,
       TEMPLATE_TYPE_PARAMETER_PACK (t) = is_parameter_pack;
       TYPE_CANONICAL (t) = canonical_type_parameter (t);
     }
+
   DECL_ARTIFICIAL (decl) = 1;
   SET_DECL_TEMPLATE_PARM_P (decl);
   pushdecl (decl);
+
   parm = build_tree_list (defval, parm);
   return chainon (list, parm);
 }
@@ -4027,11 +4046,43 @@ mark_template_parm (tree t, void* data)
   return 0;
 }
 
+
+// Check that the partial class template specialization SPEC is actually
+// a specialization or refinement of the primary template TMPL.
+static void
+check_partial_specialization (tree spec, tree tmpl)
+{
+  tree type = TREE_TYPE (spec);
+  tree inner_args = 
+    INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));
+  tree implicit_args = 
+    INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE (tmpl)));
+
+  /* [temp.class.spec]
+
+     The argument list of the specialization shall not be identical to
+     the implicit argument list of the primary template.  */
+  if (comp_template_args (inner_args, implicit_args)) 
+    {
+      // If the arguments are the same, the constraints
+      // must be distinct.
+      //
+      // Note that we haven't assigned the current constraints to the
+      // template declration yet.
+      if (same_constraints_p (current_constraints, get_constraints (tmpl)))
+        error ("partial specialization %qT does not specialize any "
+               "template arguments", type);
+    }
+}
+
+
 /* Process the partial specialization DECL.  */
 
 static tree
 process_partial_specialization (tree decl)
 {
+  gcc_assert (current_template_parms);
+
   tree type = TREE_TYPE (decl);
   tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);
   tree specargs = CLASSTYPE_TI_ARGS (type);
@@ -4046,11 +4097,10 @@ process_partial_specialization (tree decl)
   struct template_parm_data tpd;
   struct template_parm_data tpd2;
 
-  gcc_assert (current_template_parms);
-
   inner_parms = INNERMOST_TEMPLATE_PARMS (current_template_parms);
   ntparms = TREE_VEC_LENGTH (inner_parms);
 
+
   /* We check that each of the template parameters given in the
      partial specialization is used in the argument list to the
      specialization.  For example:
@@ -4113,15 +4163,10 @@ process_partial_specialization (tree decl)
   if (did_error_intro)
     return error_mark_node;
 
-  /* [temp.class.spec]
-
-     The argument list of the specialization shall not be identical to
-     the implicit argument list of the primary template.  */
-  if (comp_template_args
-      (inner_args,
-       INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE
-						   (maintmpl)))))
-    error ("partial specialization %qT does not specialize any template arguments", type);
+  // Check that decl actually specializes or refines maintmpl. This should
+  // probably incorporate the check below but it returns and the errors above 
+  // do not (could they?, should they?).
+  check_partial_specialization (decl, maintmpl);
 
   /* A partial specialization that replaces multiple parameters of the
      primary template with a pack expansion is less specialized for those
@@ -4129,8 +4174,8 @@ process_partial_specialization (tree decl)
   if (nargs < DECL_NTPARMS (maintmpl))
     {
       error ("partial specialization is not more specialized than the "
-	     "primary template because it replaces multiple parameters "
-	     "with a pack expansion");
+             "primary template because it replaces multiple parameters "
+             "with a pack expansion");
       inform (DECL_SOURCE_LOCATION (maintmpl), "primary template here");
       return decl;
     }
@@ -4704,7 +4749,8 @@ push_template_decl_real (tree decl, bool is_friend)
 	     class-type, we must be redeclaring it here.  Make sure
 	     that the redeclaration is valid.  */
 	  redeclare_class_template (TREE_TYPE (decl),
-				    current_template_parms);
+				    current_template_parms,
+            current_constraints);
 	  /* We don't need to create a new TEMPLATE_DECL; just use the
 	     one we already had.  */
 	  tmpl = TYPE_TI_TEMPLATE (TREE_TYPE (decl));
@@ -4877,6 +4923,7 @@ template arguments to %qD do not match original template %qD",
 	}
     }
 
+
   /* The DECL_TI_ARGS of DECL contains full set of arguments referring
      back to its most general template.  If TMPL is a specialization,
      ARGS may only have the innermost set of arguments.  Add the missing
@@ -4906,16 +4953,25 @@ push_template_decl (tree decl)
 }
 
 /* Called when a class template TYPE is redeclared with the indicated
-   template PARMS, e.g.:
+   template PARMS and CONStraints, e.g.:
 
      template <class T> struct S;
-     template <class T> struct S {};  */
+     template <class T> struct S {};  
+
+
+   Or, in the case where S is constrained:
+
+     template <C T> struct S;
+     template <C T> struct S { }
+
+   If the constraints differ, an error is emitted. */
 
 bool
-redeclare_class_template (tree type, tree parms)
+redeclare_class_template (tree type, tree parms, tree cons)
 {
   tree tmpl;
   tree tmpl_parms;
+  tree tmpl_cons;
   int i;
 
   if (!TYPE_TEMPLATE_INFO (type))
@@ -5012,7 +5068,17 @@ redeclare_class_template (tree type, tree parms)
 	TREE_PURPOSE (TREE_VEC_ELT (parms, i)) = tmpl_default;
     }
 
-    return true;
+  // Cannot redeclare a class template with a different set of constraints. 
+  tmpl_cons = DECL_CONSTRAINT (DECL_TEMPLATE_RESULT (tmpl));
+  if (!same_constraints_p (tmpl_cons, cons))
+    {
+      /* FIXME: This points to the wrong line. How do we make
+         it point the mis-declared thing. */
+      error_at (input_location, "redeclaration %q+D with different constraints", tmpl);
+      inform (input_location, "original declaration appeared here");
+    }
+
+  return true;
 }
 
 /* Simplify EXPR if it is a non-dependent expression.  Returns the
@@ -6125,6 +6191,64 @@ canonicalize_type_argument (tree arg, tsubst_flags_t complain)
   return arg;
 }
 
+
+// A template declaration can be substituted for a constrained
+// template template parameter only when the argument is more 
+// constrained than the parameter.
+static bool
+compatible_template_constraints (int i,
+                                 tree parm, 
+                                 tree arg,
+                                 tree in_decl,
+                                 tsubst_flags_t complain)
+{
+  // FIXME: The argument may not have a decl result. This seems to
+  // happen in some classes with nested template template
+  // parameters (e.g., a rebind struct in a class taking a template
+  // template parameter. If this is the case, just return true and
+  // allow things to happen as they always did.
+  if (TREE_CODE (arg) == TEMPLATE_DECL)
+    {
+      if (!DECL_TEMPLATE_RESULT (arg))
+        return true;
+    }
+
+  // NOTE: Increment this flag to indicate that we need to relax
+  // same_typpe_p comparison w.r.t., template type parameters.
+  //
+  // FIXME: This is hackery. What really needs to happen is that the levels
+  // of the template parameters need to be lowered, or that those of the
+  // template arguments need to be raised. Probably easier to do the latter.
+  ++checking_template_compatability;
+  bool refined = more_constrained_p (arg, parm);
+  --checking_template_compatability;
+
+  // Ok. Substitute.
+  if (refined)
+    return true;
+
+  // If not, report an error.
+  if (in_decl && (complain & tf_error))
+  {
+    error ("constraint mismatch at argument %d in "
+           "template parameter list for %qD",
+           i + 1, in_decl);
+  }
+  return false;
+}
+
+// Convert the placeholder into the given parameter by creating a new 
+// placeholder that is bound to the matching declaration.
+static tree
+convert_placeholder_argument (tree parm, tree)
+{
+  tree t = make_node (PLACEHOLDER_EXPR);
+  TREE_CHAIN (t) = parm;
+  return t;
+}
+
+
+
 /* Convert the indicated template ARG as necessary to match the
    indicated template PARM.  Returns the converted ARG, or
    error_mark_node if the conversion was unsuccessful.  Error and
@@ -6144,6 +6268,10 @@ convert_template_argument (tree parm,
   tree val;
   int is_type, requires_type, is_tmpl_type, requires_tmpl_type;
 
+  // A placeholder argument matches any template parameter.
+  if (TREE_CODE (arg) == PLACEHOLDER_EXPR)
+    return convert_placeholder_argument (parm, arg);
+
   if (TREE_CODE (arg) == TREE_LIST
       && TREE_CODE (TREE_VALUE (arg)) == OFFSET_REF)
     {
@@ -6197,7 +6325,10 @@ convert_template_argument (tree parm,
 	  || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE))
     arg = TYPE_STUB_DECL (arg);
 
-  is_type = TYPE_P (arg) || is_tmpl_type;
+  // Placeholders can act as types.
+  is_type = TYPE_P (arg) 
+         || is_tmpl_type 
+         || (TREE_CODE (arg) == PLACEHOLDER_EXPR);
 
   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF
       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)
@@ -6302,6 +6433,15 @@ convert_template_argument (tree parm,
 
 		  val = error_mark_node;
 		}
+
+              // Check that the constraints are compatible before allowing the
+              // substitution.
+              if (val != error_mark_node)
+                {
+                  if (!compatible_template_constraints (i, parm, arg, in_decl, 
+                                                        complain))
+                    val = error_mark_node;
+                }
 	    }
 	}
       else
@@ -6392,6 +6532,15 @@ coerce_template_parameter_pack (tree parms,
   if (arg_idx > nargs)
     arg_idx = nargs;
 
+  // A placeholder matches a parameter pack and becomes a kind of 
+  // argument pack.
+  if (arg_idx < nargs)
+    {
+      tree arg = TREE_VEC_ELT (inner_args, arg_idx);
+      if (TREE_CODE (arg) == PLACEHOLDER_EXPR)
+        return convert_placeholder_argument (TREE_VALUE (parm), arg);
+    }
+
   packed_args = make_tree_vec (nargs - arg_idx);
 
   if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL
@@ -6668,6 +6817,7 @@ coerce_template_parms (tree parms,
       else
 	break;
 
+      // Handle the deduced argument(s)
       if (arg == error_mark_node)
 	{
 	  if (complain & tf_error)
@@ -6704,6 +6854,7 @@ coerce_template_parms (tree parms,
   return new_inner_args;
 }
 
+
 /* Returns 1 if template args OT and NT are equivalent.  */
 
 static int
@@ -6759,7 +6910,9 @@ template_args_equal (tree ot, tree nt)
   else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))
     return 0;
   else
-    return cp_tree_equal (ot, nt);
+    {
+      return cp_tree_equal (ot, nt);
+    }
 }
 
 /* Returns 1 iff the OLDARGS and NEWARGS are in fact identical sets of
@@ -6926,6 +7079,232 @@ maybe_get_template_decl_from_type_decl (tree decl)
     ? CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl)) : decl;
 }
 
+
+
+// Return a sequence of hash arguments that incorproates template constraints.
+static tree
+constrain_hash_args (tree args)
+{
+  // Copy out the template arguments.
+  int n = TREE_VEC_LENGTH (args);
+  tree r = make_tree_vec (n + 1);
+  for (int i = 0; i < n; ++i)
+    TREE_VEC_ELT (r, i) = TREE_VEC_ELT (args, i);
+
+  // Append the constraining expression. We don't need the entire constraint
+  // info object.
+  tree c = TREE_VEC_ELT (current_constraints, 4);
+  TREE_VEC_ELT (r, n) = c;
+  return r;
+}
+
+// Returns a vector of arguments, possibly adjusted to include the current
+// constraints.
+static inline tree
+adjust_hash_args (tree args)
+{
+  if (current_constraints)
+    return constrain_hash_args (args);
+  else
+    return args;
+}
+
+// Return the specialization entry associated with the entry and its hash.
+static inline spec_entry *
+find_specialization (spec_entry &elt, hashval_t hash)
+{
+  return (spec_entry *) htab_find_with_hash (type_specializations, &elt, hash);
+}
+
+// Insert a specialization entry into the spec table.
+static spec_entry *
+insert_specialization (spec_entry &elt, hashval_t hash)
+{
+  void** slot = htab_find_slot_with_hash (type_specializations, &elt, hash, INSERT);
+  spec_entry *entry = ggc_alloc_spec_entry ();
+  *entry = elt;
+  *slot = entry;
+  return entry;
+}
+
+namespace
+{
+// The matching specialization facility is used to construct a list of 
+// specializations that can produce a given type. Optionally, constraint
+// information can be given, limiting the the selection of specializations
+// to only those whose constraints are subsumed by those given.
+//
+// Calling this as a function yields a tree list of viable specializations.
+// Effectively each list node is a tuple (purpose, value, and type) where
+// the purpose contains the specialization arguments, the value contains
+// the specialization type, and the type field contains the specialization's
+// template parameters.
+//
+// TODO: This should replace the implementation of part of
+// most_specialized_class.
+class matching_specialization
+{
+public:
+  matching_specialization (tree, tree, tree);
+
+  tree operator()();
+
+private:
+  void adjust_multilevel_args          (tree&, tree&);
+  tree get_partial_specialization_args (tree, tree);
+
+  tree tmpl_;
+  tree type_args_;
+  tree outer_args_;
+  tree constraints_;
+};
+
+inline
+matching_specialization::
+matching_specialization (tree tmpl, tree type, tree cons)
+  : tmpl_ (tmpl)
+  , type_args_ (CLASSTYPE_TI_ARGS (type))
+  , outer_args_ (NULL_TREE)
+  , constraints_ (cons)
+{
+  // Get the template arguments used to construct the type, and outer arguments
+  // if they're nested.
+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (type_args_))
+    {
+      outer_args_ = strip_innermost_template_args (type_args_, 1);
+      type_args_ = INNERMOST_TEMPLATE_ARGS (type_args_);
+    }
+}
+
+tree
+matching_specialization::operator() ()
+{
+  tree list = NULL_TREE;
+  for (tree t = DECL_TEMPLATE_SPECIALIZATIONS (tmpl_); t; t = TREE_CHAIN (t))
+    {
+      tree spec = TREE_TYPE (t);
+      tree parms = TREE_VALUE (t);
+
+      // Get the partial specialization arguments. If there's an error, skip
+      // the speciliazation.
+      //
+      // NOTE: The most_specialized_template class returns an error here.
+      // I'm not sure I want to do that.
+      tree partial_args = get_partial_specialization_args (spec, parms);
+      if (partial_args == error_mark_node)
+        continue;
+
+      // Determine if this specialization can form the type by substituting
+      // it's specialization args into the template. If so, returns the
+      // arguments for each template parameter or NULL_TREE if not.
+      tree spec_args = 
+        get_class_bindings (tmpl_, spec, parms, partial_args, type_args_);
+      if (!spec_args)
+        continue;
+
+      // If a constraints filter is given, only accept specializations that
+      // are subsumed by the current constraints.
+      if (constraints_)
+        {
+          tree cons = DECL_CONSTRAINT (TYPE_MAIN_DECL (spec));
+          if (!subsumes_constraints_p (constraints_, cons))
+            continue;
+        }
+
+      // Re-add the outer args.
+      if (outer_args_)
+        spec_args = add_to_template_args (outer_args_, spec_args);
+
+      // And save the specialization to the end of the list.
+      list = tree_cons (spec_args, parms, list);
+      TREE_TYPE (list) = spec;
+    }
+  return list;
+}
+
+void
+matching_specialization::
+adjust_multilevel_args(tree& args, tree& parms)
+{
+  // Discard the outer levels of args, and then substitute in the
+  // template args from the enclosing class.
+  args = INNERMOST_TEMPLATE_ARGS (args);
+  args = tsubst_template_args (args, outer_args_, tf_none, NULL_TREE);
+
+  // PARMS already refers to just the innermost parms, but the template
+  // parms in partial_spec_args had their levels lowered by tsubst, so
+  // we need to do the same for the parm list.  We can't just tsubst the
+  // TREE_VEC itself, as tsubst wants to treat a TREE_VEC as an argument
+  // vector.
+  parms = copy_node (parms);
+  for (int i = TREE_VEC_LENGTH (parms) - 1; i >= 0; --i)
+    {
+      tree& parm = TREE_VEC_ELT (parms, i);
+      parm = tsubst (parm, outer_args_, tf_none, NULL_TREE);
+    }
+}
+
+tree
+matching_specialization::
+get_partial_specialization_args (tree spec, tree parms)
+{
+  tree partial = CLASSTYPE_TI_ARGS (spec);
+  ++processing_template_decl;
+  if (outer_args_)
+    adjust_multilevel_args (partial, parms);
+
+  partial = coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (tmpl_),
+                                   add_to_template_args (outer_args_, partial),
+                                   tmpl_, 
+                                   tf_none,
+                                   /*require_all_args=*/true,
+                                  /*use_default_args=*/true);
+  --processing_template_decl;
+  return partial;
+}
+
+} // namespace
+
+
+// Check that we found exactly one specialization, and return it.
+static tree
+check_template_type (tree spec, tree type)
+{
+  // If multiple specializations match, then we can't figure out
+  // which was meant. Enumerate all of them.
+  if (TREE_CHAIN (spec))
+    {
+      error ("ambiguous reference to constrained specialization %qT", type);
+      for (tree t = spec; t ; t = TREE_CHAIN (t))
+        {
+          tree d = TYPE_MAIN_DECL (TREE_TYPE (t));
+          inform (DECL_SOURCE_LOCATION (d), "candidate declaration is %q#D", d);
+        }
+      return NULL_TREE;
+    }
+  else
+    return TREE_TYPE (spec);
+}
+
+
+// If entering the scope of a constrained template type, try to find the
+// specialization that best matches the constraints. This is the one 
+static tree
+enter_template_type (tree type, tree tmpl, tree)
+{
+  if (!current_constraints)
+    return type;
+
+  // Find the set of specializations that will produce the given type,
+  // and also be within the specified constraints.
+  matching_specialization match (tmpl, type, current_constraints);
+  if (tree spec = match ())
+    type = check_template_type (spec, type);
+
+  return type;
+}
+
+
 /* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of
    parameters, find the desired type.
 
@@ -6955,7 +7334,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,
 			 int entering_scope, tsubst_flags_t complain)
 {
   tree templ = NULL_TREE, parmlist;
-  tree t;
+  tree t = NULL_TREE;
   void **slot;
   spec_entry *entry;
   spec_entry elt;
@@ -7193,31 +7572,32 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,
 	/* We were unable to bind the arguments.  */
 	return error_mark_node;
 
-      /* In the scope of a template class, explicit references to the
-	 template class refer to the type of the template, not any
-	 instantiation of it.  For example, in:
+      /*In the scope of a template class, explicit references to the
+        template class refer to the type of the template, not any
+        instantiation of it.  For example, in:
 
-	   template <class T> class C { void f(C<T>); }
+        template <class T> class C { void f(C<T>); }
 
-	 the `C<T>' is just the same as `C'.  Outside of the
-	 class, however, such a reference is an instantiation.  */
+        the `C<T>' is just the same as `C'.  Outside of the
+        class, however, such a reference is an instantiation. */
       if ((entering_scope
-	   || !PRIMARY_TEMPLATE_P (gen_tmpl)
-	   || currently_open_class (template_type))
-	  /* comp_template_args is expensive, check it last.  */
-	  && comp_template_args (TYPE_TI_ARGS (template_type),
-				 arglist))
-	return template_type;
-
-      /* If we already have this specialization, return it.  */
+	         || !PRIMARY_TEMPLATE_P (gen_tmpl)
+	         || currently_open_class (template_type))
+	         /* comp_template_args is expensive, check it last.  */
+	        && comp_template_args (TYPE_TI_ARGS (template_type), arglist))
+        {
+          // We actually have to search for an appropriate type. It's not
+          // sufficient to assume that we've found it.
+          return enter_template_type (template_type, gen_tmpl, arglist);
+        }
+
+      // Build the hash query and try to find an existing specialization.
       elt.tmpl = gen_tmpl;
-      elt.args = arglist;
+      elt.args = adjust_hash_args (arglist);
       hash = hash_specialization (&elt);
-      entry = (spec_entry *) htab_find_with_hash (type_specializations,
-						  &elt, hash);
-
+      entry = find_specialization (elt, hash);
       if (entry)
-	return entry->spec;
+        return entry->spec;
 
       is_dependent_type = uses_template_parms (arglist);
 
@@ -7274,6 +7654,15 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,
 	}
       else if (DECL_ALIAS_TEMPLATE_P (gen_tmpl))
 	{
+          // If the alias template is constrained, then we must  the the
+          // arguments satisfy the template's constraints.
+          //
+          // FIXME: Improve diagnostics. This should be resolved by
+          // checking wherever complete types are required.
+          if (!is_dependent_type)
+            if (!evaluate_decl_constraints (gen_tmpl, arglist))
+              return error_mark_node;
+
 	  /* The user referred to a specialization of an alias
 	    template represented by GEN_TMPL.
 
@@ -7285,7 +7674,7 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,
 		template-arguments for the template-parameters in the
 		type-id of the alias template.  */
 
-	  t = tsubst (TREE_TYPE (gen_tmpl), arglist, complain, in_decl);
+          t = tsubst (TREE_TYPE (gen_tmpl), arglist, complain, in_decl);
 	  /* Note that the call above (by indirectly calling
 	     register_specialization in tsubst_decl) registers the
 	     TYPE_DECL representing the specialization of the alias
@@ -7318,6 +7707,16 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,
 	       equality testing, so this template class requires
 	       structural equality testing. */
 	    SET_TYPE_STRUCTURAL_EQUALITY (t);
+
+          // As an afterthought, if there are constraints, require structural
+          // equality testing.
+          //
+          // FIXME: This MUST be addressed in a more reasonable way. If we
+          // require structural tests whenever constraints are enabled, then
+          // compilation times could be reduced. What we could do is link
+          // the constrained version to its primary declaration.
+          if (current_constraints)
+            SET_TYPE_STRUCTURAL_EQUALITY (t);
 	}
       else
 	gcc_unreachable ();
@@ -7439,12 +7838,19 @@ lookup_template_class_1 (tree d1, tree arglist, tree in_decl, tree context,
 
       SET_TYPE_TEMPLATE_INFO (t, build_template_info (found, arglist));
 
+      // Register this specialization of the given template.
       elt.spec = t;
-      slot = htab_find_slot_with_hash (type_specializations,
-				       &elt, hash, INSERT);
-      entry = ggc_alloc_spec_entry ();
-      *entry = elt;
-      *slot = entry;
+      entry = insert_specialization (elt, hash);
+
+      // elt.spec = t;
+      // elt.tmpl = gen_tmpl;
+      // elt.args = arglist;
+      // hash = hash_specialization (&elt);
+      // slot = htab_find_slot_with_hash (type_specializations,
+				  //      &elt, hash, INSERT);
+      // entry = ggc_alloc_spec_entry ();
+      // *entry = elt;
+      // *slot = entry;
 
       /* Note this use of the partial instantiation so we can check it
 	 later in maybe_process_partial_specialization.  */
@@ -8277,7 +8683,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)
 
           saved_input_location = input_location;
           input_location = DECL_SOURCE_LOCATION (friend_tmpl);
-	  redeclare_class_template (TREE_TYPE (tmpl), parms);
+	  redeclare_class_template (TREE_TYPE (tmpl), parms, NULL_TREE);
           input_location = saved_input_location;
           
 	}
@@ -8477,6 +8883,16 @@ instantiate_class_template_1 (tree type)
   templ = most_general_template (CLASSTYPE_TI_TEMPLATE (type));
   gcc_assert (TREE_CODE (templ) == TEMPLATE_DECL);
 
+
+  // NOTE: The most_specialized_class function returns the partial
+  // specialization that can instantiate type. For example, if type is int*, and
+  // there is a partial specialization for T*, then that  specialization is
+  // returned. This is similar to doing overload resolution with constrained
+  // functions.
+  //
+  // Note that we must check constraints during that computation. Otherwise,
+  // we wouldn't be able to find the most specialized template.
+
   /* Determine what specialization of the original template to
      instantiate.  */
   t = most_specialized_class (type, templ, tf_warning_or_error);
@@ -8506,6 +8922,15 @@ instantiate_class_template_1 (tree type)
       args = CLASSTYPE_TI_ARGS (type);
     }
 
+  // Check the constraints of a primary class template. Note that constraints
+  // for specialized templates are checked when finding the most specialized
+  // class so checking again here, would be redundant.
+  if (!t)
+    {
+      if (!evaluate_decl_constraints (templ, args))
+        return error_mark_node;
+    }
+
   /* If the template we're instantiating is incomplete, then clearly
      there's nothing we can do.  */
   if (!COMPLETE_TYPE_P (pattern))
@@ -8515,6 +8940,7 @@ instantiate_class_template_1 (tree type)
   if (! push_tinst_level (type))
     return type;
 
+
   /* Now we're really doing the instantiation.  Mark the type as in
      the process of being defined.  */
   TYPE_BEING_DEFINED (type) = 1;
@@ -9145,7 +9571,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
       orig_arg = arg_pack;
       if (arg_pack && TREE_CODE (arg_pack) == ARGUMENT_PACK_SELECT)
 	arg_pack = ARGUMENT_PACK_SELECT_FROM_PACK (arg_pack);
-      
+
       if (arg_pack && !ARGUMENT_PACK_P (arg_pack))
 	/* This can only happen if we forget to expand an argument
 	   pack somewhere else. Just return an error, silently.  */
@@ -9362,6 +9788,30 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
   return result;
 }
 
+// Substitute args into the pack expansion t, producing a conjunction of
+// requirements.
+tree
+tsubst_pack_conjunction (tree t, tree args, tsubst_flags_t complain,
+                         tree in_decl)
+{
+  tree r = tsubst_pack_expansion (t, args, complain, in_decl);
+  if (r == error_mark_node)
+    return r;
+
+  // If the expansion is empty, then the result is implicitly true.
+  int n = TREE_VEC_LENGTH (r);
+  if (r == 0)
+    return boolean_true_node;
+
+  tree lhs = TREE_VEC_ELT (r, 0);
+  for (int i = 1; i < n; ++i)
+    {
+      tree rhs = TREE_VEC_ELT (r, i);
+      lhs = conjoin_requirements (lhs, rhs);
+    }
+  return lhs;
+}
+
 /* Given PARM_DECL PARM, find the corresponding PARM_DECL in the template
    TMPL.  We do this using DECL_PARM_INDEX, which should work even with
    parameter packs; all parms generated from a function parameter pack will
@@ -10032,6 +10482,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	    member = 0;
 	    ctx = DECL_CONTEXT (t);
 	  }
+
+        /* Instantiate the result type. */
 	type = tsubst (TREE_TYPE (t), args, complain, in_decl);
 	if (type == error_mark_node)
 	  RETURN (error_mark_node);
@@ -10110,13 +10562,29 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	       instantiated.  We handle the member function case in
 	       instantiate_class_template since the default arguments
 	       might refer to other members of the class.  */
-	    if (!member
-		&& !PRIMARY_TEMPLATE_P (gen_tmpl)
-		&& !uses_template_parms (argvec))
+	    if (!member && !PRIMARY_TEMPLATE_P (gen_tmpl) && !uses_template_parms (argvec))
 	      tsubst_default_arguments (r);
+
+
+            // If this is a member function and we are instantiating a class, we
+            // need to instantiate (or possibly evaluate) the nested
+            // declaration. Cache the results for subsequent instantiation or
+            // overload resolution.
+            //
+            // If this is not a member or we are not instantiating a class, then
+            // then the constraints on this function will have been checked during
+            // function type unification, and we don't need to do it again.
+            tree cons = NULL_TREE;
+            if (member && instantiating_class ()) 
+              cons = tsubst_constraints (t, DECL_TI_ARGS (r), complain, in_decl);
+            DECL_CONSTRAINT (r) = cons;
 	  }
 	else
-	  DECL_TEMPLATE_INFO (r) = NULL_TREE;
+          {
+	    DECL_TEMPLATE_INFO (r) = NULL_TREE;
+          }
+
+
 
 	/* Copy the list of befriending classes.  */
 	for (friends = &DECL_BEFRIENDING_CLASSES (r);
@@ -10165,6 +10633,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 
 	apply_late_template_attributes (&r, DECL_ATTRIBUTES (r), 0,
 					args, complain, in_decl);
+      
       }
       break;
 
@@ -10360,7 +10829,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	tree spec;
 	tree tmpl = NULL_TREE;
 	tree ctx;
-	tree type = NULL_TREE;
+        tree type = NULL_TREE;
+        tree cons = NULL_TREE;
 	bool local_p;
 
 	if (TREE_CODE (t) == TYPE_DECL
@@ -10575,6 +11045,9 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)
 	else
 	  register_local_specialization (r, t);
 
+        // Associate the instantiated constraint with the new declaration.
+        DECL_CONSTRAINT(r) = cons;
+
 	DECL_CHAIN (r) = NULL_TREE;
 
 	apply_late_template_attributes (&r, DECL_ATTRIBUTES (r),
@@ -12082,6 +12555,30 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	(code, tsubst (TREE_TYPE (t), args, complain, in_decl),
 	 tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));
 
+    // Instantiate and evaluate the validexpr operands, returning either a true
+    // or false literal.
+    case VALID_EXPR:
+      {
+        ++cp_unevaluated_operand;
+        ++c_inhibit_evaluation_warnings;
+        tree e = tsubst_expr (TREE_OPERAND (t, 0), args, tf_none, in_decl, false);
+        tree r = tsubst_expr (TREE_OPERAND (t, 1), args, tf_none, in_decl, false);
+        tree result = finish_valid_expr (e, r);
+        --c_inhibit_evaluation_warnings;
+        --cp_unevaluated_operand;
+        return result;
+      }
+    case VALID_TYPE:
+      {
+        ++cp_unevaluated_operand;
+        ++c_inhibit_evaluation_warnings;
+        tree r = tsubst (TREE_OPERAND (t, 0), args, 0, in_decl);
+        tree result = finish_valid_type (r);
+        --c_inhibit_evaluation_warnings;
+        --cp_unevaluated_operand;
+        return result;
+      }
+
     case COMPONENT_REF:
       {
 	tree object;
@@ -12255,6 +12752,13 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)
     case RECORD_TYPE:
     case UNION_TYPE:
     case ENUMERAL_TYPE:
+
+    case VOID_TYPE: 
+    case BOOLEAN_TYPE:
+    case REAL_TYPE:
+    case NULLPTR_TYPE:
+      // Fall thru
+
     case INTEGER_TYPE:
     case TEMPLATE_TYPE_PARM:
     case TEMPLATE_TEMPLATE_PARM:
@@ -13123,8 +13627,13 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
 					RECUR (MUST_NOT_THROW_COND (t))));
 
     case EXPR_PACK_EXPANSION:
-      error ("invalid use of pack expansion expression");
-      RETURN (error_mark_node);
+      if (processing_constraint ())
+         RETURN (tsubst_pack_conjunction (t, args, complain, in_decl));
+      else
+        {
+          error ("invalid use of pack expansion expression");
+          RETURN (error_mark_node);
+        }
 
     case NONTYPE_ARGUMENT_PACK:
       error ("use %<...%> to expand argument pack");
@@ -13265,7 +13774,7 @@ tsubst_copy_and_build (tree t,
 	  }
 	else
 	  object = NULL_TREE;
-	templ = lookup_template_function (templ, targs);
+        templ = lookup_template_function (templ, targs);
 
 	if (object)
 	  RETURN (build3 (COMPONENT_REF, TREE_TYPE (templ),
@@ -13322,6 +13831,7 @@ tsubst_copy_and_build (tree t,
 	tree type;
 	tree op, r = NULL_TREE;
 
+
 	type = tsubst (TREE_TYPE (t), args, complain, in_decl);
 	if (integral_constant_expression_p
 	    && !cast_valid_in_integral_constant_expression_p (type))
@@ -14171,7 +14681,7 @@ tsubst_copy_and_build (tree t,
 	tree type2 = TRAIT_EXPR_TYPE2 (t);
 	if (type2)
 	  type2 = tsubst_copy (type2, args, complain, in_decl);
-	
+
 	RETURN (finish_trait_expr (TRAIT_EXPR_KIND (t), type1, type2));
       }
 
@@ -14329,6 +14839,7 @@ check_instantiated_arg (tree tmpl, tree t, tsubst_flags_t complain)
 	  return true;
 	}
     }
+
   /* A non-type argument of integral or enumerated type must be a
      constant.  */
   else if (TREE_TYPE (t)
@@ -14339,6 +14850,7 @@ check_instantiated_arg (tree tmpl, tree t, tsubst_flags_t complain)
 	error ("integral expression %qE is not constant", t);
       return true;
     }
+
   return false;
 }
 
@@ -14469,6 +14981,7 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)
 			 complain, gen_tmpl);
       push_nested_class (ctx);
     }
+
   /* Substitute template parameters to obtain the specialization.  */
   fndecl = tsubst (DECL_TEMPLATE_RESULT (gen_tmpl),
 		   targ_ptr, complain, gen_tmpl);
@@ -14793,6 +15306,13 @@ fn_type_unification (tree fn,
       goto fail;
     }
 
+
+  // Having deduced all template arguments, evaluate the static constraints. If
+  // the result is false (or an error?) then we cannot instantiate the template.
+  if (!evaluate_decl_constraints (fn, targs)) 
+    goto fail;
+
+
   /* All is well so far.  Now, check:
 
      [temp.deduct]
@@ -17165,6 +17685,14 @@ more_specialized_fn (tree pat1, tree pat2, int len)
       lose2 = TREE_CODE (TREE_VALUE (args2)) == TYPE_PACK_EXPANSION;
     }
 
+  // Compare the templates to each other to deterimine if 
+  // either is more constrained than the other.
+  if (lose1 == lose2) 
+    {
+      lose1 = !more_constrained_p (pat1, pat2);
+      lose2 = !more_constrained_p (pat2, pat1);
+    }
+
   if (lose1 == lose2)
     return 0;
   else if (!lose1)
@@ -17204,7 +17732,8 @@ more_specialized_class (tree main_tmpl, tree pat1, tree pat2)
      types in the arguments, and we need our dependency check functions
      to behave correctly.  */
   ++processing_template_decl;
-  targs = get_class_bindings (main_tmpl, TREE_VALUE (pat1),
+  targs = get_class_bindings (main_tmpl, tmpl1,
+                              TREE_VALUE (pat1),
 			      CLASSTYPE_TI_ARGS (tmpl1),
 			      CLASSTYPE_TI_ARGS (tmpl2));
   if (targs)
@@ -17213,7 +17742,8 @@ more_specialized_class (tree main_tmpl, tree pat1, tree pat2)
       any_deductions = true;
     }
 
-  targs = get_class_bindings (main_tmpl, TREE_VALUE (pat2),
+  targs = get_class_bindings (main_tmpl, tmpl2,
+                              TREE_VALUE (pat2),
 			      CLASSTYPE_TI_ARGS (tmpl2),
 			      CLASSTYPE_TI_ARGS (tmpl1));
   if (targs)
@@ -17248,6 +17778,14 @@ more_specialized_class (tree main_tmpl, tree pat1, tree pat2)
         return -1;
     }
 
+
+  // All things being equal, compare the constraints.
+  // if (more_constrained_p (tmpl1, tmpl2))
+  //   ++winner;
+  // if (more_constrained_p (tmpl2, tmpl1))
+  //   --winner;
+
+
   return winner;
 }
 
@@ -17305,10 +17843,18 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)
    Then, suppose we want to get `S<double*, int>'.  The TPARMS will be
    {T}, the SPEC_ARGS will be {T*, int} and the ARGS will be {double*,
    int}.  The resulting vector will be {double}, indicating that `T'
-   is bound to `double'.  */
+   is bound to `double'. 
+
+   SPEC is the template specialization type from which we can find the
+   actual specialization.
+
+   NOTE The explicit addition of SPEC as an argument is due to a change in the
+   declaration of this function (main_tmpl replaced spec). But, we need the
+   specialization in order to appropriately deduce constraints. */
 
 static tree
-get_class_bindings (tree main_tmpl, tree tparms, tree spec_args, tree args)
+get_class_bindings (tree main_tmpl, tree spec, tree tparms, tree spec_args, 
+                    tree args)
 {
   int i, ntparms = TREE_VEC_LENGTH (tparms);
   tree deduced_args;
@@ -17335,6 +17881,7 @@ get_class_bindings (tree main_tmpl, tree tparms, tree spec_args, tree args)
     if (! TREE_VEC_ELT (innermost_deduced_args, i))
       return NULL_TREE;
 
+
   /* Verify that nondeduced template arguments agree with the type
      obtained from argument deduction.
 
@@ -17358,6 +17905,7 @@ get_class_bindings (tree main_tmpl, tree tparms, tree spec_args, tree args)
 			      INNERMOST_TEMPLATE_ARGS (args)))
     return NULL_TREE;
 
+
   /* Now that we have bindings for all of the template arguments,
      ensure that the arguments deduced for the template template
      parameters have compatible template parameter lists.  See the use
@@ -17366,6 +17914,23 @@ get_class_bindings (tree main_tmpl, tree tparms, tree spec_args, tree args)
   if (!template_template_parm_bindings_ok_p (tparms, deduced_args))
     return NULL_TREE;
 
+
+  // If the arguments are non-dependent, check the requirements. Check that the
+  // deduced arguments satisfy the template requirements. If not, then return
+  // NULL_TREE, indicating that the arguments could not be deduced.
+  //
+  // We want to do this before substituting the deduced arguments back into
+  // the specialization pattern.
+  //
+  // We have to check for dependent args since more_specialized_class calls
+  // this function using template parameters, and we can't evaluate dependent
+  // expressions.
+  if (!uses_template_parms (deduced_args))
+    {
+      if (!evaluate_type_constraints (spec, spec_args))
+        return false;
+    }
+
   return deduced_args;
 }
 
@@ -17534,6 +18099,7 @@ most_specialized_class (tree type, tree tmpl, tsubst_flags_t complain)
     {
       tree partial_spec_args;
       tree spec_args;
+      tree spec = TREE_TYPE (t);
       tree parms = TREE_VALUE (t);
 
       partial_spec_args = CLASSTYPE_TI_ARGS (TREE_TYPE (t));
@@ -17575,13 +18141,13 @@ most_specialized_class (tree type, tree tmpl, tsubst_flags_t complain)
       if (partial_spec_args == error_mark_node)
 	return error_mark_node;
 
-      spec_args = get_class_bindings (tmpl, parms,
-				      partial_spec_args,
+      spec_args = get_class_bindings (tmpl, spec, parms, partial_spec_args,
 				      args);
       if (spec_args)
 	{
 	  if (outer_args)
 	    spec_args = add_to_template_args (outer_args, spec_args);
+
 	  list = tree_cons (spec_args, TREE_VALUE (t), list);
 	  TREE_TYPE (list) = TREE_TYPE (t);
 	}
@@ -19307,6 +19873,16 @@ value_dependent_expression_p (tree expression)
 		|| (type2 ? dependent_type_p (type2) : false));
       }
 
+    case VALID_EXPR:
+      // Is value-dependent iff either if its first argument is type
+      // dependent or its second is value dependent.
+      return type_dependent_expression_p (TREE_OPERAND (expression, 0))
+          || value_dependent_expression_p (TREE_OPERAND (expression, 1));
+    
+    case VALID_TYPE:
+      // Value depednent iff its operand is dependent.
+      return dependent_type_p (TREE_OPERAND (expression, 0));
+
     case MODOP_EXPR:
       return ((value_dependent_expression_p (TREE_OPERAND (expression, 0)))
 	      || (value_dependent_expression_p (TREE_OPERAND (expression, 2))));
@@ -20489,4 +21065,104 @@ print_template_statistics (void)
 	   htab_collisions (type_specializations));
 }
 
+
+// Returns the sequence of arguments that can be substituted for parms, given
+// args as an input vector. This includes the use of default arguments and
+// parameter packs.
+tree
+deduce_constraint_parameters (tree parms, tree args)
+{
+  return coerce_template_parms (parms, args, NULL_TREE, tf_none, true, true);
+}
+
+// Instantiate an atomic proposition in a constraint expression.
+//
+// This is done by instantiating the proposition as a constant expression, 
+// ignoring warnings and errors.
+tree
+instantiate_proposition (tree prop, tree args)
+{
+  process_constraint guard;
+  return tsubst_expr (prop, args, tf_none, NULL_TREE, true);
+}
+
+// Substitute args into each proposition in the proposition list.
+static tree
+tsubst_proposition_list (tree t, tree args)
+{
+  int n = TREE_VEC_LENGTH (t);
+  tree r = make_tree_vec (n);
+  for (int i = 0; i < n; ++i)
+    TREE_VEC_ELT (r, i) = instantiate_proposition (TREE_VEC_ELT (t, i), args);
+  return r;
+}
+
+// Substitute args into each proposition list in the proposition lists.
+static tree
+tsubst_proposition_lists (tree t, tree args)
+{
+  int n = TREE_VEC_LENGTH (t);
+  tree r = make_tree_vec (n);
+  for (int i = 0; i < n; ++i)
+    TREE_VEC_ELT (r, i) = tsubst_proposition_list (TREE_VEC_ELT (t, i), args);
+  return r;
+}
+
+
+// Substitute args into the components of the constraint info block.
+static tree
+tsubst_constraint_info (tree t, tree args)
+{
+  tree r = make_tree_vec (5);
+
+  // Instantiate the various expressions associated with the 
+  if (tree x = TREE_VEC_ELT (t, 0))
+    TREE_VEC_ELT (r, 0) = tsubst_expr (x, args, tf_none, NULL_TREE, false);
+  if (tree x = TREE_VEC_ELT (t, 1))
+    TREE_VEC_ELT (r, 1) = tsubst_expr (x, args, tf_none, NULL_TREE, false);
+  if (tree x = TREE_VEC_ELT (t, 4))
+    TREE_VEC_ELT (r, 4) = tsubst_expr (x, args, tf_none, NULL_TREE, false);
+
+  // Instantiate the propositions lists.
+  TREE_VEC_ELT (r, 2) = tsubst_proposition_lists (TREE_VEC_ELT (t, 2), args);
+  TREE_VEC_ELT (r, 3) = tsubst_proposition_lists (TREE_VEC_ELT (t, 3), args);
+
+  return r;
+}
+
+
+// Return a substitution of the constraints for the function declaration, T. If
+// T is a non-template member function, evaluaet the constraints, and return the
+// results. Otherwise, if T is a template propagate the dependent constraints
+// as they are, so that they can be fully instantiated later. 
+//
+// FIXME: I need to instantiate the constraints associated with each template
+// parameter for improved error handling.
+tree
+tsubst_constraints (tree t, tree args, tsubst_flags_t complain, tree in_decl)
+{
+  // Get constraint info
+  tree info = DECL_CONSTRAINT (t);
+  if (!info)
+    return NULL_TREE;
+
+  tree tmpl = DECL_TI_TEMPLATE (t);
+  if (DECL_MEMBER_TEMPLATE_P (tmpl)) 
+    return tsubst_constraint_info (info, args);
+  else if (evaluate_constraints (info, args)) 
+    return boolean_true_node;
+   else 
+     return boolean_false_node;
+}
+
+
+// Returns true if the current instantiation is a class template.
+bool
+instantiating_class ()
+{
+  tinst_level* inst = current_instantiation();
+  return TREE_CODE (inst->decl) == RECORD_TYPE;
+}
+
 #include "gt-cp-pt.h"
+
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
index db093e0..b959320 100644
--- a/gcc/cp/semantics.c
+++ b/gcc/cp/semantics.c
@@ -45,6 +45,8 @@ along with GCC; see the file COPYING3.  If not see
 #include "gimple.h"
 #include "bitmap.h"
 
+#include <vector>
+
 /* There routines provide a modular interface to perform many parsing
    operations.  They may therefore be used during actual parsing, or
    during template instantiation, which may be regarded as a
@@ -2488,8 +2490,10 @@ finish_template_template_parm (tree aggr, tree identifier)
   DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;
   DECL_TEMPLATE_RESULT (tmpl) = decl;
   DECL_ARTIFICIAL (decl) = 1;
+  DECL_CONSTRAINT (decl) = take_constraints ();
   end_template_decl ();
 
+
   gcc_assert (DECL_TEMPLATE_PARMS (tmpl));
 
   check_default_tmpl_args (decl, DECL_TEMPLATE_PARMS (tmpl), 
@@ -2577,7 +2581,7 @@ begin_class_definition (tree t)
       t = make_class_type (TREE_CODE (t));
       pushtag (TYPE_IDENTIFIER (t), t, /*tag_scope=*/ts_current);
     }
-  maybe_process_partial_specialization (t);
+
   pushclass (t);
   TYPE_BEING_DEFINED (t) = 1;
 
@@ -2761,6 +2765,7 @@ finish_template_type (tree name, tree args, int entering_scope)
   type = lookup_template_class (name, args,
 				NULL_TREE, NULL_TREE, entering_scope,
 				tf_warning_or_error | tf_user);
+
   if (type == error_mark_node)
     return type;
   else if (CLASS_TYPE_P (type) && !alias_type_or_template_p (type))
@@ -5320,6 +5325,8 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,
   return type;
 }
 
+
+
 /* Called from trait_expr_value to evaluate either __has_nothrow_assign or 
    __has_nothrow_copy, depending on assign_p.  */
 
@@ -5368,6 +5375,7 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)
   return true;
 }
 
+
 /* Actually evaluates the trait.  */
 
 static bool
@@ -5442,8 +5450,18 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)
       return (NON_UNION_CLASS_TYPE_P (type1));
 
     case CPTK_IS_CONVERTIBLE_TO:
-      /* TODO  */
-      return false;
+    {
+      // We need to create an argument (expression) of the source type in order
+      // to lookup user-defined conversion sequences. It seems like the best way
+      // to do that is to create a typed placeholder.
+      tree t = make_node (PLACEHOLDER_EXPR);
+      TREE_TYPE (t) = type1;
+      bool r = can_convert_arg (type2, type1, t, LOOKUP_IMPLICIT, tf_none);
+      // inform (input_location, 
+      //         "\n--------------\nFROM: %qT\nTO:   %qT\nVAL:  %d\n",
+      //         type1, type2, r);
+      return r;
+    }
 
     case CPTK_IS_EMPTY:
       return (NON_UNION_CLASS_TYPE_P (type1) && CLASSTYPE_EMPTY_P (type1));
@@ -5472,12 +5490,26 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)
     case CPTK_IS_UNION:
       return (type_code1 == UNION_TYPE);
 
+    case CPTK_IS_SAME:
+      return same_type_p (type1, type2);
+
     default:
       gcc_unreachable ();
       return false;
     }
 }
 
+// Evaluate the given type trait.
+inline static bool
+trait_expr_value (tree t)
+{
+  gcc_assert (TREE_CODE (t) == TRAIT_EXPR);
+  return trait_expr_value (TRAIT_EXPR_KIND (t), 
+                           TRAIT_EXPR_TYPE1 (t), 
+                           TRAIT_EXPR_TYPE2 (t));
+}
+
+
 /* If TYPE is an array of unknown bound, or (possibly cv-qualified)
    void, or a complete type, returns it, otherwise NULL_TREE.  */
 
@@ -5519,13 +5551,8 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)
 	      || kind == CPTK_IS_POLYMORPHIC
 	      || kind == CPTK_IS_STD_LAYOUT
 	      || kind == CPTK_IS_TRIVIAL
-	      || kind == CPTK_IS_UNION);
-
-  if (kind == CPTK_IS_CONVERTIBLE_TO)
-    {
-      sorry ("__is_convertible_to");
-      return error_mark_node;
-    }
+	      || kind == CPTK_IS_UNION
+        || kind == CPTK_IS_SAME);
 
   if (type1 == error_mark_node
       || ((kind == CPTK_IS_BASE_OF || kind == CPTK_IS_CONVERTIBLE_TO)
@@ -5534,12 +5561,17 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)
 
   if (processing_template_decl)
     {
-      tree trait_expr = make_node (TRAIT_EXPR);
-      TREE_TYPE (trait_expr) = boolean_type_node;
-      TRAIT_EXPR_TYPE1 (trait_expr) = type1;
-      TRAIT_EXPR_TYPE2 (trait_expr) = type2;
-      TRAIT_EXPR_KIND (trait_expr) = kind;
-      return trait_expr;
+      // Only build a trait expr if one of the types is actually dependent.
+      // Otherwise, just evaluate the trait on the spot.
+      if (dependent_type_p (type1) || dependent_type_p (type2))
+        {
+          tree trait_expr = make_node (TRAIT_EXPR);
+          TREE_TYPE (trait_expr) = boolean_type_node;
+          TRAIT_EXPR_TYPE1 (trait_expr) = type1;
+          TRAIT_EXPR_TYPE2 (trait_expr) = type2;
+          TRAIT_EXPR_KIND (trait_expr) = kind;
+          return trait_expr;
+        }
     }
 
   switch (kind)
@@ -5576,8 +5608,11 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)
     case CPTK_IS_ENUM:
     case CPTK_IS_UNION:
       break;
-    
+
+    case CPTK_IS_SAME:
     case CPTK_IS_CONVERTIBLE_TO:
+      break;
+    
     default:
       gcc_unreachable ();
     }
@@ -6700,8 +6735,9 @@ verify_constant (tree t, bool allow_non_constant, bool *non_constant_p)
 	      if (flag_permissive)
 		return false;
 	    }
-	  else
+	  else {
 	    error ("%q+E is not a constant expression", t);
+    }
 	}
       *non_constant_p = true;
     }
@@ -7870,6 +7906,10 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,
 	 used, and they can't do anything with it, so just return it.  */
       return t;
 
+    case TEMPLATE_ID_EXPR:
+        *non_constant_p = true;
+        break;
+
     case LAMBDA_EXPR:
     case PREINCREMENT_EXPR:
     case POSTINCREMENT_EXPR:
@@ -7882,6 +7922,7 @@ cxx_eval_constant_expression (const constexpr_call *call, tree t,
     case THROW_EXPR:
     case MODIFY_EXPR:
     case MODOP_EXPR:
+
       /* GCC internal stuff.  */
     case VA_ARG_EXPR:
     case OBJ_TYPE_REF:
@@ -8144,6 +8185,8 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)
     case CONST_DECL:
     case SIZEOF_EXPR:
     case ALIGNOF_EXPR:
+    case VALID_EXPR:
+    case VALID_TYPE:
     case OFFSETOF_EXPR:
     case NOEXCEPT_EXPR:
     case TEMPLATE_PARM_INDEX:
@@ -9497,4 +9540,719 @@ is_lambda_ignored_entity (tree val)
   return false;
 }
 
+
+// Concepts stuff
+//   The following functions deal with concepts and axioms. 
+//
+// TODO: Move into constraint.c?
+
+
+namespace {
+
+// Return the first template parameter of the template declaration, DECL.
+tree
+get_first_template_parameter (tree decl)
+{
+  tree params = DECL_TEMPLATE_PARMS (decl);
+  return TREE_VALUE (TREE_VEC_ELT (TREE_VALUE(params), 0));
+}
+
+} // namespace
+
+
+// Construct a template type parameter with the given IDENTIFIER. Is
+static tree
+build_constrained_type_parameter (tree identifier)
+{
+  return finish_template_type_parm (class_type_node, identifier);
+}
+
+// Construct a template non-type parameter with the given IDENTIFIER and
+// the same properties as the PROTOtype declaration.
+static tree
+build_constrained_non_type_parameter (tree identifier, tree proto)
+{
+  return cp_build_parm_decl (identifier, TREE_TYPE (proto));
+}
+
+// Construct a template template parameter with the given IDENTIFIER and
+// the same template parameters as the PROTOtype declaration.
+static tree
+build_constrained_template_parameter (tree identifier, tree proto)
+{
+  // NOTE: Much of this is duplicated from finish_template_template_parm,
+  // so the functions could be merged.
+  tree decl = build_decl (input_location, TYPE_DECL, identifier, NULL_TREE);
+  tree tmpl = build_lang_decl (TEMPLATE_DECL, identifier, NULL_TREE);
+  DECL_TEMPLATE_PARMS (tmpl) = copy_node (DECL_TEMPLATE_PARMS (proto));
+  DECL_TEMPLATE_RESULT (tmpl) = decl;
+  DECL_ARTIFICIAL (decl) = 1;
+  return finish_template_type_parm (class_type_node, tmpl);
+}
+
+
+// Build a constrained template parameter for the given declaration. 
+//
+// Note that this does not assemble the final constraint, that is done later in
+// the build_constraint_expression function.
+//
+// IDENTIFIER is the name of the declared parameter. 
+//
+// CONSTRAINT is function template declaration that will be evaluated as the
+// actual constraint.
+//
+// PROTO is the prototype of the template parameter being declared.
+tree
+build_constrained_parameter (tree identifier, tree, tree proto)
+{
+  // Create the the template parmeter.
+  tree parm = NULL_TREE;
+  switch (TREE_CODE (proto))
+    {
+    case TYPE_DECL:
+      parm = build_constrained_type_parameter (identifier);
+      break;
+    case PARM_DECL:
+      parm =  build_constrained_non_type_parameter (identifier, proto);
+      break;
+    case TEMPLATE_DECL:
+      parm = build_constrained_template_parameter (identifier, proto);
+      break;
+    default:
+      debug_tree (proto);
+      gcc_unreachable ();
+    }
+
+
+  return parm;
+}
+
+// Returns true if the template parameter declares a parameter pack.
+static inline bool
+is_parameter_pack (tree parm)
+{
+  switch (TREE_CODE (parm)) 
+    {
+    case TYPE_DECL:
+    case TEMPLATE_DECL:
+      return TEMPLATE_TYPE_PARAMETER_PACK (TREE_TYPE (parm));
+    case PARM_DECL:
+      return TEMPLATE_PARM_PARAMETER_PACK (DECL_INITIAL (parm));
+    default:
+      gcc_unreachable ();
+    }
+}
+
+// Return a template argument corresponding to the declared template PARM. If
+// the parameter is constrained by a variadic constraint, then the argument is
+// pack-expanded.
+static tree
+get_constrained_argument_from_parm (tree parm)
+{
+  // Get the declaration that will be used as a template argument.
+  tree arg = NULL_TREE;
+  switch (TREE_CODE (parm))
+    {
+    case TYPE_DECL: arg = TREE_TYPE (parm); break;
+    case PARM_DECL: arg = DECL_INITIAL (parm); break;
+    case TEMPLATE_DECL: arg = parm; break;
+    default:
+      gcc_unreachable ();
+    }
+
+  // Is declaring template parameter a variadic constraint?
+  tree cons = TREE_VALUE (DECL_CONSTRAINT (parm));
+  tree proto = get_first_template_parameter (cons);
+  if (is_parameter_pack (parm) && is_parameter_pack (proto)) {
+    arg = make_pack_expansion (arg);
+  }
+
+  return arg;
+}
+
+// Create a vector with 1 argument: the declared parameter.
+static tree
+identifier_to_constraint_args (tree parm)
+{
+  tree args = make_tree_vec (1);
+  TREE_VEC_ELT (args, 0) = get_constrained_argument_from_parm (parm);
+  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (args, 1);
+  return args;
+}
+
+// Create a vector of arguments from the template-ID that includes the declared
+// PARM as the first argument, followed by the original arguments of the
+// template-ID.
+static tree
+template_id_to_constraint_args (tree id, tree parm)
+{
+  tree old_args = TREE_OPERAND (id, 1);
+  int n = TREE_VEC_LENGTH (old_args);
+  tree new_args = make_tree_vec (n + 1);
+  TREE_VEC_ELT (new_args, 0) = get_constrained_argument_from_parm (parm);
+  for (int i = 0; i < n; ++i) 
+    TREE_VEC_ELT (new_args, i + 1) = TREE_VEC_ELT (old_args, i);
+  SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_args, n + 1);
+  return new_args;
+}
+
+// Transform the ID expression, representing a constraint, into a sequence of
+// template (constraint) arguments that includes the declared PARM as the
+// first such argument.
+static tree
+get_constraint_args (tree id, tree parm)
+{
+  tree args;
+  switch (TREE_CODE (id))
+    {
+      case IDENTIFIER_NODE:
+        args = identifier_to_constraint_args (parm);
+        break;
+      case TEMPLATE_ID_EXPR:
+        args = template_id_to_constraint_args (id, parm);
+        break;
+      default:
+        gcc_unreachable ();
+    }
+  return args;
+}
+
+
+// For a constrained template parameter declaration C T, where C is a function
+// template described by DECL, and T is the declared parameter identifier
+// described by NAME, build the dependent call C<T>(). 
+// 
+// When ID is a template-id expression (e.g. C<X...>), then the result is a new
+// expression, C<T, X...>(). A new template id expression is created from the
+// original, using the declared parameter as the first argument.
+tree
+build_function_constraint (tree id, tree decl, tree parm)
+{
+  // Get the template argument vector for the constraint.
+  tree args = get_constraint_args (id, parm);
+
+  // Build a new overload set referring to the declared function template.
+  tree fn;
+  if (TREE_CODE (id) == IDENTIFIER_NODE)
+    fn = build_overload (decl, NULL);
+  else if (TREE_CODE (id) == TEMPLATE_ID_EXPR)
+    fn = TREE_OPERAND (id, 0);
+  else
+    gcc_unreachable ();
+
+  // Build a new template id expression binding the overload (fn) to its
+  // explicit template arguments.
+  tree expr = lookup_template_function (fn, args);
+
+  // Build a call expression over the overload. 
+  // FIXME: It is probably incorrect to force the result type to be boolean,
+  // but that's really what we want.
+  VEC(tree, gc)* fn_args = NULL;
+  tree check = finish_call_expr (expr, &fn_args, true, false, 0);
+  TREE_TYPE (check) = boolean_type_node;
+  return check;
+}
+
+
+// Buid a constraint expression based from the INFO for the template parameter,
+// PARM. 
+//
+// INFO is a tree list whose purpose is the constraint id as written in
+// the template parameter list, and whose value is the corresponding constraint
+// declaration.
+// 
+// PARM is the declared template parameter.
+// 
+// Note that the CONSTRAINT may be an id expression containing template
+// arguments.
+tree
+build_constraint_expression (tree info, tree parm)
+{
+  // Build a constraint expression for the given template and its initial
+  // parameter (the prototype).
+  tree id = TREE_PURPOSE (info);
+  tree decl = TREE_VALUE (info);
+  tree req = build_function_constraint (id, decl, parm);
+
+  // Wrap the generated expression in a cast to bool.
+  // NOTE: I don't think I need to do this.
+  // req = build_c_cast (input_location, boolean_type_node, req);
+
+  // Get information about parameter packs. If the constraining template is
+  // a variadic constraint (it's 1st parameter is a pack, then we have already
+  // created the expansion (see get_constrained_argument_from_parm). If it
+  // is not a variadic constraint, but this parameter is a parameter pack, we
+  // need to expand the constraint expression here.
+  //
+  // The difference is this:
+  //
+  //    template <typename... Ts> 
+  //      constexpr bool Same(); // variadic constraint
+  //    template <typename T> 
+  //      constexpr bool Integer(); // non-variadic constraint
+  //
+  //  template <Same... Ts> // requires Same<Ts...>()
+  //    void f();
+  //  template <Integer... Ts> // requires Integer<Ts>()...
+  //    void f();
+  tree proto = get_first_template_parameter (decl);
+  if (!is_parameter_pack (proto) && is_parameter_pack (parm))
+    req = make_pack_expansion (req);
+
+  return req;
+}
+
+
+// Fix the template parameter constraints by building constraint expressions
+// for the constraint "description" attached to each template parameter. 
+// 
+// Returns a conjunction of the constraints.
+tree
+build_shorthand_constraints (tree parms)
+{
+  // If we're given a tree_list, then we're building constraints from a
+  // template template parameter. We can get the parameter vector as the first 
+  // element of that list.
+  //
+  // FIXME: First element or last element? Probably the first, if the current
+  // template parameters defines a stack.
+  if (TREE_CODE (parms) == TREE_LIST)
+    parms = TREE_VALUE (parms);
+
+
+  // Obviously, don't build constraints if we don't have any parameters.
+  if (parms == NULL_TREE || TREE_VEC_LENGTH (parms) == 0)
+    return NULL_TREE;
+
+  // Iterate over the current parameter vector and translate the constraint
+  // description into a constraint expression.
+  tree lhs = NULL_TREE;
+  for (int i = 0 ; i < TREE_VEC_LENGTH(parms); ++i) {
+    // Each parameter is actually represented by a description, a tree list
+    // that encodes the declaration. Attach a constraint expression to that
+    // description. Note that invalid parameters are represented by 
+    // error_mark_node---those don't have constraints.
+    tree desc = TREE_VEC_ELT (parms, i);
+    tree parm = TREE_VALUE (desc);
+    if (parm == error_mark_node)
+      continue;
+
+    // Build the constraint expression and associate it with its declaring
+    // parameter, and build a conjunction of those constraints.
+    tree cons = DECL_CONSTRAINT (parm);
+    if (cons) {
+      tree rhs = build_constraint_expression (cons, parm);
+      DECL_CONSTRAINT (parm) = rhs;
+
+      // Fold the requirements into a conjunction.
+      if (!lhs)
+        lhs = rhs;
+      else
+        lhs = cp_build_binary_op (input_location, TRUTH_ANDIF_EXPR, lhs, rhs, 0);
+    }
+  }
+
+  return lhs;
+}
+
+// Helper function for conjoin_constraints.
+static inline tree
+conjoin_non_null (tree l, tree r)
+{
+  return cp_build_binary_op (input_location, TRUTH_ANDIF_EXPR, l, r, 0);
+}
+
+// Return a conjunction of the requirements l and r. Either l or r may be null,
+// denoting the absence of requiremetns. If both are null, return NULL_TREE,
+// indicating the empty set of constraints.
+//
+// FIXME: Deprecate this function in favor of conjoin_requirements.
+tree
+conjoin_constraints (tree l, tree r)
+{
+  if (l)
+    return r ? conjoin_non_null (l, r) : l;
+  else if (r)
+    return r;
+  else
+    return NULL_TREE;
+}
+
+// Same as conjoin constraints, but having the correct name.
+tree
+conjoin_requirements (tree l, tree r)
+{
+  return conjoin_constraints (l, r);
+}
+
+
+// Returns the concatenation of two vectors of a and b.
+static tree
+concatenate_vectors (tree a, tree b)
+{
+  gcc_assert (TREE_CODE (a) == TREE_VEC);
+  gcc_assert (TREE_CODE (b) == TREE_VEC);
+
+  int m = TREE_VEC_LENGTH (a);
+  int n = TREE_VEC_LENGTH (b);
+  tree r = make_tree_vec (m + n);
+  for (int i = 0; i < m; ++i)
+    TREE_VEC_ELT (r, i) = TREE_VEC_ELT (a, i);
+  for (int i = 0; i < n; ++i)
+    TREE_VEC_ELT (r, m + i) = TREE_VEC_ELT (b, i);
+  return r;
+}
+
+// Returns the cross product of two vectors of vectors a and b.
+static tree
+cross_vectors (tree a, tree b)
+{
+  gcc_assert (TREE_CODE (a) == TREE_VEC);
+  gcc_assert (TREE_CODE (b) == TREE_VEC);
+
+  int m = TREE_VEC_LENGTH (a);
+  int n = TREE_VEC_LENGTH (b);
+  tree r = make_tree_vec(m * n);
+  int k = 0;
+  for (int i = 0; i < m; ++i)
+    for (int j = 0; j < n; ++j)
+      {
+        tree p = TREE_VEC_ELT (a, i);
+        tree q = TREE_VEC_ELT (b, j);
+        TREE_VEC_ELT (r, k++) = concatenate_vectors (p, q);
+      }
+  return r;
+}
+
+// Conjoin the original left decomposed constraints with the extended set.
+// This is done efficiently by computing the cross product of the original
+// with the extension.
+//
+// For example, letting + denote branching and adjacency denote concatenation,
+// we can give the following decompositions.
+//
+//    P or Q -> P + Q
+//    (A and B) or (C and D) -> (AB + CD)
+//
+// Merging (conjoining) them, we get:
+//
+//    (P + Q)(AB + CD)  == PAB + PCD + QAB + QCD
+//
+// In other words, distribution over multiplication is effectively the cross
+// product of the terms.
+static inline tree
+merge_left_constraints (tree orig, tree ext)
+{
+  return cross_vectors (orig, ext);
+}
+
+// Merge the original right decomposed constraints with the extended set.
+// This is done efficiently by concatenating the original branches with the
+// extended set.
+//
+// For example, letting + denote branching and adjacency denote concatenation,
+// we can give the following decompositions.
+//
+//    P or Q -> PQ
+//    (A and B) or (C and D) -> (A + B)(C + D) -> AC + AD + BC + BD
+//
+// Merging (conjoining) them, we get:
+//
+//    (PQ) + (AC + AD + BC + BD)
+//
+// In other words, we simply concatenate the branches.
+static inline tree
+merge_right_constraints (tree orig, tree ext)
+{
+  return concatenate_vectors (orig, ext);
+}
+
+
+// Merge the left and right decompositions, L and R, with the current constraint
+// information.
+static inline tree
+merge_constraints (tree cons, tree l, tree r, tree e)
+{
+  tree ci = make_tree_vec (5);
+  TREE_VEC_ELT (ci, 2) = merge_left_constraints (TREE_VEC_ELT (cons, 2), l);
+  TREE_VEC_ELT (ci, 3) = merge_right_constraints (TREE_VEC_ELT (cons, 3), r);
+  TREE_VEC_ELT (ci, 4) = conjoin_requirements (TREE_VEC_ELT (cons, 4), e);
+  return ci;
+}
+
+// Return a new constraint information node, giving the initial left and
+// right decompositions, and the associated requirements.
+static tree
+init_constraints (tree l, tree r, tree e)
+{
+  // Build a tuple containing a number of constraint-related data.
+  tree ci = make_tree_vec (5);
+  TREE_VEC_ELT (ci, 2) = l; // Decomposed assumptions
+  TREE_VEC_ELT (ci, 3) = r; // Decomposed "conclusions"
+  TREE_VEC_ELT (ci, 4) = e; // Cached expression
+  return ci;
+}
+
+
+// Finish building constraints from template parameters by decomposiong the
+// requirements of R and merging that with the current constraint information.
+//
+// TODO: The tuple should really be a new tree node, but I'm being a little
+// lazy right now.
+tree
+finish_template_constraints (tree reqs)
+{
+  if (reqs)
+    return build_constraint_info (reqs);
+  else
+    return current_constraints;
+}
+
+
+static void
+dump_constraint_lists (tree v)
+{
+  extern int diagnose_constraints;
+  ++diagnose_constraints;
+  inform (input_location, "constraint lists\n");
+  int n = TREE_VEC_LENGTH (v);
+  for (int i = 0; i < n; ++i)
+    {
+      tree l = TREE_VEC_ELT (v, i);
+      int m = TREE_VEC_LENGTH (l);
+      for (int j = 0; j < m; ++j)
+        {
+          tree e = TREE_VALUE (TREE_VEC_ELT (l, j));
+          inform (input_location, "  * %qE", e);
+        }
+      if (i + 1 != n)
+        inform (input_location, "-- or --");
+    }
+  --diagnose_constraints;
+}
+
+// Given a constraint expression and a list of arguments. This only fills
+// the essential information for now. 
+//
+// FIXME: This should be the same function as finish_template_constraints.
+// I've broken it out, but it wasn't a good choice. I should fix 
+// tsubst_constraints so that it actually builds a new requires clause and
+// template constraints and then decomposes those.
+tree
+build_constraint_info (tree e)
+{
+  // Rebuild the constraint expression, removing unnecessary nodes.
+  e = rebuild_constraints (e);
+  if (!e)
+    return error_mark_node;
+
+  // Decompose the cumulative constraints into assumption sets.
+  //
+  // FIXME: Decomposition can return errors. Doing this twice means that
+  // all errors will be reported twich. Avoid doing that. 
+  tree l = left_decompose_constraints (e);
+  tree r = right_decompose_constraints (e);
+
+  if (current_constraints)
+    return merge_constraints (current_constraints, l, r, e);
+  else
+    return init_constraints (l, r, e);
+}
+
+
+// Return the current constraints, resetting that pointer to NULL.
+tree
+take_constraints ()
+{
+  tree result = current_constraints;
+  current_constraints = NULL_TREE;
+  return result;
+}
+
+// Constrain the given DECL by attaching the current constraints (if any). DECL
+// can be a class, function, or alias declaration. Note that current_constraints
+// is set to NULL_TREE after the completion of this function.
+//
+// As part of this process, we analyze the constraints, and cache known
+// subsumptions.
+void
+constrain_decl (tree decl)
+{
+  if (current_constraints)
+    DECL_CONSTRAINT (decl) = take_constraints ();
+}
+
+
+/* Returns true when the constraint A is a refinement of the constraint B.
+   Said otherwise, A includes the requirements of B, B's requirements are a
+   subset of A's, A entails B, or A is stronger than or the same as B.
+
+   The current implementation considers null constraints to be the most
+   general: weaker than non-empty constraints. In the case where both
+   constraints are non-empty, we can only compare for equivalence, not
+   order. That will change with concepts and axioms. */
+bool
+refined_constraint_p (tree a, tree b)
+{
+  if (!a)
+    return !b;
+  else if (!b)
+    return true;
+  else return cp_tree_equal (a, b);
+}
+
+
+// Build a concept declaration: a typedecl and its corresponding concept
+// type. The template decl is added later.
+tree
+build_concept (tree identifier, tree parms, tree cons)
+{
+  // FIXME: This is clearly not complete. Check for duplicate declaration.
+  tree decl = build_decl (input_location, CONCEPT_DECL, identifier, NULL_TREE);
+  if (parms) {
+    tree tmpl = build_lang_decl (TEMPLATE_DECL, identifier, NULL_TREE);
+    DECL_TEMPLATE_PARMS (tmpl) = parms;
+    DECL_TEMPLATE_RESULT (tmpl) = decl;
+  }
+  DECL_CONSTRAINT (decl) = cons;
+  return decl;
+}
+
+
+// Create a new valid-type node.
+static tree
+build_valid_type (tree t)
+{
+  t = build_min (VALID_TYPE, boolean_type_node, t);
+  TREE_SIDE_EFFECTS (t) = 0;
+  TREE_READONLY (t) = 1;
+  TREE_CONSTANT (t) = 1;
+  return t;
+}
+
+// Create a new valid-expr node.
+static tree
+build_valid_expr (tree t, tree r)
+{
+  t = build_min (VALID_EXPR, boolean_type_node, t, r);
+  TREE_SIDE_EFFECTS (t) = 0;
+  TREE_READONLY (t) = 1;
+  TREE_CONSTANT (t) = 1;
+  return t;
+}
+
+
+// Returns true if t denotes a valid type name.
+static tree
+eval_valid_type (tree t)
+{
+  if (t == error_mark_node)
+    return boolean_false_node;
+  else
+    return boolean_true_node;
+}
+
+
+static tree
+eval_valid_expr (tree t, tree r)
+{
+  // If the argument type is ever an error, the it is not valid. If the
+  // tree is a type, then it must be valid, so return true.
+  if (t == error_mark_node)
+    return boolean_false_node;
+
+  // Avoid "unused" warnings. Hopefully, that's all this does.
+  t = mark_type_use (t);
+
+  // If the node is not typed, then it is not valid.
+  //
+  // Note that the if the syntax was valid, then the resulting expresion
+  // was also folded, so we should have only true or false.
+  if (TREE_TYPE (t) == error_mark_node)
+    return boolean_false_node;
+  else
+    return r;
+}
+
+// Finish processing a valid-type expression. If we can't immediately
+// evaluate the trait (e.g., because T is a dependent type), then build an
+// expression as a placeholder.
+tree
+finish_valid_type (tree t)
+{
+  if (processing_template_decl)
+    if (dependent_type_p (t))
+      return build_valid_type (t);
+  return eval_valid_type (t);
+}
+
+// Finish processing a valid-expr expression. When we can't immediately
+// evaluate the trait (e.g,. because the operands are value-dependent), then
+// build an expression as a placeholder.
+tree
+finish_valid_expr (tree t, tree r)
+{
+  if (processing_template_decl)
+    if (value_dependent_expression_p (t) || value_dependent_expression_p (r))
+      return build_valid_expr (t, r);
+  return eval_valid_expr (t, r);
+}
+
+
+// Create a node that will determine if the type of the expression e is the
+// same as t. In particular, we want to create the requirement
+//
+//    __is_same(decltype(e), t)
+//
+// This function is only defined when processing a template.
+tree
+build_is_same (tree e, tree t)
+{
+  gcc_assert(processing_template_decl);
+  tree d = finish_decltype_type (e, false, 0);
+  return finish_trait_expr (CPTK_IS_SAME, d, t);
+}
+
+
+// Create a node that will determine if the type of the expression e is
+// convertible to t. In particular, we want to create the requirement
+//
+//    __is_convertible_to(decltype(e), t).
+//
+// This function is only defined when processing a template.
+tree
+build_is_convertible (tree e, tree t)
+{
+  gcc_assert(processing_template_decl);
+  tree d = finish_decltype_type (e, false, 0);
+  return finish_trait_expr (CPTK_IS_CONVERTIBLE_TO, d, t);
+}
+
+
+// Returns true if t is a member function or member function template.
+bool
+is_member_fn (tree t)
+{
+  return DECL_DECLARES_FUNCTION_P (t) && DECL_CLASS_SCOPE_P (t);
+}
+
+// Returns true if t is a member function template.
+bool
+is_member_fn_template (tree t)
+{
+  tree tmpl = DECL_TI_TEMPLATE (t);
+  if (tmpl)
+    return DECL_DECLARES_FUNCTION_P (t) && DECL_MEMBER_TEMPLATE_P (tmpl);
+  else
+    return false;
+}
+
+// Returns true if t is a non-template member function.
+bool
+is_non_template_member_fn (tree t)
+{
+  return is_member_fn (t) && !is_member_fn_template (t);
+}
+
+
 #include "gt-cp-semantics.h"
diff --git a/gcc/cp/std.c b/gcc/cp/std.c
new file mode 100644
index 0000000..64f3ee1
--- /dev/null
+++ b/gcc/cp/std.c
@@ -0,0 +1,99 @@
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "tm.h"
+#include "tree.h"
+#include "cp-tree.h"
+
+#include "std.h"
+
+// ---------------------
+// Standard Tree Library
+// ---------------------
+//
+// This is a collection of utilities involving trees and the C++ standard
+// library. It is mostly a collection of algorithms.
+
+
+// Create a new tree vector containing the elements of v.
+tree 
+to_tree_vec (const Tree_vector& v)
+{
+  tree vec = make_tree_vec (v.size());
+  for (size_t i = 0; i < v.size(); ++i)
+    TREE_VEC_ELT (vec, i) = v[i];
+  return vec;
+}
+
+// Create a tree vector containing the elements of l.
+tree
+to_tree_vec (const Tree_list& l)
+{
+  tree vec = make_tree_vec (l.size());
+  Tree_list::const_iterator i = l.begin();
+  Tree_list::const_iterator e = l.end();
+  int n = 0;
+  while (i != e)
+    {
+      TREE_VEC_ELT (vec, n) = *i;
+      ++i;
+      ++n;
+    }
+  return vec;
+}
+
+// Copy elements from a tree vector into to std::vector.
+void
+get_vector (tree vec, Tree_vector& out)
+{
+  gcc_assert (TREE_CODE (vec) == TREE_VEC);
+  for (int i = 0; i < TREE_VEC_LENGTH (vec); ++i)
+    out.push_back (TREE_VEC_ELT (vec, i));
+}
+
+// Return a vector containing the tree nodes in vec.
+Tree_vector
+get_vector (tree vec, size_t res)
+{
+  Tree_vector v;
+  v.reserve (res);
+  get_vector (vec, v);
+  return v;
+}
+
+// Return a vector containing a vector of the template parameterse in decl.
+Tree_vector
+get_template_parms (tree decl, size_t res)
+{
+  gcc_assert (TREE_CODE (decl) == TEMPLATE_DECL);
+  tree parms = TREE_VALUE (DECL_TEMPLATE_PARMS (decl));
+  return get_vector (parms, res);
+}
+
+
+// Print the elements of the v.
+void
+debug (const Tree_vector& v)
+{
+  for (size_t i = 0; i < v.size(); ++i)
+    {
+      fprintf (stderr, "elt %lu", i);
+      debug_tree (v[i]);
+    }
+}
+
+void
+debug (const Tree_list& l)
+{
+  Tree_list::const_iterator i = l.begin();
+  Tree_list::const_iterator e = l.end();
+  size_t n = 0;
+  while (i != e) 
+    {
+      fprintf (stderr, "elt %lu", n);
+      debug_tree (*i);
+      ++i;
+      ++n;
+    }
+}
diff --git a/gcc/cp/std.h b/gcc/cp/std.h
new file mode 100644
index 0000000..8ce454c
--- /dev/null
+++ b/gcc/cp/std.h
@@ -0,0 +1,141 @@
+/* Definitions for C++ parsing and type checking.
+   Copyright (C) 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
+   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
+   2012
+   Free Software Foundation, Inc.
+   Contributed by Michael Tiemann (tiemann@cygnus.com)
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_CP_STD_H
+#define GCC_CP_STD_H
+
+#include "ggc.h"
+#include "cp-tree.h"
+
+#include <utility>
+#include <vector>
+#include <list>
+
+// Useful aliases.
+typedef std::pair<tree, tree> Tree_pair;
+typedef std::vector<tree> Tree_vector;
+typedef std::list<tree> Tree_list;
+
+typedef std::pair<tree, tree> tree_pair;
+
+// Make trees from various std containers.
+tree to_tree_vec (const Tree_vector&);
+tree to_tree_vec (const Tree_list&);
+
+// Methods for constructing vectors from various tree nodes. The default
+// argument is the number of elements to reserve initially.
+void   get_vector (tree, Tree_vector&);
+Tree_vector get_vector (tree, size_t = 8);
+Tree_vector get_template_parms (tree, size_t = 8);
+
+void debug (const Tree_vector&);
+void debug (const Tree_list&);
+
+
+// Returns the next iterator past iter.
+template<typename I>
+  inline I next(I iter) { return ++iter; }
+
+
+// -------------------------------------------------------------------------- //
+//                                Best Element
+//
+// The following algorithms are used to find the best element among a set of
+// values, partially ordered by some relation. These functions take a 3way
+// comparison function, which takes 2 arguments and returns a value in the set
+// (-1, 0, 1), which is interpreted as:
+//
+//                 { -1 if a is better than b
+//    comp(a, b) = { 0 if neither is better
+//                 { 1 if b is better than a
+//
+
+// Returns an iterator to a best element among the elements in [first, last),
+// partially ordered by the relation comp, or last if it can be determined
+// that no best element exists.
+//
+// Note that the result is not guaranteed to be the unique best element. Only
+// one of potentially many.
+template<typename I, typename R>
+  inline I 
+  non_unique_best_element (I first, I last, R comp)
+  {
+    I best = first;
+    for (I i = next(first); i != last; ++i) {
+      int x = comp (*best, *i);
+      if (x == -1) {
+        // Keep the current best
+      } else if (x == 1) {
+        // Replace the current best
+        best = i;
+      } else if (x == 0) {
+        // This proves ambiguity.
+        if (next(i) == last)
+          return last;
+      }
+    }
+    return best;
+  }
+
+// Returns true if *last is better than the elements [first, last) as
+// compared using the partial order comp.
+template<typename I, typename R>
+  inline bool 
+  is_best_element (I first, I last, R comp)
+  {
+    while (first != last) {
+      if (comp (*first, *last) != 1)
+        return false;
+      ++first;
+    }
+    return true;
+  }
+
+// Returns an iterator to the best element in the non-empty range [first, last]
+// or last if no single best element can be found.
+template<typename I, typename R>
+  inline I 
+  best_element_nonempty(I first, I last, R comp)
+  {
+    I best = non_unique_best_element (first, last, comp);
+    if (best != last && is_best_element (first, best, comp))
+      return best;
+    else
+      return last;
+  }
+
+// Returns an iterator to the best element in the range [first, last) of
+// elements partially ordered by R. If there is no single best element or if
+// [first == last), this returns last.
+template<typename I, typename R>
+  inline I 
+  best_element(I first, I last, R comp)
+  {
+    if (first == last)
+      return last;
+    else
+      return best_element_nonempty(first, last, comp);
+  }
+
+
+#endif
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
index 7dddf22..a2954f5 100644
--- a/gcc/cp/tree.c
+++ b/gcc/cp/tree.c
@@ -2409,6 +2409,16 @@ called_fns_equal (tree t1, tree t2)
     return cp_tree_equal (t1, t2);
 }
 
+// Two declared values (declval variables) compare equal when they have
+// the same type. These declarations range over all values of the type so
+// they are generally indistinguishable, even when they have different names.
+static bool
+same_declared_values (tree t1, tree t2)
+{
+  return same_type_p (TREE_TYPE (t1), TREE_TYPE (t2));
+}
+
+
 /* Return truthvalue of whether T1 is the same tree structure as T2.
    Return 1 if they are the same. Return 0 if they are different.  */
 
@@ -2466,6 +2476,7 @@ cp_tree_equal (tree t1, tree t2)
       /* We need to do this when determining whether or not two
 	 non-type pointer to member function template arguments
 	 are the same.  */
+
       if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))
 	  || CONSTRUCTOR_NELTS (t1) != CONSTRUCTOR_NELTS (t2))
 	return false;
@@ -2558,6 +2569,11 @@ cp_tree_equal (tree t1, tree t2)
       return false;
 
     case VAR_DECL:
+      // If these are declared values, they can be compared. 
+      // Otherwise, fall through.
+      if (DECL_DECLARED_VALUE (t1) && DECL_DECLARED_VALUE (t2))
+        return same_declared_values (t1, t2);
+    
     case CONST_DECL:
     case FUNCTION_DECL:
     case TEMPLATE_DECL:
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
index ad4b090..ffd284f 100644
--- a/gcc/cp/typeck.c
+++ b/gcc/cp/typeck.c
@@ -143,6 +143,7 @@ complete_type (tree type)
 tree
 complete_type_or_maybe_complain (tree type, tree value, tsubst_flags_t complain)
 {
+  constraint_errors cerrs;
   type = complete_type (type);
   if (type == error_mark_node)
     /* We already issued an error.  */
@@ -150,7 +151,13 @@ complete_type_or_maybe_complain (tree type, tree value, tsubst_flags_t complain)
   else if (!COMPLETE_TYPE_P (type))
     {
       if (complain & tf_error)
-	cxx_incomplete_type_diagnostic (value, type, DK_ERROR);
+        {
+	  cxx_incomplete_type_diagnostic (value, type, DK_ERROR);
+
+          // FIXME: There must be a better design for this...
+          if (cerrs.has_errors ())
+            cerrs.print_errors (input_location);
+        }
       return NULL_TREE;
     }
   else
@@ -1122,6 +1129,18 @@ comp_array_types (const_tree t1, const_tree t2, bool allow_redeclaration)
   return true;
 }
 
+
+// This is a total hack. When we determine if a class template can be used as a
+// template template parameter, we have to compare the constraints of the
+// declared parameter with the constraints of the provided argument, which
+// necessitates a call to cp_tree_equal, and ultimately the function below:
+// comp_template_parms_position. However, when comparing constraints we do *not*
+// want to compare the positions of arguments to see if they represent the same
+// potential types. It is sufficient to know that tw type parameters (or any
+// template parameter, for that matter) are, in fact, equivalent.
+int checking_template_compatability = 0;
+
+
 /* Compare the relative position of T1 and T2 into their respective
    template parameter list.
    T1 and T2 must be template parameter types.
@@ -1140,6 +1159,17 @@ comp_template_parms_position (tree t1, tree t2)
   index1 = TEMPLATE_TYPE_PARM_INDEX (TYPE_MAIN_VARIANT (t1));
   index2 = TEMPLATE_TYPE_PARM_INDEX (TYPE_MAIN_VARIANT (t2));
 
+  // When comparing the constraints of a template template  parameter against
+  // those of a template argument, we don't care if the template parameters have
+  // the same depth. They won't. They should have the same index and whether
+  // both are parameter packs.
+  if (checking_template_compatability) 
+  {
+    return TEMPLATE_PARM_IDX (index1) == TEMPLATE_PARM_IDX (index2)
+        && TEMPLATE_PARM_PARAMETER_PACK (index1) 
+             == TEMPLATE_PARM_PARAMETER_PACK (index2);
+  }
+
   /* Then compare their relative position.  */
   if (TEMPLATE_PARM_IDX (index1) != TEMPLATE_PARM_IDX (index2)
       || TEMPLATE_PARM_LEVEL (index1) != TEMPLATE_PARM_LEVEL (index2)
@@ -1364,6 +1394,11 @@ structural_comptypes (tree t1, tree t2, int strict)
 bool
 comptypes (tree t1, tree t2, int strict)
 {
+  // Continuing with the template template hack. Bypass all of the usual
+  // assurances that types that compare equal have the same canonical type.
+  if (checking_template_compatability)
+    return structural_comptypes (t1, t2, strict);
+
   if (strict == COMPARE_STRICT)
     {
       if (t1 == t2)
@@ -1381,7 +1416,6 @@ comptypes (tree t1, tree t2, int strict)
       if (USE_CANONICAL_TYPES)
 	{
 	  bool result = structural_comptypes (t1, t2, strict);
-	  
 	  if (result && TYPE_CANONICAL (t1) != TYPE_CANONICAL (t2))
 	    /* The two types are structurally equivalent, but their
 	       canonical types were different. This is a failure of the
@@ -1690,6 +1724,8 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)
   return fold_convert (size_type_node, t);
 }
 
+
+
 /* Process a sizeof or alignof expression E with code OP where the operand
    is an expression.  */
 
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
index 58b2db6..04cc1dd 100644
--- a/gcc/cp/typeck2.c
+++ b/gcc/cp/typeck2.c
@@ -1791,6 +1791,7 @@ add_exception_specifier (tree list, tree spec, int complain)
   bool is_ptr;
   diagnostic_t diag_type = DK_UNSPECIFIED; /* none */
 
+  constraint_errors cerrs;
   if (spec == error_mark_node)
     return list;
 
@@ -1812,13 +1813,16 @@ add_exception_specifier (tree list, tree spec, int complain)
     ok = true;
   else
     {
+      // FIXME: Diagnose incomplete type errors related to constraints here,
+      // too.
+
       ok = true;
       /* 15.4/1 says that types in an exception specifier must be complete,
 	 but it seems more reasonable to only require this on definitions
 	 and calls.  So just give a pedwarn at this point; we will give an
 	 error later if we hit one of those two cases.  */
       if (!COMPLETE_TYPE_P (complete_type (core)))
-	diag_type = DK_PEDWARN; /* pedwarn */
+        diag_type = DK_PEDWARN; /* pedwarn */
     }
 
   if (ok)
@@ -1834,9 +1838,10 @@ add_exception_specifier (tree list, tree spec, int complain)
   else
     diag_type = DK_ERROR; /* error */
 
-  if (diag_type != DK_UNSPECIFIED
-      && (complain & tf_warning_or_error))
+  if (diag_type != DK_UNSPECIFIED && (complain & tf_warning_or_error))
     cxx_incomplete_type_diagnostic (NULL_TREE, core, diag_type);
+  else if (cerrs.has_errors ())
+    cerrs.print_errors (input_location);
 
   return list;
 }
diff --git a/gcc/print-tree.c b/gcc/print-tree.c
index 27fb72f..cdded29 100644
--- a/gcc/print-tree.c
+++ b/gcc/print-tree.c
@@ -552,6 +552,9 @@ print_node (FILE *file, const char *prefix, tree node, int indent)
 	{
 	  print_node_brief (file, "attributes",
 			    DECL_ATTRIBUTES (node), indent + 4);
+          if (DECL_CONSTRAINED_P (node))
+            print_node (file, "constraint", DECL_CONSTRAINT (node),
+                              indent + 4);
 	  if (code != PARM_DECL)
 	    print_node_brief (file, "initial", DECL_INITIAL (node),
 			      indent + 4);
diff --git a/gcc/tree.h b/gcc/tree.h
index f9c9a7f..00d5b13 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -2682,6 +2682,19 @@ struct GTY(()) tree_decl_minimal {
    ??? Need to figure out some way to check this isn't a PARM_DECL.  */
 #define DECL_INITIAL(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.initial)
 
+
+/* Holds the set (or sequence) or constraints associated with a declaration. 
+   Constraints are stored as vector of expressions that are used to determine 
+   whether or not the declaration can be used in. For FUNCTION_DECLs, 
+   constraints are also used to partially order overloads.  */
+#define DECL_CONSTRAINT(NODE) \
+   (DECL_COMMON_CHECK (NODE)->decl_common.constraints)
+
+/* True if NODE is a constrained declaration. */
+#define DECL_CONSTRAINED_P(NODE) \
+    (DECL_CONSTRAINT (NODE) != NULL_TREE)
+
+
 /* Holds the size of the datum, in bits, as a tree expression.
    Need not be constant.  */
 #define DECL_SIZE(NODE) (DECL_COMMON_CHECK (NODE)->decl_common.size)
@@ -2866,6 +2879,7 @@ struct GTY(()) tree_decl_common {
   unsigned int pt_uid;
 
   tree size_unit;
+  tree constraints;
   tree initial;
   tree attributes;
   tree abstract_origin;
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
index 0075004..87d70f0 100644
--- a/libstdc++-v3/include/Makefile.am
+++ b/libstdc++-v3/include/Makefile.am
@@ -173,7 +173,15 @@ bits_headers = \
 	${bits_srcdir}/valarray_array.tcc \
 	${bits_srcdir}/valarray_before.h \
 	${bits_srcdir}/valarray_after.h \
-	${bits_srcdir}/vector.tcc
+	${bits_srcdir}/vector.tcc \
+	${bits_srcdir}/cons_type_traits.h \
+	${bits_srcdir}/cons_iterator_base_types.h \
+	${bits_srcdir}/cons_iterator_base_funcs.h \
+	${bits_srcdir}/cons_algofwd.h \
+	${bits_srcdir}/cons_algobase.h \
+	${bits_srcdir}/cons_algo.h \
+	${bits_srcdir}/cons_heap.h
+
 
 bits_sup_srcdir = ${glibcxx_srcdir}/libsupc++
 bits_sup_headers = \
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
index f0d1365..31036d9 100644
--- a/libstdc++-v3/include/Makefile.in
+++ b/libstdc++-v3/include/Makefile.in
@@ -428,7 +428,14 @@ bits_headers = \
 	${bits_srcdir}/valarray_array.tcc \
 	${bits_srcdir}/valarray_before.h \
 	${bits_srcdir}/valarray_after.h \
-	${bits_srcdir}/vector.tcc
+	${bits_srcdir}/vector.tcc \
+	${bits_srcdir}/cons_type_traits.h \
+	${bits_srcdir}/cons_iterator_base_types.h \
+	${bits_srcdir}/cons_iterator_base_funcs.h \
+	${bits_srcdir}/cons_algofwd.h \
+	${bits_srcdir}/cons_algobase.h \
+	${bits_srcdir}/cons_algo.h \
+	${bits_srcdir}/cons_heap.h
 
 bits_sup_srcdir = ${glibcxx_srcdir}/libsupc++
 bits_sup_headers = \
diff --git a/libstdc++-v3/include/bits/algorithmfwd.h b/libstdc++-v3/include/bits/algorithmfwd.h
index fbec55d..7ff72d6 100644
--- a/libstdc++-v3/include/bits/algorithmfwd.h
+++ b/libstdc++-v3/include/bits/algorithmfwd.h
@@ -39,6 +39,10 @@
 #include <initializer_list>
 #endif
 
+#ifdef __GXX_EXPERIMENTAL_CXX1Y__
+#include <bits/cons_algofwd.h>
+#else
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -818,6 +822,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 _GLIBCXX_END_NAMESPACE_ALGO
 } // namespace std
 
+#endif /* __GXX_EXPERIMENTAL_CXX1Y__ */
+
 #ifdef _GLIBCXX_PARALLEL
 # include <parallel/algorithmfwd.h>
 #endif
diff --git a/libstdc++-v3/include/bits/cons_algo.h b/libstdc++-v3/include/bits/cons_algo.h
new file mode 100644
index 0000000..89dabff
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_algo.h
@@ -0,0 +1,5719 @@
+// Algorithm implementation -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
+// 2010, 2011
+// Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /// Swaps the median value of *__a, *__b and *__c to *__a
+  template<typename _Iterator>
+    void
+    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_LessThanComparableConcept<
+      typename iterator_traits<_Iterator>::value_type>)
+
+      if (*__a < *__b)
+  {
+    if (*__b < *__c)
+      std::iter_swap(__a, __b);
+    else if (*__a < *__c)
+      std::iter_swap(__a, __c);
+  }
+      else if (*__a < *__c)
+  return;
+      else if (*__b < *__c)
+  std::iter_swap(__a, __c);
+      else
+  std::iter_swap(__a, __b);
+    }
+
+  /// Swaps the median value of *__a, *__b and *__c under __comp to *__a
+  template<typename _Iterator, typename _Compare>
+    void
+    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c,
+      _Compare __comp)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_BinaryFunctionConcept<_Compare, bool,
+      typename iterator_traits<_Iterator>::value_type,
+      typename iterator_traits<_Iterator>::value_type>)
+
+      if (__comp(*__a, *__b))
+  {
+    if (__comp(*__b, *__c))
+      std::iter_swap(__a, __b);
+    else if (__comp(*__a, *__c))
+      std::iter_swap(__a, __c);
+  }
+      else if (__comp(*__a, *__c))
+  return;
+      else if (__comp(*__b, *__c))
+  std::iter_swap(__a, __c);
+      else
+  std::iter_swap(__a, __b);
+    }
+
+  // for_each
+
+  /// This is an overload used by find() for the Input Iterator case.
+  template<typename _InputIterator, typename _Tp>
+    inline _InputIterator
+    __find(_InputIterator __first, _InputIterator __last,
+     const _Tp& __val, input_iterator_tag)
+    {
+      while (__first != __last && !(*__first == __val))
+  ++__first;
+      return __first;
+    }
+
+  /// This is an overload used by find_if() for the Input Iterator case.
+  template<typename _InputIterator, typename _Predicate>
+    inline _InputIterator
+    __find_if(_InputIterator __first, _InputIterator __last,
+        _Predicate __pred, input_iterator_tag)
+    {
+      while (__first != __last && !bool(__pred(*__first)))
+  ++__first;
+      return __first;
+    }
+
+  /// This is an overload used by find() for the RAI case.
+  template<typename _RandomAccessIterator, typename _Tp>
+    _RandomAccessIterator
+    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
+     const _Tp& __val, random_access_iterator_tag)
+    {
+      typename iterator_traits<_RandomAccessIterator>::difference_type
+  __trip_count = (__last - __first) >> 2;
+
+      for (; __trip_count > 0; --__trip_count)
+  {
+    if (*__first == __val)
+      return __first;
+    ++__first;
+
+    if (*__first == __val)
+      return __first;
+    ++__first;
+
+    if (*__first == __val)
+      return __first;
+    ++__first;
+
+    if (*__first == __val)
+      return __first;
+    ++__first;
+  }
+
+      switch (__last - __first)
+  {
+  case 3:
+    if (*__first == __val)
+      return __first;
+    ++__first;
+  case 2:
+    if (*__first == __val)
+      return __first;
+    ++__first;
+  case 1:
+    if (*__first == __val)
+      return __first;
+    ++__first;
+  case 0:
+  default:
+    return __last;
+  }
+    }
+
+  /// This is an overload used by find_if() for the RAI case.
+  template<typename _RandomAccessIterator, typename _Predicate>
+    _RandomAccessIterator
+    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
+        _Predicate __pred, random_access_iterator_tag)
+    {
+      typename iterator_traits<_RandomAccessIterator>::difference_type
+  __trip_count = (__last - __first) >> 2;
+
+      for (; __trip_count > 0; --__trip_count)
+  {
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+  }
+
+      switch (__last - __first)
+  {
+  case 3:
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+  case 2:
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+  case 1:
+    if (__pred(*__first))
+      return __first;
+    ++__first;
+  case 0:
+  default:
+    return __last;
+  }
+    }
+
+  /// This is an overload used by find_if_not() for the Input Iterator case.
+  template<typename _InputIterator, typename _Predicate>
+    inline _InputIterator
+    __find_if_not(_InputIterator __first, _InputIterator __last,
+      _Predicate __pred, input_iterator_tag)
+    {
+      while (__first != __last && bool(__pred(*__first)))
+  ++__first;
+      return __first;
+    }
+
+  /// This is an overload used by find_if_not() for the RAI case.
+  template<typename _RandomAccessIterator, typename _Predicate>
+    _RandomAccessIterator
+    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
+      _Predicate __pred, random_access_iterator_tag)
+    {
+      typename iterator_traits<_RandomAccessIterator>::difference_type
+  __trip_count = (__last - __first) >> 2;
+
+      for (; __trip_count > 0; --__trip_count)
+  {
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+  }
+
+      switch (__last - __first)
+  {
+  case 3:
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+  case 2:
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+  case 1:
+    if (!bool(__pred(*__first)))
+      return __first;
+    ++__first;
+  case 0:
+  default:
+    return __last;
+  }
+    }
+
+  /// Provided for stable_partition to use.
+  template<typename _InputIterator, typename _Predicate>
+    inline _InputIterator
+    __find_if_not(_InputIterator __first, _InputIterator __last,
+      _Predicate __pred)
+    {
+      return std::__find_if_not(__first, __last, __pred,
+        std::__iterator_category(__first));
+    }
+
+  /// Like find_if_not(), but uses and updates a count of the
+  /// remaining range length instead of comparing against an end
+  /// iterator.
+  template<typename _InputIterator, typename _Predicate, typename _Distance>
+    _InputIterator
+    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
+    {
+      for (; __len; --__len, ++__first)
+  if (!bool(__pred(*__first)))
+    break;
+      return __first;
+    }
+
+  // set_difference
+  // set_intersection
+  // set_symmetric_difference
+  // set_union
+  // for_each
+  // find
+  // find_if
+  // find_first_of
+  // adjacent_find
+  // count
+  // count_if
+  // search
+
+  /**
+   *  This is an uglified
+   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
+   *  overloaded for forward iterators.
+  */
+  template<typename _ForwardIterator, typename _Integer, typename _Tp>
+    _ForwardIterator
+    __search_n(_ForwardIterator __first, _ForwardIterator __last,
+         _Integer __count, const _Tp& __val,
+         std::forward_iterator_tag)
+    {
+      __first = _GLIBCXX_STD_A::find(__first, __last, __val);
+      while (__first != __last)
+  {
+    typename iterator_traits<_ForwardIterator>::difference_type
+      __n = __count;
+    _ForwardIterator __i = __first;
+    ++__i;
+    while (__i != __last && __n != 1 && *__i == __val)
+      {
+        ++__i;
+        --__n;
+      }
+    if (__n == 1)
+      return __first;
+    if (__i == __last)
+      return __last;
+    __first = _GLIBCXX_STD_A::find(++__i, __last, __val);
+  }
+      return __last;
+    }
+
+  /**
+   *  This is an uglified
+   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
+   *  overloaded for random access iterators.
+  */
+  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
+    _RandomAccessIter
+    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
+         _Integer __count, const _Tp& __val, 
+         std::random_access_iterator_tag)
+    {
+      
+      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
+  _DistanceType;
+
+      _DistanceType __tailSize = __last - __first;
+      const _DistanceType __pattSize = __count;
+
+      if (__tailSize < __pattSize)
+        return __last;
+
+      const _DistanceType __skipOffset = __pattSize - 1;
+      _RandomAccessIter __lookAhead = __first + __skipOffset;
+      __tailSize -= __pattSize;
+
+      while (1) // the main loop...
+  {
+    // __lookAhead here is always pointing to the last element of next 
+    // possible match.
+    while (!(*__lookAhead == __val)) // the skip loop...
+      {
+        if (__tailSize < __pattSize)
+    return __last;  // Failure
+        __lookAhead += __pattSize;
+        __tailSize -= __pattSize;
+      }
+    _DistanceType __remainder = __skipOffset;
+    for (_RandomAccessIter __backTrack = __lookAhead - 1; 
+         *__backTrack == __val; --__backTrack)
+      {
+        if (--__remainder == 0)
+    return (__lookAhead - __skipOffset); // Success
+      }
+    if (__remainder > __tailSize)
+      return __last; // Failure
+    __lookAhead += __remainder;
+    __tailSize -= __remainder;
+  }
+    }
+
+  // search_n
+
+  /**
+   *  This is an uglified
+   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,
+   *         _BinaryPredicate)
+   *  overloaded for forward iterators.
+  */
+  template<typename _ForwardIterator, typename _Integer, typename _Tp,
+           typename _BinaryPredicate>
+    _ForwardIterator
+    __search_n(_ForwardIterator __first, _ForwardIterator __last,
+         _Integer __count, const _Tp& __val,
+         _BinaryPredicate __binary_pred, std::forward_iterator_tag)
+    {
+      while (__first != __last && !bool(__binary_pred(*__first, __val)))
+        ++__first;
+
+      while (__first != __last)
+  {
+    typename iterator_traits<_ForwardIterator>::difference_type
+      __n = __count;
+    _ForwardIterator __i = __first;
+    ++__i;
+    while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
+      {
+        ++__i;
+        --__n;
+      }
+    if (__n == 1)
+      return __first;
+    if (__i == __last)
+      return __last;
+    __first = ++__i;
+    while (__first != __last
+     && !bool(__binary_pred(*__first, __val)))
+      ++__first;
+  }
+      return __last;
+    }
+
+  /**
+   *  This is an uglified
+   *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&,
+   *         _BinaryPredicate)
+   *  overloaded for random access iterators.
+  */
+  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
+     typename _BinaryPredicate>
+    _RandomAccessIter
+    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
+         _Integer __count, const _Tp& __val,
+         _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
+    {
+      
+      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
+  _DistanceType;
+
+      _DistanceType __tailSize = __last - __first;
+      const _DistanceType __pattSize = __count;
+
+      if (__tailSize < __pattSize)
+        return __last;
+
+      const _DistanceType __skipOffset = __pattSize - 1;
+      _RandomAccessIter __lookAhead = __first + __skipOffset;
+      __tailSize -= __pattSize;
+
+      while (1) // the main loop...
+  {
+    // __lookAhead here is always pointing to the last element of next 
+    // possible match.
+    while (!bool(__binary_pred(*__lookAhead, __val))) // the skip loop...
+      {
+        if (__tailSize < __pattSize)
+    return __last;  // Failure
+        __lookAhead += __pattSize;
+        __tailSize -= __pattSize;
+      }
+    _DistanceType __remainder = __skipOffset;
+    for (_RandomAccessIter __backTrack = __lookAhead - 1; 
+         __binary_pred(*__backTrack, __val); --__backTrack)
+      {
+        if (--__remainder == 0)
+    return (__lookAhead - __skipOffset); // Success
+      }
+    if (__remainder > __tailSize)
+      return __last; // Failure
+    __lookAhead += __remainder;
+    __tailSize -= __remainder;
+  }
+    }
+
+  // find_end for forward iterators.
+  template<typename _ForwardIterator1, typename _ForwardIterator2>
+    _ForwardIterator1
+    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
+         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
+         forward_iterator_tag, forward_iterator_tag)
+    {
+      if (__first2 == __last2)
+  return __last1;
+      else
+  {
+    _ForwardIterator1 __result = __last1;
+    while (1)
+      {
+        _ForwardIterator1 __new_result
+    = _GLIBCXX_STD_A::search(__first1, __last1, __first2, __last2);
+        if (__new_result == __last1)
+    return __result;
+        else
+    {
+      __result = __new_result;
+      __first1 = __new_result;
+      ++__first1;
+    }
+      }
+  }
+    }
+
+  template<typename _ForwardIterator1, typename _ForwardIterator2,
+     typename _BinaryPredicate>
+    _ForwardIterator1
+    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
+         _ForwardIterator2 __first2, _ForwardIterator2 __last2,
+         forward_iterator_tag, forward_iterator_tag,
+         _BinaryPredicate __comp)
+    {
+      if (__first2 == __last2)
+  return __last1;
+      else
+  {
+    _ForwardIterator1 __result = __last1;
+    while (1)
+      {
+        _ForwardIterator1 __new_result
+    = _GLIBCXX_STD_A::search(__first1, __last1, __first2,
+           __last2, __comp);
+        if (__new_result == __last1)
+    return __result;
+        else
+    {
+      __result = __new_result;
+      __first1 = __new_result;
+      ++__first1;
+    }
+      }
+  }
+    }
+
+  // find_end for bidirectional iterators (much faster).
+  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
+    _BidirectionalIterator1
+    __find_end(_BidirectionalIterator1 __first1,
+         _BidirectionalIterator1 __last1,
+         _BidirectionalIterator2 __first2,
+         _BidirectionalIterator2 __last2,
+         bidirectional_iterator_tag, bidirectional_iterator_tag)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_BidirectionalIteratorConcept<
+          _BidirectionalIterator1>)
+      __glibcxx_function_requires(_BidirectionalIteratorConcept<
+          _BidirectionalIterator2>)
+
+      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
+      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
+
+      _RevIterator1 __rlast1(__first1);
+      _RevIterator2 __rlast2(__first2);
+      _RevIterator1 __rresult = _GLIBCXX_STD_A::search(_RevIterator1(__last1),
+                   __rlast1,
+                   _RevIterator2(__last2),
+                   __rlast2);
+
+      if (__rresult == __rlast1)
+  return __last1;
+      else
+  {
+    _BidirectionalIterator1 __result = __rresult.base();
+    std::advance(__result, -std::distance(__first2, __last2));
+    return __result;
+  }
+    }
+
+  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
+     typename _BinaryPredicate>
+    _BidirectionalIterator1
+    __find_end(_BidirectionalIterator1 __first1,
+         _BidirectionalIterator1 __last1,
+         _BidirectionalIterator2 __first2,
+         _BidirectionalIterator2 __last2,
+         bidirectional_iterator_tag, bidirectional_iterator_tag,
+         _BinaryPredicate __comp)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_BidirectionalIteratorConcept<
+          _BidirectionalIterator1>)
+      __glibcxx_function_requires(_BidirectionalIteratorConcept<
+          _BidirectionalIterator2>)
+
+      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
+      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
+
+      _RevIterator1 __rlast1(__first1);
+      _RevIterator2 __rlast2(__first2);
+      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
+              _RevIterator2(__last2), __rlast2,
+              __comp);
+
+      if (__rresult == __rlast1)
+  return __last1;
+      else
+  {
+    _BidirectionalIterator1 __result = __rresult.base();
+    std::advance(__result, -std::distance(__first2, __last2));
+    return __result;
+  }
+    }
+
+  /**
+   *  @brief  Find last matching subsequence in a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  Start of range to search.
+   *  @param  __last1   End of range to search.
+   *  @param  __first2  Start of sequence to match.
+   *  @param  __last2   End of sequence to match.
+   *  @return   The last iterator @c i in the range
+   *  @p [__first1,__last1-(__last2-__first2)) such that @c *(i+N) ==
+   *  @p *(__first2+N) for each @c N in the range @p
+   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
+   *
+   *  Searches the range @p [__first1,__last1) for a sub-sequence that
+   *  compares equal value-by-value with the sequence given by @p
+   *  [__first2,__last2) and returns an iterator to the __first
+   *  element of the sub-sequence, or @p __last1 if the sub-sequence
+   *  is not found.  The sub-sequence will be the last such
+   *  subsequence contained in [__first,__last1).
+   *
+   *  Because the sub-sequence must lie completely within the range @p
+   *  [__first1,__last1) it must start at a position less than @p
+   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
+   *  length of the sub-sequence.  This means that the returned
+   *  iterator @c i will be in the range @p
+   *  [__first1,__last1-(__last2-__first2))
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      inline _Iter1
+      find_end(_Iter1 __first1, _Iter1 __last1,
+               _Iter2 __first2, _Iter2 __last2)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        return std::__find_end(__first1, __last1, __first2, __last2,
+             std::__iterator_category(__first1),
+             std::__iterator_category(__first2));
+      }
+
+  /**
+   *  @brief  Find last matching subsequence in a sequence using a predicate.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  Start of range to search.
+   *  @param  __last1   End of range to search.
+   *  @param  __first2  Start of sequence to match.
+   *  @param  __last2   End of sequence to match.
+   *  @param  __comp    The predicate to use.
+   *  @return The last iterator @c i in the range @p
+   *  [__first1,__last1-(__last2-__first2)) such that @c
+   *  predicate(*(i+N), @p (__first2+N)) is true for each @c N in the
+   *  range @p [0,__last2-__first2), or @p __last1 if no such iterator
+   *  exists.
+   *
+   *  Searches the range @p [__first1,__last1) for a sub-sequence that
+   *  compares equal value-by-value with the sequence given by @p
+   *  [__first2,__last2) using comp as a predicate and returns an
+   *  iterator to the first element of the sub-sequence, or @p __last1
+   *  if the sub-sequence is not found.  The sub-sequence will be the
+   *  last such subsequence contained in [__first,__last1).
+   *
+   *  Because the sub-sequence must lie completely within the range @p
+   *  [__first1,__last1) it must start at a position less than @p
+   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
+   *  length of the sub-sequence.  This means that the returned
+   *  iterator @c i will be in the range @p
+   *  [__first1,__last1-(__last2-__first2))
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2>()
+      inline _Iter1
+      find_end(_Iter1 __first1, _Iter1 __last1,
+               _Iter2 __first2, _Iter2 __last2,
+               _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        return std::__find_end(__first1, __last1, __first2, __last2,
+             std::__iterator_category(__first1),
+             std::__iterator_category(__first2),
+             __comp);
+      }
+
+  /**
+   *  @brief  Checks that a predicate is true for all the elements
+   *          of a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __pred    A predicate.
+   *  @return  True if the check is true, false otherwise.
+   *
+   *  Returns true if @p __pred is true for each element in the range
+   *  @p [__first,__last), and false otherwise.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    inline bool
+    all_of(_Iter __first, _Iter __last, _Predicate __pred)
+    { return __last == std::find_if_not(__first, __last, __pred); }
+
+  /**
+   *  @brief  Checks that a predicate is false for all the elements
+   *          of a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __pred    A predicate.
+   *  @return  True if the check is true, false otherwise.
+   *
+   *  Returns true if @p __pred is false for each element in the range
+   *  @p [__first,__last), and false otherwise.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    inline bool
+    none_of(_Iter __first, _Iter __last, _Predicate __pred)
+    { return __last == _GLIBCXX_STD_A::find_if(__first, __last, __pred); }
+
+  /**
+   *  @brief  Checks that a predicate is false for at least an element
+   *          of a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __pred    A predicate.
+   *  @return  True if the check is true, false otherwise.
+   *
+   *  Returns true if an element exists in the range @p
+   *  [__first,__last) such that @p __pred is true, and false
+   *  otherwise.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    inline bool
+    any_of(_Iter __first, _Iter __last, _Predicate __pred)
+    { return !std::none_of(__first, __last, __pred); }
+
+  /**
+   *  @brief  Find the first element in a sequence for which a
+   *          predicate is false.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __pred   A predicate.
+   *  @return   The first iterator @c i in the range @p [__first,__last)
+   *  such that @p __pred(*i) is false, or @p __last if no such iterator exists.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    inline _Iter
+    find_if_not(_Iter __first, _Iter __last, _Predicate __pred)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+      return std::__find_if_not(__first, __last, __pred);
+    }
+
+  /**
+   *  @brief  Checks whether the sequence is partitioned.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __pred   A predicate.
+   *  @return  True if the range @p [__first,__last) is partioned by @p __pred,
+   *  i.e. if all elements that satisfy @p __pred appear before those that
+   *  do not.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    inline bool
+    is_partitioned(_Iter __first, _Iter __last, _Predicate __pred)
+    {
+      __first = std::find_if_not(__first, __last, __pred);
+      return std::none_of(__first, __last, __pred);
+    }
+
+  /**
+   *  @brief  Find the partition point of a partitioned range.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __pred    A predicate.
+   *  @return  An iterator @p mid such that @p all_of(__first, mid, __pred)
+   *           and @p none_of(mid, __last, __pred) are both true.
+  */
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    _Iter
+    partition_point(_Iter __first, _Iter __last, _Predicate __pred)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      Difference_type<_Iter> __len = std::distance(__first, __last);
+      Difference_type<_Iter> __half;
+      _Iter __middle;
+
+      while (__len > 0)
+  {
+    __half = __len >> 1;
+    __middle = __first;
+    std::advance(__middle, __half);
+    if (__pred(*__middle))
+      {
+        __first = __middle;
+        ++__first;
+        __len = __len - __half - 1;
+      }
+    else
+      __len = __half;
+  }
+      return __first;
+    }
+
+
+  /**
+   *  @brief Copy a sequence, removing elements of a given value.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __result  An output iterator.
+   *  @param  __value   The value to be removed.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  Copies each element in the range @p [__first,__last) not equal
+   *  to @p __value to the range beginning at @p __result.
+   *  remove_copy() is stable, so the relative order of elements that
+   *  are copied is unchanged.
+  */
+  template<Input_iterator _In, Advanceable _Out, Equality_comparable<Value_type<_In>> _Tp>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out
+      remove_copy(_In __first, _In __last, _Out __result, const _Tp& __value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        for (; __first != __last; ++__first)
+          if (!(*__first == __value))
+            {
+              *__result = *__first;
+              ++__result;
+            }
+        return __result;
+      }
+
+  /**
+   *  @brief Copy a sequence, removing elements for which a predicate is true.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __result  An output iterator.
+   *  @param  __pred    A predicate.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  Copies each element in the range @p [__first,__last) for which
+   *  @p __pred returns false to the range beginning at @p __result.
+   *
+   *  remove_copy_if() is stable, so the relative order of elements that are
+   *  copied is unchanged.
+  */
+  template<Input_iterator _In, Advanceable _Out, Predicate<Value_type<_In>> _Predicate>
+    requires Indirectly_copyable<_In, _Out>()
+    _Out
+    remove_copy_if(_In __first, _In __last, _Out __result, _Predicate __pred)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      for (; __first != __last; ++__first)
+        if (!bool(__pred(*__first)))
+          {
+            *__result = *__first;
+            ++__result;
+          }
+      return __result;
+    }
+
+  /**
+   *  @brief Copy the elements of a sequence for which a predicate is true.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __result  An output iterator.
+   *  @param  __pred    A predicate.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  Copies each element in the range @p [__first,__last) for which
+   *  @p __pred returns true to the range beginning at @p __result.
+   *
+   *  copy_if() is stable, so the relative order of elements that are
+   *  copied is unchanged.
+  */
+  template<Input_iterator _In, Advanceable _Out, Predicate<Value_type<_In>> _Predicate>
+    requires Indirectly_copyable<_In, _Out>()
+    _Out
+    copy_if(_In __first, _In __last, _Out __result, _Predicate __pred)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      for (; __first != __last; ++__first)
+        if (__pred(*__first))
+          {
+            *__result = *__first;
+            ++__result;
+          }
+      return __result;
+    }
+
+
+  template<typename _InputIterator, typename _Size, typename _OutputIterator>
+    _OutputIterator
+    __copy_n(_InputIterator __first, _Size __n,
+       _OutputIterator __result, input_iterator_tag)
+    {
+      if (__n > 0)
+  {
+    while (true)
+      {
+        *__result = *__first;
+        ++__result;
+        if (--__n > 0)
+    ++__first;
+        else
+    break;
+      }
+  }
+      return __result;
+    }
+
+  template<typename _RandomAccessIterator, typename _Size,
+     typename _OutputIterator>
+    inline _OutputIterator
+    __copy_n(_RandomAccessIterator __first, _Size __n,
+       _OutputIterator __result, random_access_iterator_tag)
+    { return std::copy(__first, __first + __n, __result); }
+
+  /**
+   *  @brief Copies the range [first,first+n) into [result,result+n).
+   *  @ingroup mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __n      The number of elements to copy.
+   *  @param  __result An output iterator.
+   *  @return  result+n.
+   *
+   *  This inline function will boil down to a call to @c memmove whenever
+   *  possible.  Failing that, if random access iterators are passed, then the
+   *  loop count will be known (and therefore a candidate for compiler
+   *  optimizations such as unrolling).
+  */
+  template<Input_iterator _In, Integral _Size, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      inline _Out
+      copy_n(_In __first, _Size __n, _Out __result)
+      {
+        return std::__copy_n(__first, __n, __result,
+           std::__iterator_category(__first));
+      }
+
+  /**
+   *  @brief Copy the elements of a sequence to separate output sequences
+   *         depending on the truth value of a predicate.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __out_true   An output iterator.
+   *  @param  __out_false  An output iterator.
+   *  @param  __pred    A predicate.
+   *  @return   A pair designating the ends of the resulting sequences.
+   *
+   *  Copies each element in the range @p [__first,__last) for which
+   *  @p __pred returns true to the range beginning at @p out_true
+   *  and each element for which @p __pred returns false to @p __out_false.
+  */
+  template<Input_iterator _In, 
+          Advanceable _Out1, 
+          Advanceable _Out2,
+          Predicate<Value_type<_In>> _Predicate>
+    requires Indirectly_copyable<_In, _Out1>() && Indirectly_copyable<_In, _Out2>()
+      pair<_Out1, _Out2>
+      partition_copy(_In __first, _In __last,
+                     _Out1 __out_true, _Out2 __out_false,
+                     _Predicate __pred)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+        
+        for (; __first != __last; ++__first)
+          if (__pred(*__first))
+            {
+              *__out_true = *__first;
+              ++__out_true;
+            }
+          else
+            {
+              *__out_false = *__first;
+              ++__out_false;
+            }
+
+        return pair<_Out1, _Out2>(__out_true, __out_false);
+      }
+
+  /**
+   *  @brief Remove elements from a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __value  The value to be removed.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  All elements equal to @p __value are removed from the range
+   *  @p [__first,__last).
+   *
+   *  remove() is stable, so the relative order of elements that are
+   *  not removed is unchanged.
+   *
+   *  Elements between the end of the resulting sequence and @p __last
+   *  are still present, but their value is unspecified.
+  */
+  template<Forward_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    requires Permutable<_Iter>()
+      _Iter
+      remove(_Iter __first, _Iter __last, const _Tp& __value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        __first = _GLIBCXX_STD_A::find(__first, __last, __value);
+        if(__first == __last)
+          return __first;
+        _Iter __result = __first;
+        ++__first;
+        for(; __first != __last; ++__first)
+          if(!(*__first == __value))
+            {
+              *__result = _GLIBCXX_MOVE(*__first);
+              ++__result;
+            }
+        return __result;
+      }
+
+  /**
+   *  @brief Remove elements from a sequence using a predicate.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __last   A forward iterator.
+   *  @param  __pred   A predicate.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  All elements for which @p __pred returns true are removed from the range
+   *  @p [__first,__last).
+   *
+   *  remove_if() is stable, so the relative order of elements that are
+   *  not removed is unchanged.
+   *
+   *  Elements between the end of the resulting sequence and @p __last
+   *  are still present, but their value is unspecified.
+  */
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    requires Permutable<_Iter>()
+      _Iter
+      remove_if(_Iter __first, _Iter __last, _Predicate __pred)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        __first = _GLIBCXX_STD_A::find_if(__first, __last, __pred);
+        if(__first == __last)
+          return __first;
+        _Iter __result = __first;
+        ++__first;
+        for(; __first != __last; ++__first)
+          if(!bool(__pred(*__first)))
+            {
+              *__result = _GLIBCXX_MOVE(*__first);
+              ++__result;
+            }
+        return __result;
+      }
+
+  /**
+   *  @brief Remove consecutive duplicate values from a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __last   A forward iterator.
+   *  @return  An iterator designating the end of the resulting sequence.
+   *
+   *  Removes all but the first element from each group of consecutive
+   *  values that compare equal.
+   *  unique() is stable, so the relative order of elements that are
+   *  not removed is unchanged.
+   *  Elements between the end of the resulting sequence and @p __last
+   *  are still present, but their value is unspecified.
+  */
+  template<Forward_iterator _Iter>
+    requires Equality_comparable<Value_type<_Iter>>() && Permutable<_Iter>()
+      _Iter
+      unique(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        // Skip the beginning, if already unique.
+        __first = _GLIBCXX_STD_A::adjacent_find(__first, __last);
+        if (__first == __last)
+          return __last;
+
+        // Do the real copy work.
+        _Iter __dest = __first;
+        ++__first;
+        while (++__first != __last)
+          if (!(*__dest == *__first))
+            *++__dest = _GLIBCXX_MOVE(*__first);
+        return ++__dest;
+      }
+
+  /**
+   *  @brief Remove consecutive values from a sequence using a predicate.
+   *  @ingroup mutating_algorithms
+   *  @param  __first        A forward iterator.
+   *  @param  __last         A forward iterator.
+   *  @param  __binary_pred  A binary predicate.
+   *  @return  An iterator designating the end of the resulting sequence.
+   *
+   *  Removes all but the first element from each group of consecutive
+   *  values for which @p __binary_pred returns true.
+   *  unique() is stable, so the relative order of elements that are
+   *  not removed is unchanged.
+   *  Elements between the end of the resulting sequence and @p __last
+   *  are still present, but their value is unspecified.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    requires Permutable<_Iter>()
+      _Iter
+      unique(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        // Skip the beginning, if already unique.
+        __first = _GLIBCXX_STD_A::adjacent_find(__first, __last, __comp);
+        if (__first == __last)
+          return __last;
+
+        // Do the real copy work.
+        _Iter __dest = __first;
+        ++__first;
+        while (++__first != __last)
+          if (!bool(__comp(*__dest, *__first)))
+            *++__dest = _GLIBCXX_MOVE(*__first);
+        return ++__dest;
+      }
+
+  /**
+   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
+   *                                  _OutputIterator)
+   *  overloaded for forward iterators and output iterator as result.
+  */
+  template<typename _ForwardIterator, typename _OutputIterator>
+    _OutputIterator
+    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
+      _OutputIterator __result,
+      forward_iterator_tag, output_iterator_tag)
+    {
+      // concept requirements -- taken care of in dispatching function
+      _ForwardIterator __next = __first;
+      *__result = *__first;
+      while (++__next != __last)
+  if (!(*__first == *__next))
+    {
+      __first = __next;
+      *++__result = *__first;
+    }
+      return ++__result;
+    }
+
+  /**
+   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
+   *                                  _OutputIterator)
+   *  overloaded for input iterators and output iterator as result.
+  */
+  template<typename _InputIterator, typename _OutputIterator>
+    _OutputIterator
+    __unique_copy(_InputIterator __first, _InputIterator __last,
+      _OutputIterator __result,
+      input_iterator_tag, output_iterator_tag)
+    {
+      // concept requirements -- taken care of in dispatching function
+      typename iterator_traits<_InputIterator>::value_type __value = *__first;
+      *__result = __value;
+      while (++__first != __last)
+  if (!(__value == *__first))
+    {
+      __value = *__first;
+      *++__result = __value;
+    }
+      return ++__result;
+    }
+
+  /**
+   *  This is an uglified unique_copy(_InputIterator, _InputIterator,
+   *                                  _OutputIterator)
+   *  overloaded for input iterators and forward iterator as result.
+  */
+  template<typename _InputIterator, typename _ForwardIterator>
+    _ForwardIterator
+    __unique_copy(_InputIterator __first, _InputIterator __last,
+      _ForwardIterator __result,
+      input_iterator_tag, forward_iterator_tag)
+    {
+      // concept requirements -- taken care of in dispatching function
+      *__result = *__first;
+      while (++__first != __last)
+  if (!(*__result == *__first))
+    *++__result = *__first;
+      return ++__result;
+    }
+
+  /**
+   *  This is an uglified
+   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
+   *              _BinaryPredicate)
+   *  overloaded for forward iterators and output iterator as result.
+  */
+  template<typename _ForwardIterator, typename _OutputIterator,
+     typename _BinaryPredicate>
+    _OutputIterator
+    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
+      _OutputIterator __result, _BinaryPredicate __binary_pred,
+      forward_iterator_tag, output_iterator_tag)
+    {
+      // concept requirements -- iterators already checked
+      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
+    typename iterator_traits<_ForwardIterator>::value_type,
+    typename iterator_traits<_ForwardIterator>::value_type>)
+
+      _ForwardIterator __next = __first;
+      *__result = *__first;
+      while (++__next != __last)
+  if (!bool(__binary_pred(*__first, *__next)))
+    {
+      __first = __next;
+      *++__result = *__first;
+    }
+      return ++__result;
+    }
+
+  /**
+   *  This is an uglified
+   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
+   *              _BinaryPredicate)
+   *  overloaded for input iterators and output iterator as result.
+  */
+  template<typename _InputIterator, typename _OutputIterator,
+     typename _BinaryPredicate>
+    _OutputIterator
+    __unique_copy(_InputIterator __first, _InputIterator __last,
+      _OutputIterator __result, _BinaryPredicate __binary_pred,
+      input_iterator_tag, output_iterator_tag)
+    {
+      // concept requirements -- iterators already checked
+      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
+    typename iterator_traits<_InputIterator>::value_type,
+    typename iterator_traits<_InputIterator>::value_type>)
+
+      typename iterator_traits<_InputIterator>::value_type __value = *__first;
+      *__result = __value;
+      while (++__first != __last)
+  if (!bool(__binary_pred(__value, *__first)))
+    {
+      __value = *__first;
+      *++__result = __value;
+    }
+      return ++__result;
+    }
+
+  /**
+   *  This is an uglified
+   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,
+   *              _BinaryPredicate)
+   *  overloaded for input iterators and forward iterator as result.
+  */
+  template<typename _InputIterator, typename _ForwardIterator,
+     typename _BinaryPredicate>
+    _ForwardIterator
+    __unique_copy(_InputIterator __first, _InputIterator __last,
+      _ForwardIterator __result, _BinaryPredicate __binary_pred,
+      input_iterator_tag, forward_iterator_tag)
+    {
+      // concept requirements -- iterators already checked
+      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
+    typename iterator_traits<_ForwardIterator>::value_type,
+    typename iterator_traits<_InputIterator>::value_type>)
+
+      *__result = *__first;
+      while (++__first != __last)
+  if (!bool(__binary_pred(*__result, *__first)))
+    *++__result = *__first;
+      return ++__result;
+    }
+
+  /**
+   *  This is an uglified reverse(_BidirectionalIterator,
+   *                              _BidirectionalIterator)
+   *  overloaded for bidirectional iterators.
+  */
+  template<typename _BidirectionalIterator>
+    void
+    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
+        bidirectional_iterator_tag)
+    {
+      while (true)
+  if (__first == __last || __first == --__last)
+    return;
+  else
+    {
+      std::iter_swap(__first, __last);
+      ++__first;
+    }
+    }
+
+  /**
+   *  This is an uglified reverse(_BidirectionalIterator,
+   *                              _BidirectionalIterator)
+   *  overloaded for random access iterators.
+  */
+  template<typename _RandomAccessIterator>
+    void
+    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
+        random_access_iterator_tag)
+    {
+      if (__first == __last)
+  return;
+      --__last;
+      while (__first < __last)
+  {
+    std::iter_swap(__first, __last);
+    ++__first;
+    --__last;
+  }
+    }
+
+  /**
+   *  @brief Reverse a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A bidirectional iterator.
+   *  @param  __last   A bidirectional iterator.
+   *  @return   reverse() returns no value.
+   *
+   *  Reverses the order of the elements in the range @p [__first,__last),
+   *  so that the first element becomes the last etc.
+   *  For every @c i such that @p 0<=i<=(__last-__first)/2), @p reverse()
+   *  swaps @p *(__first+i) and @p *(__last-(i+1))
+  */
+  template<Bidirectional_iterator _Iter>
+    requires Permutable<_Iter>()
+      inline void
+      reverse(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        std::__reverse(__first, __last, std::__iterator_category(__first));
+      }
+
+  /**
+   *  @brief Copy a sequence, reversing its elements.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A bidirectional iterator.
+   *  @param  __last    A bidirectional iterator.
+   *  @param  __result  An output iterator.
+   *  @return  An iterator designating the end of the resulting sequence.
+   *
+   *  Copies the elements in the range @p [__first,__last) to the
+   *  range @p [__result,__result+(__last-__first)) such that the
+   *  order of the elements is reversed.  For every @c i such that @p
+   *  0<=i<=(__last-__first), @p reverse_copy() performs the
+   *  assignment @p *(__result+(__last-__first)-i) = *(__first+i).
+   *  The ranges @p [__first,__last) and @p
+   *  [__result,__result+(__last-__first)) must not overlap.
+  */
+  template<Bidirectional_iterator _In, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+    _Out
+      reverse_copy(_In __first, _In __last, _Out __result)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        while (__first != __last)
+          {
+            --__last;
+            *__result = *__last;
+            ++__result;
+          }
+        return __result;
+      }
+
+  /**
+   *  This is a helper function for the rotate algorithm specialized on RAIs.
+   *  It returns the greatest common divisor of two integer values.
+  */
+  template<typename _EuclideanRingElement>
+    _EuclideanRingElement
+    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
+    {
+      while (__n != 0)
+  {
+    _EuclideanRingElement __t = __m % __n;
+    __m = __n;
+    __n = __t;
+  }
+      return __m;
+    }
+
+  /// This is a helper function for the rotate algorithm.
+  template<typename _ForwardIterator>
+    void
+    __rotate(_ForwardIterator __first,
+       _ForwardIterator __middle,
+       _ForwardIterator __last,
+       forward_iterator_tag)
+    {
+      if (__first == __middle || __last  == __middle)
+  return;
+
+      _ForwardIterator __first2 = __middle;
+      do
+  {
+    std::iter_swap(__first, __first2);
+    ++__first;
+    ++__first2;
+    if (__first == __middle)
+      __middle = __first2;
+  }
+      while (__first2 != __last);
+
+      __first2 = __middle;
+
+      while (__first2 != __last)
+  {
+    std::iter_swap(__first, __first2);
+    ++__first;
+    ++__first2;
+    if (__first == __middle)
+      __middle = __first2;
+    else if (__first2 == __last)
+      __first2 = __middle;
+  }
+    }
+
+   /// This is a helper function for the rotate algorithm.
+  template<typename _BidirectionalIterator>
+    void
+    __rotate(_BidirectionalIterator __first,
+       _BidirectionalIterator __middle,
+       _BidirectionalIterator __last,
+        bidirectional_iterator_tag)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<
+          _BidirectionalIterator>)
+
+      if (__first == __middle || __last  == __middle)
+  return;
+
+      std::__reverse(__first,  __middle, bidirectional_iterator_tag());
+      std::__reverse(__middle, __last,   bidirectional_iterator_tag());
+
+      while (__first != __middle && __middle != __last)
+  {
+    std::iter_swap(__first, --__last);
+    ++__first;
+  }
+
+      if (__first == __middle)
+  std::__reverse(__middle, __last,   bidirectional_iterator_tag());
+      else
+  std::__reverse(__first,  __middle, bidirectional_iterator_tag());
+    }
+
+  /// This is a helper function for the rotate algorithm.
+  template<typename _RandomAccessIterator>
+    void
+    __rotate(_RandomAccessIterator __first,
+       _RandomAccessIterator __middle,
+       _RandomAccessIterator __last,
+       random_access_iterator_tag)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
+          _RandomAccessIterator>)
+
+      if (__first == __middle || __last  == __middle)
+  return;
+
+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
+  _Distance;
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+
+      _Distance __n = __last   - __first;
+      _Distance __k = __middle - __first;
+
+      if (__k == __n - __k)
+  {
+    std::swap_ranges(__first, __middle, __middle);
+    return;
+  }
+
+      _RandomAccessIterator __p = __first;
+
+      for (;;)
+  {
+    if (__k < __n - __k)
+      {
+        if (__is_pod(_ValueType) && __k == 1)
+    {
+      _ValueType __t = _GLIBCXX_MOVE(*__p);
+      _GLIBCXX_MOVE3(__p + 1, __p + __n, __p);
+      *(__p + __n - 1) = _GLIBCXX_MOVE(__t);
+      return;
+    }
+        _RandomAccessIterator __q = __p + __k;
+        for (_Distance __i = 0; __i < __n - __k; ++ __i)
+    {
+      std::iter_swap(__p, __q);
+      ++__p;
+      ++__q;
+    }
+        __n %= __k;
+        if (__n == 0)
+    return;
+        std::swap(__n, __k);
+        __k = __n - __k;
+      }
+    else
+      {
+        __k = __n - __k;
+        if (__is_pod(_ValueType) && __k == 1)
+    {
+      _ValueType __t = _GLIBCXX_MOVE(*(__p + __n - 1));
+      _GLIBCXX_MOVE_BACKWARD3(__p, __p + __n - 1, __p + __n);
+      *__p = _GLIBCXX_MOVE(__t);
+      return;
+    }
+        _RandomAccessIterator __q = __p + __n;
+        __p = __q - __k;
+        for (_Distance __i = 0; __i < __n - __k; ++ __i)
+    {
+      --__p;
+      --__q;
+      std::iter_swap(__p, __q);
+    }
+        __n %= __k;
+        if (__n == 0)
+    return;
+        std::swap(__n, __k);
+      }
+  }
+    }
+
+  /**
+   *  @brief Rotate the elements of a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __middle  A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @return  Nothing.
+   *
+   *  Rotates the elements of the range @p [__first,__last) by 
+   *  @p (__middle - __first) positions so that the element at @p __middle
+   *  is moved to @p __first, the element at @p __middle+1 is moved to
+   *  @p __first+1 and so on for each element in the range
+   *  @p [__first,__last).
+   *
+   *  This effectively swaps the ranges @p [__first,__middle) and
+   *  @p [__middle,__last).
+   *
+   *  Performs
+   *   @p *(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n)
+   *  for each @p n in the range @p [0,__last-__first).
+  */
+  template<Forward_iterator _Iter>
+    requires Permutable<_Iter>()
+    inline void
+    rotate(_Iter __first, _Iter __middle, _Iter __last)
+    {
+      __glibcxx_requires_valid_range(__first, __middle);
+      __glibcxx_requires_valid_range(__middle, __last);
+
+      using _IterType = Iterator_category<_Iter>;
+      std::__rotate(__first, __middle, __last, _IterType());
+    }
+
+  /**
+   *  @brief Copy a sequence, rotating its elements.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __middle  A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @param  __result  An output iterator.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  Copies the elements of the range @p [__first,__last) to the
+   *  range beginning at @result, rotating the copied elements by 
+   *  @p (__middle-__first) positions so that the element at @p __middle
+   *  is moved to @p __result, the element at @p __middle+1 is moved
+   *  to @p __result+1 and so on for each element in the range @p
+   *  [__first,__last).
+   *
+   *  Performs 
+   *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
+   *  for each @p n in the range @p [0,__last-__first).
+  */
+  template<Forward_iterator _In, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out
+      rotate_copy(_In __first, _In __middle, _In __last, _Out __result)
+      {
+        __glibcxx_requires_valid_range(__first, __middle);
+        __glibcxx_requires_valid_range(__middle, __last);
+
+        return std::copy(__first, __middle, std::copy(__middle, __last, __result));
+      }
+
+  /// This is a helper function...
+  template<typename _ForwardIterator, typename _Predicate>
+    _ForwardIterator
+    __partition(_ForwardIterator __first, _ForwardIterator __last,
+    _Predicate __pred, forward_iterator_tag)
+    {
+      if (__first == __last)
+  return __first;
+
+      while (__pred(*__first))
+  if (++__first == __last)
+    return __first;
+
+      _ForwardIterator __next = __first;
+
+      while (++__next != __last)
+  if (__pred(*__next))
+    {
+      std::iter_swap(__first, __next);
+      ++__first;
+    }
+
+      return __first;
+    }
+
+  /// This is a helper function...
+  template<typename _BidirectionalIterator, typename _Predicate>
+    _BidirectionalIterator
+    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
+    _Predicate __pred, bidirectional_iterator_tag)
+    {
+      while (true)
+  {
+    while (true)
+      if (__first == __last)
+        return __first;
+      else if (__pred(*__first))
+        ++__first;
+      else
+        break;
+    --__last;
+    while (true)
+      if (__first == __last)
+        return __first;
+      else if (!bool(__pred(*__last)))
+        --__last;
+      else
+        break;
+    std::iter_swap(__first, __last);
+    ++__first;
+  }
+    }
+
+  // partition
+
+  /// This is a helper function...
+  /// Requires __len != 0 and !__pred(*__first),
+  /// same as __stable_partition_adaptive.
+  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
+    _ForwardIterator
+    __inplace_stable_partition(_ForwardIterator __first,
+             _Predicate __pred, _Distance __len)
+    {
+      if (__len == 1)
+  return __first;
+      _ForwardIterator __middle = __first;
+      std::advance(__middle, __len / 2);
+      _ForwardIterator __left_split =
+  std::__inplace_stable_partition(__first, __pred, __len / 2);
+      // Advance past true-predicate values to satisfy this
+      // function's preconditions.
+      _Distance __right_len = __len - __len / 2;
+      _ForwardIterator __right_split =
+  std::__find_if_not_n(__middle, __right_len, __pred);
+      if (__right_len)
+  __right_split = std::__inplace_stable_partition(__middle,
+              __pred,
+              __right_len);
+      std::rotate(__left_split, __middle, __right_split);
+      std::advance(__left_split, std::distance(__middle, __right_split));
+      return __left_split;
+    }
+
+  /// This is a helper function...
+  /// Requires __first != __last and !__pred(*__first)
+  /// and __len == distance(__first, __last).
+  ///
+  /// !__pred(*__first) allows us to guarantee that we don't
+  /// move-assign an element onto itself.
+  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
+     typename _Distance>
+    _ForwardIterator
+    __stable_partition_adaptive(_ForwardIterator __first,
+        _ForwardIterator __last,
+        _Predicate __pred, _Distance __len,
+        _Pointer __buffer,
+        _Distance __buffer_size)
+    {
+      if (__len <= __buffer_size)
+  {
+    _ForwardIterator __result1 = __first;
+    _Pointer __result2 = __buffer;
+    // The precondition guarantees that !__pred(*__first), so
+    // move that element to the buffer before starting the loop.
+    // This ensures that we only call __pred once per element.
+    *__result2 = _GLIBCXX_MOVE(*__first);
+    ++__result2;
+    ++__first;
+    for (; __first != __last; ++__first)
+      if (__pred(*__first))
+        {
+    *__result1 = _GLIBCXX_MOVE(*__first);
+    ++__result1;
+        }
+      else
+        {
+    *__result2 = _GLIBCXX_MOVE(*__first);
+    ++__result2;
+        }
+    _GLIBCXX_MOVE3(__buffer, __result2, __result1);
+    return __result1;
+  }
+      else
+  {
+    _ForwardIterator __middle = __first;
+    std::advance(__middle, __len / 2);
+    _ForwardIterator __left_split =
+      std::__stable_partition_adaptive(__first, __middle, __pred,
+               __len / 2, __buffer,
+               __buffer_size);
+    // Advance past true-predicate values to satisfy this
+    // function's preconditions.
+    _Distance __right_len = __len - __len / 2;
+    _ForwardIterator __right_split =
+      std::__find_if_not_n(__middle, __right_len, __pred);
+    if (__right_len)
+      __right_split =
+        std::__stable_partition_adaptive(__right_split, __last, __pred,
+                 __right_len,
+                 __buffer, __buffer_size);
+    std::rotate(__left_split, __middle, __right_split);
+    std::advance(__left_split, std::distance(__middle, __right_split));
+    return __left_split;
+  }
+    }
+
+  /**
+   *  @brief Move elements for which a predicate is true to the beginning
+   *         of a sequence, preserving relative ordering.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @param  __pred    A predicate functor.
+   *  @return  An iterator @p middle such that @p __pred(i) is true for each
+   *  iterator @p i in the range @p [first,middle) and false for each @p i
+   *  in the range @p [middle,last).
+   *
+   *  Performs the same function as @p partition() with the additional
+   *  guarantee that the relative ordering of elements in each group is
+   *  preserved, so any two elements @p x and @p y in the range
+   *  @p [__first,__last) such that @p __pred(x)==__pred(y) will have the same
+   *  relative ordering after calling @p stable_partition().
+  */
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    requires Permutable<_Iter>()
+      _Iter
+      stable_partition(_Iter __first, _Iter __last, _Predicate __pred)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        __first = std::__find_if_not(__first, __last, __pred);
+
+        if (__first == __last)
+          return __first;
+        else
+          {
+            typedef Value_type<_Iter> _ValueType;
+            typedef Difference_type<_Iter> _DistanceType;
+
+            _Temporary_buffer<_Iter, _ValueType> __buf(__first, __last);
+          if (__buf.size() > 0)
+            return
+              std::__stable_partition_adaptive(__first, __last, __pred,
+                    _DistanceType(__buf.requested_size()),
+                    __buf.begin(),
+                    _DistanceType(__buf.size()));
+          else
+            return
+              std::__inplace_stable_partition(__first, __pred,
+                   _DistanceType(__buf.requested_size()));
+          }
+      }
+
+  /// This is a helper function for the sort routines.
+  template<typename _RandomAccessIterator>
+    void
+    __heap_select(_RandomAccessIterator __first,
+      _RandomAccessIterator __middle,
+      _RandomAccessIterator __last)
+    {
+      std::make_heap(__first, __middle);
+      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
+  if (*__i < *__first)
+    std::__pop_heap(__first, __middle, __i);
+    }
+
+  /// This is a helper function for the sort routines.
+  template<typename _RandomAccessIterator, typename _Compare>
+    void
+    __heap_select(_RandomAccessIterator __first,
+      _RandomAccessIterator __middle,
+      _RandomAccessIterator __last, _Compare __comp)
+    {
+      std::make_heap(__first, __middle, __comp);
+      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
+  if (__comp(*__i, *__first))
+    std::__pop_heap(__first, __middle, __i, __comp);
+    }
+
+  // partial_sort
+
+  /**
+   *  @brief Copy the smallest elements of a sequence.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __result_first   A random-access iterator.
+   *  @param  __result_last    Another random-access iterator.
+   *  @return   An iterator indicating the end of the resulting sequence.
+   *
+   *  Copies and sorts the smallest N values from the range @p [__first,__last)
+   *  to the range beginning at @p __result_first, where the number of
+   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
+   *  @p (__result_last-__result_first).
+   *  After the sort if @e i and @e j are iterators in the range
+   *  @p [__result_first,__result_first+N) such that i precedes j then
+   *  *j<*i is false.
+   *  The value returned is @p __result_first+N.
+  */
+  template<Input_iterator _In, Random_access_iterator _Out>
+    requires Indirectly_copyable<_In, _Out>()
+          && Indirectly_ordered<_In, _Out>()
+          && Sortable<_Out>()
+      _Out
+      partial_sort_copy(_In __first, _In __last,
+                        _Out __result_first, _Out __result_last)
+      {
+        using _DistanceType = Difference_type<_In>;
+        using _InputValueType = Value_type<_In>;
+
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_valid_range(__result_first, __result_last);
+
+        if (__result_first == __result_last)
+          return __result_last;
+        _Out __result_real_last = __result_first;
+        while(__first != __last && __result_real_last != __result_last)
+          {
+            *__result_real_last = *__first;
+            ++__result_real_last;
+            ++__first;
+          }
+        std::make_heap(__result_first, __result_real_last);
+        while (__first != __last)
+          {
+            // FIXME: There's a copy here that doesn't seem to be refelected
+            // in the requiremetns. Is it?
+            if (*__first < *__result_first)
+              std::__adjust_heap(__result_first, _DistanceType(0),
+                     _DistanceType(__result_real_last - __result_first),
+                     _InputValueType(*__first));
+            ++__first;
+          }
+        std::sort_heap(__result_first, __result_real_last);
+        return __result_real_last;
+      }
+
+  /**
+   *  @brief Copy the smallest elements of a sequence using a predicate for
+   *         comparison.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    Another input iterator.
+   *  @param  __result_first   A random-access iterator.
+   *  @param  __result_last    Another random-access iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return   An iterator indicating the end of the resulting sequence.
+   *
+   *  Copies and sorts the smallest N values from the range @p [__first,__last)
+   *  to the range beginning at @p result_first, where the number of
+   *  elements to be copied, @p N, is the smaller of @p (__last-__first) and
+   *  @p (__result_last-__result_first).
+   *  After the sort if @e i and @e j are iterators in the range
+   *  @p [__result_first,__result_first+N) such that i precedes j then
+   *  @p __comp(*j,*i) is false.
+   *  The value returned is @p __result_first+N.
+  */
+  template<Input_iterator _In, Random_access_iterator _Out, typename _Compare>
+    requires Indirectly_copyable<_In, _Out>()
+          && Indirectly_comparable<_In, _Out, _Compare>()
+          && Sortable<_Out, _Compare>()
+      _Out
+      partial_sort_copy(_In __first, _In __last,
+                        _Out __result_first, _Out __result_last,
+                        _Compare __comp)
+      {
+        using _DistanceType = Difference_type<_In>;
+        using _InputValueType = Value_type<_In>;
+
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_valid_range(__result_first, __result_last);
+
+        if (__result_first == __result_last)
+          return __result_last;
+        _Out __result_real_last = __result_first;
+        while(__first != __last && __result_real_last != __result_last)
+          {
+            *__result_real_last = *__first;
+            ++__result_real_last;
+            ++__first;
+          }
+        std::make_heap(__result_first, __result_real_last, __comp);
+        while (__first != __last)
+          {
+                  // FIXME: There's a copy here that doesn't seem to be refelected
+                  // in the requiremetns. Is it?
+            if (__comp(*__first, *__result_first))
+              std::__adjust_heap(__result_first, _DistanceType(0),
+                     _DistanceType(__result_real_last - __result_first),
+                     _InputValueType(*__first),
+                     __comp);
+            ++__first;
+          }
+        std::sort_heap(__result_first, __result_real_last, __comp);
+        return __result_real_last;
+      }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator>
+    void
+    __unguarded_linear_insert(_RandomAccessIterator __last)
+    {
+      typename iterator_traits<_RandomAccessIterator>::value_type
+  __val = _GLIBCXX_MOVE(*__last);
+      _RandomAccessIterator __next = __last;
+      --__next;
+      while (__val < *__next)
+  {
+    *__last = _GLIBCXX_MOVE(*__next);
+    __last = __next;
+    --__next;
+  }
+      *__last = _GLIBCXX_MOVE(__val);
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator, typename _Compare>
+    void
+    __unguarded_linear_insert(_RandomAccessIterator __last,
+            _Compare __comp)
+    {
+      typename iterator_traits<_RandomAccessIterator>::value_type
+  __val = _GLIBCXX_MOVE(*__last);
+      _RandomAccessIterator __next = __last;
+      --__next;
+      while (__comp(__val, *__next))
+  {
+    *__last = _GLIBCXX_MOVE(*__next);
+    __last = __next;
+    --__next;
+  }
+      *__last = _GLIBCXX_MOVE(__val);
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator>
+    void
+    __insertion_sort(_RandomAccessIterator __first,
+         _RandomAccessIterator __last)
+    {
+      if (__first == __last)
+  return;
+
+      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
+  {
+    if (*__i < *__first)
+      {
+        typename iterator_traits<_RandomAccessIterator>::value_type
+    __val = _GLIBCXX_MOVE(*__i);
+        _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
+        *__first = _GLIBCXX_MOVE(__val);
+      }
+    else
+      std::__unguarded_linear_insert(__i);
+  }
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator, typename _Compare>
+    void
+    __insertion_sort(_RandomAccessIterator __first,
+         _RandomAccessIterator __last, _Compare __comp)
+    {
+      if (__first == __last) return;
+
+      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
+  {
+    if (__comp(*__i, *__first))
+      {
+        typename iterator_traits<_RandomAccessIterator>::value_type
+    __val = _GLIBCXX_MOVE(*__i);
+        _GLIBCXX_MOVE_BACKWARD3(__first, __i, __i + 1);
+        *__first = _GLIBCXX_MOVE(__val);
+      }
+    else
+      std::__unguarded_linear_insert(__i, __comp);
+  }
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator>
+    inline void
+    __unguarded_insertion_sort(_RandomAccessIterator __first,
+             _RandomAccessIterator __last)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+
+      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
+  std::__unguarded_linear_insert(__i);
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator, typename _Compare>
+    inline void
+    __unguarded_insertion_sort(_RandomAccessIterator __first,
+             _RandomAccessIterator __last, _Compare __comp)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+
+      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
+  std::__unguarded_linear_insert(__i, __comp);
+    }
+
+  /**
+   *  @doctodo
+   *  This controls some aspect of the sort routines.
+  */
+  enum { _S_threshold = 16 };
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator>
+    void
+    __final_insertion_sort(_RandomAccessIterator __first,
+         _RandomAccessIterator __last)
+    {
+      if (__last - __first > int(_S_threshold))
+  {
+    std::__insertion_sort(__first, __first + int(_S_threshold));
+    std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
+  }
+      else
+  std::__insertion_sort(__first, __last);
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator, typename _Compare>
+    void
+    __final_insertion_sort(_RandomAccessIterator __first,
+         _RandomAccessIterator __last, _Compare __comp)
+    {
+      if (__last - __first > int(_S_threshold))
+  {
+    std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
+    std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
+            __comp);
+  }
+      else
+  std::__insertion_sort(__first, __last, __comp);
+    }
+
+  /// This is a helper function...
+  template<typename _RandomAccessIterator, typename _Tp>
+    _RandomAccessIterator
+    __unguarded_partition(_RandomAccessIterator __first,
+        _RandomAccessIterator __last, const _Tp& __pivot)
+    {
+      while (true)
+  {
+    while (*__first < __pivot)
+      ++__first;
+    --__last;
+    while (__pivot < *__last)
+      --__last;
+    if (!(__first < __last))
+      return __first;
+    std::iter_swap(__first, __last);
+    ++__first;
+  }
+    }
+
+  /// This is a helper function...
+  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
+    _RandomAccessIterator
+    __unguarded_partition(_RandomAccessIterator __first,
+        _RandomAccessIterator __last,
+        const _Tp& __pivot, _Compare __comp)
+    {
+      while (true)
+  {
+    while (__comp(*__first, __pivot))
+      ++__first;
+    --__last;
+    while (__comp(__pivot, *__last))
+      --__last;
+    if (!(__first < __last))
+      return __first;
+    std::iter_swap(__first, __last);
+    ++__first;
+  }
+    }
+
+  /// This is a helper function...
+  template<typename _RandomAccessIterator>
+    inline _RandomAccessIterator
+    __unguarded_partition_pivot(_RandomAccessIterator __first,
+        _RandomAccessIterator __last)
+    {
+      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
+      std::__move_median_first(__first, __mid, (__last - 1));
+      return std::__unguarded_partition(__first + 1, __last, *__first);
+    }
+
+
+  /// This is a helper function...
+  template<typename _RandomAccessIterator, typename _Compare>
+    inline _RandomAccessIterator
+    __unguarded_partition_pivot(_RandomAccessIterator __first,
+        _RandomAccessIterator __last, _Compare __comp)
+    {
+      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
+      std::__move_median_first(__first, __mid, (__last - 1), __comp);
+      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator, typename _Size>
+    void
+    __introsort_loop(_RandomAccessIterator __first,
+         _RandomAccessIterator __last,
+         _Size __depth_limit)
+    {
+      while (__last - __first > int(_S_threshold))
+  {
+    if (__depth_limit == 0)
+      {
+        _GLIBCXX_STD_A::partial_sort(__first, __last, __last);
+        return;
+      }
+    --__depth_limit;
+    _RandomAccessIterator __cut =
+      std::__unguarded_partition_pivot(__first, __last);
+    std::__introsort_loop(__cut, __last, __depth_limit);
+    __last = __cut;
+  }
+    }
+
+  /// This is a helper function for the sort routine.
+  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
+    void
+    __introsort_loop(_RandomAccessIterator __first,
+         _RandomAccessIterator __last,
+         _Size __depth_limit, _Compare __comp)
+    {
+      while (__last - __first > int(_S_threshold))
+  {
+    if (__depth_limit == 0)
+      {
+        _GLIBCXX_STD_A::partial_sort(__first, __last, __last, __comp);
+        return;
+      }
+    --__depth_limit;
+    _RandomAccessIterator __cut =
+      std::__unguarded_partition_pivot(__first, __last, __comp);
+    std::__introsort_loop(__cut, __last, __depth_limit, __comp);
+    __last = __cut;
+  }
+    }
+
+  // sort
+
+  template<typename _RandomAccessIterator, typename _Size>
+    void
+    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
+      _RandomAccessIterator __last, _Size __depth_limit)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+
+      while (__last - __first > 3)
+  {
+    if (__depth_limit == 0)
+      {
+        std::__heap_select(__first, __nth + 1, __last);
+
+        // Place the nth largest element in its final position.
+        std::iter_swap(__first, __nth);
+        return;
+      }
+    --__depth_limit;
+    _RandomAccessIterator __cut =
+      std::__unguarded_partition_pivot(__first, __last);
+    if (__cut <= __nth)
+      __first = __cut;
+    else
+      __last = __cut;
+  }
+      std::__insertion_sort(__first, __last);
+    }
+
+  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
+    void
+    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
+      _RandomAccessIterator __last, _Size __depth_limit,
+      _Compare __comp)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+
+      while (__last - __first > 3)
+  {
+    if (__depth_limit == 0)
+      {
+        std::__heap_select(__first, __nth + 1, __last, __comp);
+        // Place the nth largest element in its final position.
+        std::iter_swap(__first, __nth);
+        return;
+      }
+    --__depth_limit;
+    _RandomAccessIterator __cut =
+      std::__unguarded_partition_pivot(__first, __last, __comp);
+    if (__cut <= __nth)
+      __first = __cut;
+    else
+      __last = __cut;
+  }
+      std::__insertion_sort(__first, __last, __comp);
+    }
+
+  // nth_element
+
+  // lower_bound moved to stl_algobase.h
+
+  /**
+   *  @brief Finds the first position in which @p __val could be inserted
+   *         without changing the ordering.
+   *  @ingroup binary_search_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @param  __comp    A functor to use for comparisons.
+   *  @return An iterator pointing to the first element <em>not less
+   *           than</em> @p __val, or end() if every element is less
+   *           than @p __val.
+   *  @ingroup binary_search_algorithms
+   *
+   *  The comparison function should have the same effects on ordering as
+   *  the function used for the initial sort.
+  */
+  template<Forward_iterator _Iter, 
+           typename _Tp, 
+           Relation<Value_type<_Iter>, _Tp> _Compare>
+    _Iter
+    lower_bound(_Iter __first, _Iter __last, const _Tp& __val, _Compare __comp)
+    {
+      typedef Difference_type<_Iter> _DistanceType;
+
+      __glibcxx_requires_partitioned_lower_pred(__first, __last, __val, __comp);
+
+      _DistanceType __len = std::distance(__first, __last);
+      while (__len > 0)
+        {
+          _DistanceType __half = __len >> 1;
+          _Iter __middle = __first;
+          std::advance(__middle, __half);
+          if (__comp(*__middle, __val))
+            {
+              __first = __middle;
+              ++__first;
+              __len = __len - __half - 1;
+            }
+          else
+            __len = __half;
+        }
+      return __first;
+    }
+
+  /**
+   *  @brief Finds the last position in which @p __val could be inserted
+   *         without changing the ordering.
+   *  @ingroup binary_search_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @return  An iterator pointing to the first element greater than @p __val,
+   *           or end() if no elements are greater than @p __val.
+   *  @ingroup binary_search_algorithms
+  */
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    _Iter
+    upper_bound(_Iter __first, _Iter __last,
+    const _Tp& __val)
+    {
+      typedef Difference_type<_Iter>_DistanceType;
+
+      __glibcxx_requires_partitioned_upper(__first, __last, __val);
+
+      _DistanceType __len = std::distance(__first, __last);
+      while (__len > 0)
+        {
+          _DistanceType __half = __len >> 1;
+          _Iter __middle = __first;
+          std::advance(__middle, __half);
+          if (__val < *__middle)
+            __len = __half;
+          else
+            {
+              __first = __middle;
+              ++__first;
+              __len = __len - __half - 1;
+            }
+        }
+      return __first;
+    }
+
+  /**
+   *  @brief Finds the last position in which @p __val could be inserted
+   *         without changing the ordering.
+   *  @ingroup binary_search_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @param  __comp    A functor to use for comparisons.
+   *  @return  An iterator pointing to the first element greater than @p __val,
+   *           or end() if no elements are greater than @p __val.
+   *  @ingroup binary_search_algorithms
+   *
+   *  The comparison function should have the same effects on ordering as
+   *  the function used for the initial sort.
+  */
+  template<Forward_iterator _Iter, typename _Tp, Relation<Value_type<_Iter>, _Tp> _Compare>
+    _Iter
+    upper_bound(_Iter __first, _Iter __last, const _Tp& __val, _Compare __comp)
+    {
+      typedef Difference_type<_Iter> _DistanceType;
+
+      __glibcxx_requires_partitioned_upper_pred(__first, __last, __val, __comp);
+
+      _DistanceType __len = std::distance(__first, __last);
+      while (__len > 0)
+        {
+          _DistanceType __half = __len >> 1;
+          _Iter __middle = __first;
+          std::advance(__middle, __half);
+          if (__comp(__val, *__middle))
+            __len = __half;
+          else
+            {
+              __first = __middle;
+              ++__first;
+              __len = __len - __half - 1;
+            }
+        }
+      return __first;
+    }
+
+  /**
+   *  @brief Finds the largest subrange in which @p __val could be inserted
+   *         at any place in it without changing the ordering.
+   *  @ingroup binary_search_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @return  An pair of iterators defining the subrange.
+   *  @ingroup binary_search_algorithms
+   *
+   *  This is equivalent to
+   *  @code
+   *    std::make_pair(lower_bound(__first, __last, __val),
+   *                   upper_bound(__first, __last, __val))
+   *  @endcode
+   *  but does not actually call those functions.
+  */
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    pair<_Iter, _Iter>
+    equal_range(_Iter __first, _Iter __last, const _Tp& __val)
+    {
+      typedef Difference_type<_Iter> _DistanceType;
+
+      __glibcxx_requires_partitioned_lower(__first, __last, __val);
+      __glibcxx_requires_partitioned_upper(__first, __last, __val);      
+
+      _DistanceType __len = std::distance(__first, __last);
+ 
+      while (__len > 0)
+  {
+    _DistanceType __half = __len >> 1;
+    _Iter __middle = __first;
+    std::advance(__middle, __half);
+    if (*__middle < __val)
+      {
+        __first = __middle;
+        ++__first;
+        __len = __len - __half - 1;
+      }
+    else if (__val < *__middle)
+      __len = __half;
+    else
+      {
+        _Iter __left = std::lower_bound(__first, __middle,
+               __val);
+        std::advance(__first, __len);
+        _Iter __right = std::upper_bound(++__middle, __first,
+                __val);
+        return pair<_Iter, _Iter>(__left, __right);
+      }
+  }
+      return pair<_Iter, _Iter>(__first, __first);
+    }
+
+  /**
+   *  @brief Finds the largest subrange in which @p __val could be inserted
+   *         at any place in it without changing the ordering.
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @param  __comp    A functor to use for comparisons.
+   *  @return  An pair of iterators defining the subrange.
+   *  @ingroup binary_search_algorithms
+   *
+   *  This is equivalent to
+   *  @code
+   *    std::make_pair(lower_bound(__first, __last, __val, __comp),
+   *                   upper_bound(__first, __last, __val, __comp))
+   *  @endcode
+   *  but does not actually call those functions.
+  */
+  template<Forward_iterator _Iter, typename _Tp, Relation<Value_type<_Iter>, _Tp> _Compare>
+    pair<_Iter, _Iter>
+    equal_range(_Iter __first, _Iter __last, const _Tp& __val, _Compare __comp)
+    {
+      typedef Difference_type<_Iter> _DistanceType;
+
+      __glibcxx_requires_partitioned_lower_pred(__first, __last, __val, __comp);
+      __glibcxx_requires_partitioned_upper_pred(__first, __last, __val, __comp);
+
+      _DistanceType __len = std::distance(__first, __last);
+
+      while (__len > 0)
+  {
+    _DistanceType __half = __len >> 1;
+    _Iter __middle = __first;
+    std::advance(__middle, __half);
+    if (__comp(*__middle, __val))
+      {
+        __first = __middle;
+        ++__first;
+        __len = __len - __half - 1;
+      }
+    else if (__comp(__val, *__middle))
+      __len = __half;
+    else
+      {
+        _Iter __left = std::lower_bound(__first, __middle, __val, __comp);
+        std::advance(__first, __len);
+        _Iter __right = std::upper_bound(++__middle, __first, __val, __comp);
+        return pair<_Iter, _Iter>(__left, __right);
+      }
+  }
+      return pair<_Iter, _Iter>(__first, __first);
+    }
+
+  /**
+   *  @brief Determines whether an element exists in a range.
+   *  @ingroup binary_search_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @return True if @p __val (or its equivalent) is in [@p
+   *  __first,@p __last ].
+   *
+   *  Note that this does not actually return an iterator to @p __val.  For
+   *  that, use std::find or a container's specialized find member functions.
+  */
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    bool
+    binary_search(_Iter __first, _Iter __last, const _Tp& __val)
+    {
+      __glibcxx_requires_partitioned_lower(__first, __last, __val);
+      __glibcxx_requires_partitioned_upper(__first, __last, __val);
+
+      _Iter __i = std::lower_bound(__first, __last, __val);
+      return __i != __last && !(__val < *__i);
+    }
+
+  /**
+   *  @brief Determines whether an element exists in a range.
+   *  @ingroup binary_search_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @param  __comp    A functor to use for comparisons.
+   *  @return  True if @p __val (or its equivalent) is in @p [__first,__last].
+   *
+   *  Note that this does not actually return an iterator to @p __val.  For
+   *  that, use std::find or a container's specialized find member functions.
+   *
+   *  The comparison function should have the same effects on ordering as
+   *  the function used for the initial sort.
+  */
+  template<Forward_iterator _Iter, typename _Tp, 
+           Relation<Value_type<_Iter>, _Tp> _Compare>
+    bool
+    binary_search(_Iter __first, _Iter __last, const _Tp& __val, _Compare __comp)
+    {
+      __glibcxx_requires_partitioned_lower_pred(__first, __last, __val, __comp);
+      __glibcxx_requires_partitioned_upper_pred(__first, __last, __val, __comp);
+
+      _Iter __i = std::lower_bound(__first, __last, __val, __comp);
+      return __i != __last && !bool(__comp(__val, *__i));
+    }
+
+  // merge
+
+  /// This is a helper function for the __merge_adaptive routines.
+  template<typename _InputIterator1, typename _InputIterator2,
+     typename _OutputIterator>
+    void
+    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
+        _InputIterator2 __first2, _InputIterator2 __last2,
+        _OutputIterator __result)
+    {
+      while (__first1 != __last1 && __first2 != __last2)
+  {
+    if (*__first2 < *__first1)
+      {
+        *__result = _GLIBCXX_MOVE(*__first2);
+        ++__first2;
+      }
+    else
+      {
+        *__result = _GLIBCXX_MOVE(*__first1);
+        ++__first1;
+      }
+    ++__result;
+  }
+      if (__first1 != __last1)
+  _GLIBCXX_MOVE3(__first1, __last1, __result);
+    }
+
+  /// This is a helper function for the __merge_adaptive routines.
+  template<typename _InputIterator1, typename _InputIterator2,
+     typename _OutputIterator, typename _Compare>
+    void
+    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
+        _InputIterator2 __first2, _InputIterator2 __last2,
+        _OutputIterator __result, _Compare __comp)
+    {
+      while (__first1 != __last1 && __first2 != __last2)
+  {
+    if (__comp(*__first2, *__first1))
+      {
+        *__result = _GLIBCXX_MOVE(*__first2);
+        ++__first2;
+      }
+    else
+      {
+        *__result = _GLIBCXX_MOVE(*__first1);
+        ++__first1;
+      }
+    ++__result;
+  }
+      if (__first1 != __last1)
+  _GLIBCXX_MOVE3(__first1, __last1, __result);
+    }
+
+  /// This is a helper function for the __merge_adaptive routines.
+  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
+     typename _BidirectionalIterator3>
+    void
+    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
+           _BidirectionalIterator1 __last1,
+           _BidirectionalIterator2 __first2,
+           _BidirectionalIterator2 __last2,
+           _BidirectionalIterator3 __result)
+    {
+      if (__first1 == __last1)
+  {
+    _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
+    return;
+  }
+      else if (__first2 == __last2)
+  return;
+
+      --__last1;
+      --__last2;
+      while (true)
+  {
+    if (*__last2 < *__last1)
+      {
+        *--__result = _GLIBCXX_MOVE(*__last1);
+        if (__first1 == __last1)
+    {
+      _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
+      return;
+    }
+        --__last1;
+      }
+    else
+      {
+        *--__result = _GLIBCXX_MOVE(*__last2);
+        if (__first2 == __last2)
+    return;
+        --__last2;
+      }
+  }
+    }
+
+  /// This is a helper function for the __merge_adaptive routines.
+  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
+     typename _BidirectionalIterator3, typename _Compare>
+    void
+    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
+           _BidirectionalIterator1 __last1,
+           _BidirectionalIterator2 __first2,
+           _BidirectionalIterator2 __last2,
+           _BidirectionalIterator3 __result,
+           _Compare __comp)
+    {
+      if (__first1 == __last1)
+  {
+    _GLIBCXX_MOVE_BACKWARD3(__first2, __last2, __result);
+    return;
+  }
+      else if (__first2 == __last2)
+  return;
+
+      --__last1;
+      --__last2;
+      while (true)
+  {
+    if (__comp(*__last2, *__last1))
+      {
+        *--__result = _GLIBCXX_MOVE(*__last1);
+        if (__first1 == __last1)
+    {
+      _GLIBCXX_MOVE_BACKWARD3(__first2, ++__last2, __result);
+      return;
+    }
+        --__last1;
+      }
+    else
+      {
+        *--__result = _GLIBCXX_MOVE(*__last2);
+        if (__first2 == __last2)
+    return;
+        --__last2;
+      }
+  }
+    }
+
+  /// This is a helper function for the merge routines.
+  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
+     typename _Distance>
+    _BidirectionalIterator1
+    __rotate_adaptive(_BidirectionalIterator1 __first,
+          _BidirectionalIterator1 __middle,
+          _BidirectionalIterator1 __last,
+          _Distance __len1, _Distance __len2,
+          _BidirectionalIterator2 __buffer,
+          _Distance __buffer_size)
+    {
+      _BidirectionalIterator2 __buffer_end;
+      if (__len1 > __len2 && __len2 <= __buffer_size)
+  {
+    if (__len2)
+      {
+        __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
+        _GLIBCXX_MOVE_BACKWARD3(__first, __middle, __last);
+        return _GLIBCXX_MOVE3(__buffer, __buffer_end, __first);
+      }
+    else
+      return __first;
+  }
+      else if (__len1 <= __buffer_size)
+  {
+    if (__len1)
+      {
+        __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
+        _GLIBCXX_MOVE3(__middle, __last, __first);
+        return _GLIBCXX_MOVE_BACKWARD3(__buffer, __buffer_end, __last);
+      }
+    else
+      return __last;
+  }
+      else
+  {
+    std::rotate(__first, __middle, __last);
+    std::advance(__first, std::distance(__middle, __last));
+    return __first;
+  }
+    }
+
+  /// This is a helper function for the merge routines.
+  template<typename _BidirectionalIterator, typename _Distance,
+     typename _Pointer>
+    void
+    __merge_adaptive(_BidirectionalIterator __first,
+                     _BidirectionalIterator __middle,
+         _BidirectionalIterator __last,
+         _Distance __len1, _Distance __len2,
+         _Pointer __buffer, _Distance __buffer_size)
+    {
+      if (__len1 <= __len2 && __len1 <= __buffer_size)
+  {
+    _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
+    std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
+             __first);
+  }
+      else if (__len2 <= __buffer_size)
+  {
+    _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
+    std::__move_merge_adaptive_backward(__first, __middle, __buffer,
+                __buffer_end, __last);
+  }
+      else
+  {
+    _BidirectionalIterator __first_cut = __first;
+    _BidirectionalIterator __second_cut = __middle;
+    _Distance __len11 = 0;
+    _Distance __len22 = 0;
+    if (__len1 > __len2)
+      {
+        __len11 = __len1 / 2;
+        std::advance(__first_cut, __len11);
+        __second_cut = std::lower_bound(__middle, __last,
+                *__first_cut);
+        __len22 = std::distance(__middle, __second_cut);
+      }
+    else
+      {
+        __len22 = __len2 / 2;
+        std::advance(__second_cut, __len22);
+        __first_cut = std::upper_bound(__first, __middle,
+               *__second_cut);
+        __len11 = std::distance(__first, __first_cut);
+      }
+    _BidirectionalIterator __new_middle =
+      std::__rotate_adaptive(__first_cut, __middle, __second_cut,
+           __len1 - __len11, __len22, __buffer,
+           __buffer_size);
+    std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
+        __len22, __buffer, __buffer_size);
+    std::__merge_adaptive(__new_middle, __second_cut, __last,
+        __len1 - __len11,
+        __len2 - __len22, __buffer, __buffer_size);
+  }
+    }
+
+  /// This is a helper function for the merge routines.
+  template<typename _BidirectionalIterator, typename _Distance, 
+     typename _Pointer, typename _Compare>
+    void
+    __merge_adaptive(_BidirectionalIterator __first,
+                     _BidirectionalIterator __middle,
+         _BidirectionalIterator __last,
+         _Distance __len1, _Distance __len2,
+         _Pointer __buffer, _Distance __buffer_size,
+         _Compare __comp)
+    {
+      if (__len1 <= __len2 && __len1 <= __buffer_size)
+  {
+    _Pointer __buffer_end = _GLIBCXX_MOVE3(__first, __middle, __buffer);
+    std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
+             __first, __comp);
+  }
+      else if (__len2 <= __buffer_size)
+  {
+    _Pointer __buffer_end = _GLIBCXX_MOVE3(__middle, __last, __buffer);
+    std::__move_merge_adaptive_backward(__first, __middle, __buffer,
+                __buffer_end, __last, __comp);
+  }
+      else
+  {
+    _BidirectionalIterator __first_cut = __first;
+    _BidirectionalIterator __second_cut = __middle;
+    _Distance __len11 = 0;
+    _Distance __len22 = 0;
+    if (__len1 > __len2)
+      {
+        __len11 = __len1 / 2;
+        std::advance(__first_cut, __len11);
+        __second_cut = std::lower_bound(__middle, __last, *__first_cut,
+                __comp);
+        __len22 = std::distance(__middle, __second_cut);
+      }
+    else
+      {
+        __len22 = __len2 / 2;
+        std::advance(__second_cut, __len22);
+        __first_cut = std::upper_bound(__first, __middle, *__second_cut,
+               __comp);
+        __len11 = std::distance(__first, __first_cut);
+      }
+    _BidirectionalIterator __new_middle =
+      std::__rotate_adaptive(__first_cut, __middle, __second_cut,
+           __len1 - __len11, __len22, __buffer,
+           __buffer_size);
+    std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
+        __len22, __buffer, __buffer_size, __comp);
+    std::__merge_adaptive(__new_middle, __second_cut, __last,
+        __len1 - __len11,
+        __len2 - __len22, __buffer,
+        __buffer_size, __comp);
+  }
+    }
+
+  /// This is a helper function for the merge routines.
+  template<typename _BidirectionalIterator, typename _Distance>
+    void
+    __merge_without_buffer(_BidirectionalIterator __first,
+         _BidirectionalIterator __middle,
+         _BidirectionalIterator __last,
+         _Distance __len1, _Distance __len2)
+    {
+      if (__len1 == 0 || __len2 == 0)
+  return;
+      if (__len1 + __len2 == 2)
+  {
+    if (*__middle < *__first)
+      std::iter_swap(__first, __middle);
+    return;
+  }
+      _BidirectionalIterator __first_cut = __first;
+      _BidirectionalIterator __second_cut = __middle;
+      _Distance __len11 = 0;
+      _Distance __len22 = 0;
+      if (__len1 > __len2)
+  {
+    __len11 = __len1 / 2;
+    std::advance(__first_cut, __len11);
+    __second_cut = std::lower_bound(__middle, __last, *__first_cut);
+    __len22 = std::distance(__middle, __second_cut);
+  }
+      else
+  {
+    __len22 = __len2 / 2;
+    std::advance(__second_cut, __len22);
+    __first_cut = std::upper_bound(__first, __middle, *__second_cut);
+    __len11 = std::distance(__first, __first_cut);
+  }
+      std::rotate(__first_cut, __middle, __second_cut);
+      _BidirectionalIterator __new_middle = __first_cut;
+      std::advance(__new_middle, std::distance(__middle, __second_cut));
+      std::__merge_without_buffer(__first, __first_cut, __new_middle,
+          __len11, __len22);
+      std::__merge_without_buffer(__new_middle, __second_cut, __last,
+          __len1 - __len11, __len2 - __len22);
+    }
+
+  /// This is a helper function for the merge routines.
+  template<typename _BidirectionalIterator, typename _Distance,
+     typename _Compare>
+    void
+    __merge_without_buffer(_BidirectionalIterator __first,
+                           _BidirectionalIterator __middle,
+         _BidirectionalIterator __last,
+         _Distance __len1, _Distance __len2,
+         _Compare __comp)
+    {
+      if (__len1 == 0 || __len2 == 0)
+  return;
+      if (__len1 + __len2 == 2)
+  {
+    if (__comp(*__middle, *__first))
+      std::iter_swap(__first, __middle);
+    return;
+  }
+      _BidirectionalIterator __first_cut = __first;
+      _BidirectionalIterator __second_cut = __middle;
+      _Distance __len11 = 0;
+      _Distance __len22 = 0;
+      if (__len1 > __len2)
+  {
+    __len11 = __len1 / 2;
+    std::advance(__first_cut, __len11);
+    __second_cut = std::lower_bound(__middle, __last, *__first_cut,
+            __comp);
+    __len22 = std::distance(__middle, __second_cut);
+  }
+      else
+  {
+    __len22 = __len2 / 2;
+    std::advance(__second_cut, __len22);
+    __first_cut = std::upper_bound(__first, __middle, *__second_cut,
+           __comp);
+    __len11 = std::distance(__first, __first_cut);
+  }
+      std::rotate(__first_cut, __middle, __second_cut);
+      _BidirectionalIterator __new_middle = __first_cut;
+      std::advance(__new_middle, std::distance(__middle, __second_cut));
+      std::__merge_without_buffer(__first, __first_cut, __new_middle,
+          __len11, __len22, __comp);
+      std::__merge_without_buffer(__new_middle, __second_cut, __last,
+          __len1 - __len11, __len2 - __len22, __comp);
+    }
+
+  /**
+   *  @brief Merges two sorted ranges in place.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __middle  Another iterator.
+   *  @param  __last    Another iterator.
+   *  @return  Nothing.
+   *
+   *  Merges two sorted and consecutive ranges, [__first,__middle) and
+   *  [__middle,__last), and puts the result in [__first,__last).  The
+   *  output will be sorted.  The sort is @e stable, that is, for
+   *  equivalent elements in the two ranges, elements from the first
+   *  range will always come before elements from the second.
+   *
+   *  If enough additional memory is available, this takes (__last-__first)-1
+   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
+   *  distance(__first,__last).
+  */
+  template<Bidirectional_iterator _Iter>
+    requires Sortable<_Iter>()
+      void
+      inplace_merge(_Iter __first, _Iter __middle, _Iter __last)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        // concept requirements
+        __glibcxx_requires_sorted(__first, __middle);
+        __glibcxx_requires_sorted(__middle, __last);
+
+        if (__first == __middle || __middle == __last)
+    return;
+
+        _DistanceType __len1 = std::distance(__first, __middle);
+        _DistanceType __len2 = std::distance(__middle, __last);
+
+        _Temporary_buffer<_Iter, _ValueType> __buf(__first, __last);
+        if (__buf.begin() == 0)
+    std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
+        else
+    std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
+              __buf.begin(), _DistanceType(__buf.size()));
+      }
+
+  /**
+   *  @brief Merges two sorted ranges in place.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __middle  Another iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A functor to use for comparisons.
+   *  @return  Nothing.
+   *
+   *  Merges two sorted and consecutive ranges, [__first,__middle) and
+   *  [middle,last), and puts the result in [__first,__last).  The output will
+   *  be sorted.  The sort is @e stable, that is, for equivalent
+   *  elements in the two ranges, elements from the first range will always
+   *  come before elements from the second.
+   *
+   *  If enough additional memory is available, this takes (__last-__first)-1
+   *  comparisons.  Otherwise an NlogN algorithm is used, where N is
+   *  distance(__first,__last).
+   *
+   *  The comparison function should have the same effects on ordering as
+   *  the function used for the initial sort.
+  */
+  template<Bidirectional_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void
+      inplace_merge(_Iter __first, _Iter __middle, _Iter __last, _Compare __comp)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_requires_sorted_pred(__first, __middle, __comp);
+        __glibcxx_requires_sorted_pred(__middle, __last, __comp);
+
+        if (__first == __middle || __middle == __last)
+    return;
+
+        const _DistanceType __len1 = std::distance(__first, __middle);
+        const _DistanceType __len2 = std::distance(__middle, __last);
+
+        _Temporary_buffer<_Iter, _ValueType> __buf(__first,
+                    __last);
+        if (__buf.begin() == 0)
+    std::__merge_without_buffer(__first, __middle, __last, __len1,
+              __len2, __comp);
+        else
+    std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
+              __buf.begin(), _DistanceType(__buf.size()),
+              __comp);
+      }
+
+
+  /// This is a helper function for the __merge_sort_loop routines.
+  template<typename _InputIterator1, typename _InputIterator2,
+     typename _OutputIterator>
+    _OutputIterator
+    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
+     _InputIterator2 __first2, _InputIterator2 __last2,
+     _OutputIterator __result)
+    {
+      while (__first1 != __last1 && __first2 != __last2)
+  {
+    if (*__first2 < *__first1)
+      {
+        *__result = _GLIBCXX_MOVE(*__first2);
+        ++__first2;
+      }
+    else
+      {
+        *__result = _GLIBCXX_MOVE(*__first1);
+        ++__first1;
+      }
+    ++__result;
+  }
+      return _GLIBCXX_MOVE3(__first2, __last2,
+          _GLIBCXX_MOVE3(__first1, __last1,
+             __result));
+    }
+
+  /// This is a helper function for the __merge_sort_loop routines.
+  template<typename _InputIterator1, typename _InputIterator2,
+     typename _OutputIterator, typename _Compare>
+    _OutputIterator
+    __move_merge(_InputIterator1 __first1, _InputIterator1 __last1,
+     _InputIterator2 __first2, _InputIterator2 __last2,
+     _OutputIterator __result, _Compare __comp)
+    {
+      while (__first1 != __last1 && __first2 != __last2)
+  {
+    if (__comp(*__first2, *__first1))
+      {
+        *__result = _GLIBCXX_MOVE(*__first2);
+        ++__first2;
+      }
+    else
+      {
+        *__result = _GLIBCXX_MOVE(*__first1);
+        ++__first1;
+      }
+    ++__result;
+  }
+      return _GLIBCXX_MOVE3(__first2, __last2,
+          _GLIBCXX_MOVE3(__first1, __last1,
+             __result));
+    }
+
+  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
+     typename _Distance>
+    void
+    __merge_sort_loop(_RandomAccessIterator1 __first,
+          _RandomAccessIterator1 __last,
+          _RandomAccessIterator2 __result,
+          _Distance __step_size)
+    {
+      const _Distance __two_step = 2 * __step_size;
+
+      while (__last - __first >= __two_step)
+  {
+    __result = std::__move_merge(__first, __first + __step_size,
+               __first + __step_size,
+               __first + __two_step, __result);
+    __first += __two_step;
+  }
+
+      __step_size = std::min(_Distance(__last - __first), __step_size);
+      std::__move_merge(__first, __first + __step_size,
+      __first + __step_size, __last, __result);
+    }
+
+  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
+     typename _Distance, typename _Compare>
+    void
+    __merge_sort_loop(_RandomAccessIterator1 __first,
+          _RandomAccessIterator1 __last,
+          _RandomAccessIterator2 __result, _Distance __step_size,
+          _Compare __comp)
+    {
+      const _Distance __two_step = 2 * __step_size;
+
+      while (__last - __first >= __two_step)
+  {
+    __result = std::__move_merge(__first, __first + __step_size,
+               __first + __step_size,
+               __first + __two_step,
+               __result, __comp);
+    __first += __two_step;
+  }
+      __step_size = std::min(_Distance(__last - __first), __step_size);
+
+      std::__move_merge(__first,__first + __step_size,
+      __first + __step_size, __last, __result, __comp);
+    }
+
+  template<typename _RandomAccessIterator, typename _Distance>
+    void
+    __chunk_insertion_sort(_RandomAccessIterator __first,
+         _RandomAccessIterator __last,
+         _Distance __chunk_size)
+    {
+      while (__last - __first >= __chunk_size)
+  {
+    std::__insertion_sort(__first, __first + __chunk_size);
+    __first += __chunk_size;
+  }
+      std::__insertion_sort(__first, __last);
+    }
+
+  template<typename _RandomAccessIterator, typename _Distance,
+     typename _Compare>
+    void
+    __chunk_insertion_sort(_RandomAccessIterator __first,
+         _RandomAccessIterator __last,
+         _Distance __chunk_size, _Compare __comp)
+    {
+      while (__last - __first >= __chunk_size)
+  {
+    std::__insertion_sort(__first, __first + __chunk_size, __comp);
+    __first += __chunk_size;
+  }
+      std::__insertion_sort(__first, __last, __comp);
+    }
+
+  enum { _S_chunk_size = 7 };
+
+  template<typename _RandomAccessIterator, typename _Pointer>
+    void
+    __merge_sort_with_buffer(_RandomAccessIterator __first,
+           _RandomAccessIterator __last,
+                             _Pointer __buffer)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
+  _Distance;
+
+      const _Distance __len = __last - __first;
+      const _Pointer __buffer_last = __buffer + __len;
+
+      _Distance __step_size = _S_chunk_size;
+      std::__chunk_insertion_sort(__first, __last, __step_size);
+
+      while (__step_size < __len)
+  {
+    std::__merge_sort_loop(__first, __last, __buffer, __step_size);
+    __step_size *= 2;
+    std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
+    __step_size *= 2;
+  }
+    }
+
+  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
+    void
+    __merge_sort_with_buffer(_RandomAccessIterator __first,
+           _RandomAccessIterator __last,
+                             _Pointer __buffer, _Compare __comp)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
+  _Distance;
+
+      const _Distance __len = __last - __first;
+      const _Pointer __buffer_last = __buffer + __len;
+
+      _Distance __step_size = _S_chunk_size;
+      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
+
+      while (__step_size < __len)
+  {
+    std::__merge_sort_loop(__first, __last, __buffer,
+         __step_size, __comp);
+    __step_size *= 2;
+    std::__merge_sort_loop(__buffer, __buffer_last, __first,
+         __step_size, __comp);
+    __step_size *= 2;
+  }
+    }
+
+  template<typename _RandomAccessIterator, typename _Pointer,
+     typename _Distance>
+    void
+    __stable_sort_adaptive(_RandomAccessIterator __first,
+         _RandomAccessIterator __last,
+                           _Pointer __buffer, _Distance __buffer_size)
+    {
+      const _Distance __len = (__last - __first + 1) / 2;
+      const _RandomAccessIterator __middle = __first + __len;
+      if (__len > __buffer_size)
+  {
+    std::__stable_sort_adaptive(__first, __middle,
+              __buffer, __buffer_size);
+    std::__stable_sort_adaptive(__middle, __last,
+              __buffer, __buffer_size);
+  }
+      else
+  {
+    std::__merge_sort_with_buffer(__first, __middle, __buffer);
+    std::__merge_sort_with_buffer(__middle, __last, __buffer);
+  }
+      std::__merge_adaptive(__first, __middle, __last,
+          _Distance(__middle - __first),
+          _Distance(__last - __middle),
+          __buffer, __buffer_size);
+    }
+
+  template<typename _RandomAccessIterator, typename _Pointer,
+     typename _Distance, typename _Compare>
+    void
+    __stable_sort_adaptive(_RandomAccessIterator __first,
+         _RandomAccessIterator __last,
+                           _Pointer __buffer, _Distance __buffer_size,
+                           _Compare __comp)
+    {
+      const _Distance __len = (__last - __first + 1) / 2;
+      const _RandomAccessIterator __middle = __first + __len;
+      if (__len > __buffer_size)
+  {
+    std::__stable_sort_adaptive(__first, __middle, __buffer,
+              __buffer_size, __comp);
+    std::__stable_sort_adaptive(__middle, __last, __buffer,
+              __buffer_size, __comp);
+  }
+      else
+  {
+    std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
+    std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
+  }
+      std::__merge_adaptive(__first, __middle, __last,
+          _Distance(__middle - __first),
+          _Distance(__last - __middle),
+          __buffer, __buffer_size,
+          __comp);
+    }
+
+  /// This is a helper function for the stable sorting routines.
+  template<typename _RandomAccessIterator>
+    void
+    __inplace_stable_sort(_RandomAccessIterator __first,
+        _RandomAccessIterator __last)
+    {
+      if (__last - __first < 15)
+  {
+    std::__insertion_sort(__first, __last);
+    return;
+  }
+      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
+      std::__inplace_stable_sort(__first, __middle);
+      std::__inplace_stable_sort(__middle, __last);
+      std::__merge_without_buffer(__first, __middle, __last,
+          __middle - __first,
+          __last - __middle);
+    }
+
+  /// This is a helper function for the stable sorting routines.
+  template<typename _RandomAccessIterator, typename _Compare>
+    void
+    __inplace_stable_sort(_RandomAccessIterator __first,
+        _RandomAccessIterator __last, _Compare __comp)
+    {
+      if (__last - __first < 15)
+  {
+    std::__insertion_sort(__first, __last, __comp);
+    return;
+  }
+      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
+      std::__inplace_stable_sort(__first, __middle, __comp);
+      std::__inplace_stable_sort(__middle, __last, __comp);
+      std::__merge_without_buffer(__first, __middle, __last,
+          __middle - __first,
+          __last - __middle,
+          __comp);
+    }
+
+  // stable_sort
+
+  // Set algorithms: includes, set_union, set_intersection, set_difference,
+  // set_symmetric_difference.  All of these algorithms have the precondition
+  // that their input ranges are sorted and the postcondition that their output
+  // ranges are sorted.
+
+  /**
+   *  @brief Determines whether all elements of a sequence exists in a range.
+   *  @param  __first1  Start of search range.
+   *  @param  __last1   End of search range.
+   *  @param  __first2  Start of sequence
+   *  @param  __last2   End of sequence.
+   *  @return  True if each element in [__first2,__last2) is contained in order
+   *  within [__first1,__last1).  False otherwise.
+   *  @ingroup set_algorithms
+   *
+   *  This operation expects both [__first1,__last1) and
+   *  [__first2,__last2) to be sorted.  Searches for the presence of
+   *  each element in [__first2,__last2) within [__first1,__last1).
+   *  The iterators over each range only move forward, so this is a
+   *  linear algorithm.  If an element in [__first2,__last2) is not
+   *  found before the search iterator reaches @p __last2, false is
+   *  returned.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_ordered<_Iter1, _Iter2>()
+      bool
+      includes(_Iter1 __first1, _Iter1 __last1,
+               _Iter2 __first2, _Iter2 __last2)
+      {
+        __glibcxx_requires_sorted_set(__first1, __last1, __first2);
+        __glibcxx_requires_sorted_set(__first2, __last2, __first1);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          if (*__first2 < *__first1)
+            return false;
+          else if(*__first1 < *__first2)
+            ++__first1;
+          else
+            ++__first1, ++__first2;
+
+        return __first2 == __last2;
+      }
+
+  /**
+   *  @brief Determines whether all elements of a sequence exists in a range
+   *  using comparison.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of search range.
+   *  @param  __last1   End of search range.
+   *  @param  __first2  Start of sequence
+   *  @param  __last2   End of sequence.
+   *  @param  __comp    Comparison function to use.
+   *  @return True if each element in [__first2,__last2) is contained
+   *  in order within [__first1,__last1) according to comp.  False
+   *  otherwise.  @ingroup set_algorithms
+   *
+   *  This operation expects both [__first1,__last1) and
+   *  [__first2,__last2) to be sorted.  Searches for the presence of
+   *  each element in [__first2,__last2) within [__first1,__last1),
+   *  using comp to decide.  The iterators over each range only move
+   *  forward, so this is a linear algorithm.  If an element in
+   *  [__first2,__last2) is not found before the search iterator
+   *  reaches @p __last2, false is returned.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+    bool
+    includes(_Iter1 __first1, _Iter1 __last1,
+             _Iter2 __first2, _Iter2 __last2,
+             _Compare __comp)
+    {
+      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
+      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
+
+      while (__first1 != __last1 && __first2 != __last2)
+        if (__comp(*__first2, *__first1))
+          return false;
+        else if(__comp(*__first1, *__first2))
+          ++__first1;
+        else
+          ++__first1, ++__first2;
+
+      return __first2 == __last2;
+    }
+
+  // nth_element
+  // merge
+  // set_difference
+  // set_intersection
+  // set_union
+  // stable_sort
+  // set_symmetric_difference
+  // min_element
+  // max_element
+
+  /**
+   *  @brief  Permute range into the next @e dictionary ordering.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  False if wrapped to first permutation, true otherwise.
+   *
+   *  Treats all permutations of the range as a set of @e dictionary sorted
+   *  sequences.  Permutes the current sequence into the next one of this set.
+   *  Returns true if there are more sequences to generate.  If the sequence
+   *  is the largest of the set, the smallest is generated and false returned.
+  */
+  template<Bidirectional_iterator _Iter>
+    requires Sortable<_Iter>()
+      bool
+      next_permutation(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+    return false;
+        _Iter __i = __first;
+        ++__i;
+        if (__i == __last)
+    return false;
+        __i = __last;
+        --__i;
+
+        for(;;)
+    {
+      _Iter __ii = __i;
+      --__i;
+      if (*__i < *__ii)
+        {
+          _Iter __j = __last;
+          while (!(*__i < *--__j))
+      {}
+          std::iter_swap(__i, __j);
+          std::reverse(__ii, __last);
+          return true;
+        }
+      if (__i == __first)
+        {
+          std::reverse(__first, __last);
+          return false;
+        }
+    }
+      }
+
+  /**
+   *  @brief  Permute range into the next @e dictionary ordering using
+   *          comparison functor.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   A comparison functor.
+   *  @return  False if wrapped to first permutation, true otherwise.
+   *
+   *  Treats all permutations of the range [__first,__last) as a set of
+   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
+   *  sequence into the next one of this set.  Returns true if there are more
+   *  sequences to generate.  If the sequence is the largest of the set, the
+   *  smallest is generated and false returned.
+  */
+  template<Bidirectional_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      bool
+      next_permutation(_Iter __first,
+           _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+    return false;
+        _Iter __i = __first;
+        ++__i;
+        if (__i == __last)
+    return false;
+        __i = __last;
+        --__i;
+
+        for(;;)
+    {
+      _Iter __ii = __i;
+      --__i;
+      if (__comp(*__i, *__ii))
+        {
+          _Iter __j = __last;
+          while (!bool(__comp(*__i, *--__j)))
+      {}
+          std::iter_swap(__i, __j);
+          std::reverse(__ii, __last);
+          return true;
+        }
+      if (__i == __first)
+        {
+          std::reverse(__first, __last);
+          return false;
+        }
+    }
+      }
+
+  /**
+   *  @brief  Permute range into the previous @e dictionary ordering.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  False if wrapped to last permutation, true otherwise.
+   *
+   *  Treats all permutations of the range as a set of @e dictionary sorted
+   *  sequences.  Permutes the current sequence into the previous one of this
+   *  set.  Returns true if there are more sequences to generate.  If the
+   *  sequence is the smallest of the set, the largest is generated and false
+   *  returned.
+  */
+  template<Bidirectional_iterator _Iter>
+    requires Sortable<_Iter>()
+      bool
+      prev_permutation(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+    return false;
+        _Iter __i = __first;
+        ++__i;
+        if (__i == __last)
+    return false;
+        __i = __last;
+        --__i;
+
+        for(;;)
+    {
+      _Iter __ii = __i;
+      --__i;
+      if (*__ii < *__i)
+        {
+          _Iter __j = __last;
+          while (!(*--__j < *__i))
+      {}
+          std::iter_swap(__i, __j);
+          std::reverse(__ii, __last);
+          return true;
+        }
+      if (__i == __first)
+        {
+          std::reverse(__first, __last);
+          return false;
+        }
+    }
+      }
+
+  /**
+   *  @brief  Permute range into the previous @e dictionary ordering using
+   *          comparison functor.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   A comparison functor.
+   *  @return  False if wrapped to last permutation, true otherwise.
+   *
+   *  Treats all permutations of the range [__first,__last) as a set of
+   *  @e dictionary sorted sequences ordered by @p __comp.  Permutes the current
+   *  sequence into the previous one of this set.  Returns true if there are
+   *  more sequences to generate.  If the sequence is the smallest of the set,
+   *  the largest is generated and false returned.
+  */
+  template<Bidirectional_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      bool
+      prev_permutation(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+    return false;
+        _Iter __i = __first;
+        ++__i;
+        if (__i == __last)
+    return false;
+        __i = __last;
+        --__i;
+
+        for(;;)
+    {
+      _Iter __ii = __i;
+      --__i;
+      if (__comp(*__ii, *__i))
+        {
+          _Iter __j = __last;
+          while (!bool(__comp(*--__j, *__i)))
+      {}
+          std::iter_swap(__i, __j);
+          std::reverse(__ii, __last);
+          return true;
+        }
+      if (__i == __first)
+        {
+          std::reverse(__first, __last);
+          return false;
+        }
+    }
+      }
+
+  // replace
+  // replace_if
+
+  /**
+   *  @brief Copy a sequence, replacing each element of one value with another
+   *         value.
+   *  @param  __first      An input iterator.
+   *  @param  __last       An input iterator.
+   *  @param  __result     An output iterator.
+   *  @param  __old_value  The value to be replaced.
+   *  @param  __new_value  The replacement value.
+   *  @return   The end of the output sequence, @p result+(last-first).
+   *
+   *  Copies each element in the input range @p [__first,__last) to the
+   *  output range @p [__result,__result+(__last-__first)) replacing elements
+   *  equal to @p __old_value with @p __new_value.
+  */
+  template<Input_iterator _In, Advanceable _Out, Equality_comparable<Value_type<_In>> _Tp>
+    requires Indirectly_copyable<_In, _Out>() && Writable<_Out, _Tp>()
+      _Out
+      replace_copy(_In __first, _In __last, _Out __result,
+                   const _Tp& __old_value, const _Tp& __new_value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        for (; __first != __last; ++__first, ++__result)
+          if (*__first == __old_value)
+            *__result = __new_value;
+          else
+            *__result = *__first;
+        return __result;
+      }
+
+  /**
+   *  @brief Copy a sequence, replacing each value for which a predicate
+   *         returns true with another value.
+   *  @ingroup mutating_algorithms
+   *  @param  __first      An input iterator.
+   *  @param  __last       An input iterator.
+   *  @param  __result     An output iterator.
+   *  @param  __pred       A predicate.
+   *  @param  __new_value  The replacement value.
+   *  @return   The end of the output sequence, @p __result+(__last-__first).
+   *
+   *  Copies each element in the range @p [__first,__last) to the range
+   *  @p [__result,__result+(__last-__first)) replacing elements for which
+   *  @p __pred returns true with @p __new_value.
+  */
+  template<Input_iterator _In, Advanceable _Out,
+           Predicate<Value_type<_In>> _Predicate, typename _Tp>
+    requires Indirectly_copyable<_In, _Out>() && Writable<_Out, _Tp>()
+      _Out
+      replace_copy_if(_In __first, _In __last, _Out __result, 
+                      _Predicate __pred, const _Tp& __new_value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        for (; __first != __last; ++__first, ++__result)
+          if (__pred(*__first))
+            *__result = __new_value;
+          else
+            *__result = *__first;
+        return __result;
+      }
+
+  /**
+   *  @brief  Determines whether the elements of a sequence are sorted.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @return  True if the elements are sorted, false otherwise.
+  */
+  template<Forward_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+    inline bool
+    is_sorted(_Iter __first, _Iter __last)
+    { return std::is_sorted_until(__first, __last) == __last; }
+
+  /**
+   *  @brief  Determines whether the elements of a sequence are sorted
+   *          according to a comparison functor.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return  True if the elements are sorted, false otherwise.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    inline bool
+    is_sorted(_Iter __first, _Iter __last, _Compare __comp)
+    { return std::is_sorted_until(__first, __last, __comp) == __last; }
+
+  /**
+   *  @brief  Determines the end of a sorted sequence.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @return  An iterator pointing to the last iterator i in [__first, __last)
+   *           for which the range [__first, i) is sorted.
+  */
+  template<Forward_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      _Iter
+      is_sorted_until(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+          return __last;
+
+        _Iter __next = __first;
+        for (++__next; __next != __last; __first = __next, ++__next)
+          if (*__next < *__first)
+            return __next;
+        return __next;
+      }
+
+  /**
+   *  @brief  Determines the end of a sorted sequence using comparison functor.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return  An iterator pointing to the last iterator i in [__first, __last)
+   *           for which the range [__first, i) is sorted.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter
+    is_sorted_until(_Iter __first, _Iter __last,
+        _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last)
+          return __last;
+
+      _Iter __next = __first;
+      for (++__next; __next != __last; __first = __next, ++__next)
+        if (__comp(*__next, *__first))
+          return __next;
+      return __next;
+    }
+
+  /**
+   *  @brief  Determines min and max at once as an ordered pair.
+   *  @ingroup sorting_algorithms
+   *  @param  __a  A thing of arbitrary type.
+   *  @param  __b  Another thing of arbitrary type.
+   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
+   *  __b) otherwise.
+  */
+  template<Weakly_ordered _Tp>
+    inline pair<const _Tp&, const _Tp&>
+    minmax(const _Tp& __a, const _Tp& __b)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
+
+      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
+                 : pair<const _Tp&, const _Tp&>(__a, __b);
+    }
+
+  /**
+   *  @brief  Determines min and max at once as an ordered pair.
+   *  @ingroup sorting_algorithms
+   *  @param  __a  A thing of arbitrary type.
+   *  @param  __b  Another thing of arbitrary type.
+   *  @param  __comp  A @link comparison_functors comparison functor @endlink.
+   *  @return A pair(__b, __a) if __b is smaller than __a, pair(__a,
+   *  __b) otherwise.
+  */
+  template<typename _Tp, Relation<_Tp> _Compare>
+    inline pair<const _Tp&, const _Tp&>
+    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
+    {
+      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
+                        : pair<const _Tp&, const _Tp&>(__a, __b);
+    }
+
+  /**
+   *  @brief  Return a pair of iterators pointing to the minimum and maximum
+   *          elements in a range.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  make_pair(m, M), where m is the first iterator i in 
+   *           [__first, __last) such that no other element in the range is
+   *           smaller, and where M is the last iterator i in [__first, __last)
+   *           such that no other element in the range is larger.
+  */
+  template<Forward_iterator _Iter>
+    requires Weakly_ordered<Value_type<_Iter>>()
+      pair<_Iter, _Iter>
+      minmax_element(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        _Iter __next = __first;
+        if (__first == __last
+      || ++__next == __last)
+    return std::make_pair(__first, __first);
+
+        _Iter __min, __max;
+        if (*__next < *__first)
+    {
+      __min = __next;
+      __max = __first;
+    }
+        else
+    {
+      __min = __first;
+      __max = __next;
+    }
+
+        __first = __next;
+        ++__first;
+
+        while (__first != __last)
+    {
+      __next = __first;
+      if (++__next == __last)
+        {
+          if (*__first < *__min)
+      __min = __first;
+          else if (!(*__first < *__max))
+      __max = __first;
+          break;
+        }
+
+      if (*__next < *__first)
+        {
+          if (*__next < *__min)
+      __min = __next;
+          if (!(*__first < *__max))
+      __max = __first;
+        }
+      else
+        {
+          if (*__first < *__min)
+      __min = __first;
+          if (!(*__next < *__max))
+      __max = __next;
+        }
+
+      __first = __next;
+      ++__first;
+    }
+
+        return std::make_pair(__min, __max);
+      }
+
+  /**
+   *  @brief  Return a pair of iterators pointing to the minimum and maximum
+   *          elements in a range.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   Comparison functor.
+   *  @return  make_pair(m, M), where m is the first iterator i in 
+   *           [__first, __last) such that no other element in the range is
+   *           smaller, and where M is the last iterator i in [__first, __last)
+   *           such that no other element in the range is larger.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    pair<_Iter, _Iter>
+    minmax_element(_Iter __first, _Iter __last, _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      _Iter __next = __first;
+      if (__first == __last
+    || ++__next == __last)
+  return std::make_pair(__first, __first);
+
+      _Iter __min, __max;
+      if (__comp(*__next, *__first))
+  {
+    __min = __next;
+    __max = __first;
+  }
+      else
+  {
+    __min = __first;
+    __max = __next;
+  }
+
+      __first = __next;
+      ++__first;
+
+      while (__first != __last)
+  {
+    __next = __first;
+    if (++__next == __last)
+      {
+        if (__comp(*__first, *__min))
+    __min = __first;
+        else if (!__comp(*__first, *__max))
+    __max = __first;
+        break;
+      }
+
+    if (__comp(*__next, *__first))
+      {
+        if (__comp(*__next, *__min))
+    __min = __next;
+        if (!__comp(*__first, *__max))
+    __max = __first;
+      }
+    else
+      {
+        if (__comp(*__first, *__min))
+    __min = __first;
+        if (!__comp(*__next, *__max))
+    __max = __next;
+      }
+
+    __first = __next;
+    ++__first;
+  }
+
+      return std::make_pair(__min, __max);
+    }
+
+  // N2722 + DR 915.
+  template<Weakly_ordered _Tp>
+    inline _Tp
+    min(initializer_list<_Tp> __l)
+    { return *std::min_element(__l.begin(), __l.end()); }
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    inline _Tp
+    min(initializer_list<_Tp> __l, _Compare __comp)
+    { return *std::min_element(__l.begin(), __l.end(), __comp); }
+
+  template<Weakly_ordered _Tp>
+    inline _Tp
+    max(initializer_list<_Tp> __l)
+    { return *std::max_element(__l.begin(), __l.end()); }
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    inline _Tp
+    max(initializer_list<_Tp> __l, _Compare __comp)
+    { return *std::max_element(__l.begin(), __l.end(), __comp); }
+
+  template<Weakly_ordered _Tp>
+    inline pair<_Tp, _Tp>
+    minmax(initializer_list<_Tp> __l)
+    {
+      pair<const _Tp*, const _Tp*> __p =
+  std::minmax_element(__l.begin(), __l.end());
+      return std::make_pair(*__p.first, *__p.second);
+    }
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    inline pair<_Tp, _Tp>
+    minmax(initializer_list<_Tp> __l, _Compare __comp)
+    {
+      pair<const _Tp*, const _Tp*> __p =
+  std::minmax_element(__l.begin(), __l.end(), __comp);
+      return std::make_pair(*__p.first, *__p.second);
+    }
+
+  /**
+   *  @brief  Checks whether a permutaion of the second sequence is equal
+   *          to the first sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @return true if there exists a permutation of the elements in the range
+   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
+   *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
+   *          returns true; otherwise, returns false.
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      bool
+      is_permutation(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2)
+      {
+        // Efficiently compare identical prefixes:  O(N) if sequences
+        // have the same elements in the same order.
+        for (; __first1 != __last1; ++__first1, ++__first2)
+          if (!(*__first1 == *__first2))
+            break;
+
+        if (__first1 == __last1)
+          return true;
+
+        // Establish __last2 assuming equal ranges by iterating over the
+        // rest of the list.
+        _Iter2 __last2 = __first2;
+        std::advance(__last2, std::distance(__first1, __last1));
+        for (_Iter1 __scan = __first1; __scan != __last1; ++__scan)
+          {
+            if (__scan != _GLIBCXX_STD_A::find(__first1, __scan, *__scan))
+              continue; // We've seen this one before.
+
+            auto __matches = std::count(__first2, __last2, *__scan);
+            if (0 == __matches
+                || std::count(__scan, __last1, *__scan) != __matches)
+              return false;
+          }
+        return true;
+      }
+
+  /**
+   *  @brief  Checks whether a permutation of the second sequence is equal
+   *          to the first sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __pred    A binary predicate.
+   *  @return true if there exists a permutation of the elements in
+   *          the range [__first2, __first2 + (__last1 - __first1)),
+   *          beginning with ForwardIterator2 begin, such that
+   *          equal(__first1, __last1, __begin, __pred) returns true;
+   *          otherwise, returns false.
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      bool
+      is_permutation(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2, 
+                     _Compare __comp)
+      {
+        // Efficiently compare identical prefixes:  O(N) if sequences
+        // have the same elements in the same order.
+        for (; __first1 != __last1; ++__first1, ++__first2)
+          if (!bool(__comp(*__first1, *__first2)))
+            break;
+
+        if (__first1 == __last1)
+          return true;
+
+        // Establish __last2 assuming equal ranges by iterating over the
+        // rest of the list.
+        _Iter2 __last2 = __first2;
+        std::advance(__last2, std::distance(__first1, __last1));
+        for (_Iter1 __scan = __first1; __scan != __last1; ++__scan)
+          {
+            using std::placeholders::_1;
+
+            if (__scan != _GLIBCXX_STD_A::find_if(__first1, __scan,
+                    std::bind(__comp, _1, *__scan)))
+              continue; // We've seen this one before.
+            
+            auto __matches = std::count_if(__first2, __last2,
+                   std::bind(__comp, _1, *__scan));
+            if (0 == __matches
+                || std::count_if(__scan, __last1,
+                     std::bind(__comp, _1, *__scan)) != __matches)
+              return false;
+          }
+        return true;
+      }
+
+  /**
+   *  @brief Shuffle the elements of a sequence using a uniform random
+   *         number generator.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @param  __g       A UniformRandomNumberGenerator (26.5.1.3).
+   *  @return  Nothing.
+   *
+   *  Reorders the elements in the range @p [__first,__last) using @p __g to
+   *  provide random numbers.
+  */
+  template<Random_access_iterator _Iter, typename _UniformRandomNumberGenerator>
+    void
+    shuffle(_Iter __first, _Iter __last, _UniformRandomNumberGenerator&& __g)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last)
+        return;
+
+      typedef Difference_type<_Iter> _DistanceType;
+      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
+      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
+      typedef typename __distr_type::param_type __p_type;
+      __distr_type __d;
+
+      for (_Iter __i = __first + 1; __i != __last; ++__i)
+        std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
+    }
+
+
+_GLIBCXX_END_NAMESPACE_VERSION
+
+_GLIBCXX_BEGIN_NAMESPACE_ALGO
+
+  /**
+   *  @brief Apply a function to every element of a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __f      A unary function object.
+   *  @return   @p __f (std::move(@p __f) in C++0x).
+   *
+   *  Applies the function object @p __f to each element in the range
+   *  @p [first,last).  @p __f must not modify the order of the sequence.
+   *  If @p __f has a return value it is ignored.
+  */
+  template<Input_iterator _Iter, Function<Value_type<_Iter>> _Fn>
+    _Fn
+    for_each(_Iter __first, _Iter __last, _Fn __f)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      for (; __first != __last; ++__first)
+        __f(*__first);
+      return _GLIBCXX_MOVE(__f);
+    }
+
+  /**
+   *  @brief Find the first occurrence of a value in a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __val    The value to find.
+   *  @return   The first iterator @c i in the range @p [__first,__last)
+   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
+  */
+  template<Input_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    inline _Iter
+    find(_Iter __first, _Iter __last, const _Tp& __val)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      return std::__find(__first, __last, __val,
+             std::__iterator_category(__first));
+    }
+
+  /**
+   *  @brief Find the first element in a sequence for which a
+   *         predicate is true.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __pred   A predicate.
+   *  @return   The first iterator @c i in the range @p [__first,__last)
+   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    inline _Iter
+    find_if(_Iter __first, _Iter __last, _Predicate __pred)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      return std::__find_if(__first, __last, __pred,
+          std::__iterator_category(__first));
+    }
+
+  /**
+   *  @brief  Find element from a set in a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  Start of range to search.
+   *  @param  __last1   End of range to search.
+   *  @param  __first2  Start of match candidates.
+   *  @param  __last2   End of match candidates.
+   *  @return   The first iterator @c i in the range
+   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
+   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
+   *
+   *  Searches the range @p [__first1,__last1) for an element that is
+   *  equal to some element in the range [__first2,__last2).  If
+   *  found, returns an iterator in the range [__first1,__last1),
+   *  otherwise returns @p __last1.
+  */
+  template<Input_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      _Iter1
+      find_first_of(_Iter1 __first1, _Iter1 __last1,
+                    _Iter2 __first2, _Iter2 __last2)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        for (; __first1 != __last1; ++__first1)
+          for (_Iter2 __iter = __first2; __iter != __last2; ++__iter)
+            if (*__first1 == *__iter)
+              return __first1;
+        return __last1;
+      }
+
+  /**
+   *  @brief  Find element from a set in a sequence using a predicate.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  Start of range to search.
+   *  @param  __last1   End of range to search.
+   *  @param  __first2  Start of match candidates.
+   *  @param  __last2   End of match candidates.
+   *  @param  __comp    Predicate to use.
+   *  @return   The first iterator @c i in the range
+   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
+   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
+   *  such iterator exists.
+   *
+
+   *  Searches the range @p [__first1,__last1) for an element that is
+   *  equal to some element in the range [__first2,__last2).  If
+   *  found, returns an iterator in the range [__first1,__last1),
+   *  otherwise returns @p __last1.
+  */
+  template<Input_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      _Iter1
+      find_first_of(_Iter1 __first1, _Iter1 __last1,
+                    _Iter2 __first2, _Iter2 __last2,
+                    _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        for (; __first1 != __last1; ++__first1)
+          for (_Iter2 __iter = __first2; __iter != __last2; ++__iter)
+            if (__comp(*__first1, *__iter))
+              return __first1;
+        return __last1;
+      }
+
+  /**
+   *  @brief Find two adjacent values in a sequence that are equal.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __last   A forward iterator.
+   *  @return   The first iterator @c i such that @c i and @c i+1 are both
+   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
+   *  or @p __last if no such iterator exists.
+  */
+  template<Forward_iterator _Iter>
+    requires Equality_comparable<Value_type<_Iter>>()
+    _Iter
+    adjacent_find(_Iter __first, _Iter __last)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+      
+      if (__first == __last)
+        return __last;
+      _Iter __next = __first;
+      while(++__next != __last)
+        {
+          if (*__first == *__next)
+            return __first;
+          __first = __next;
+        }
+      return __last;
+    }
+
+  /**
+   *  @brief Find two adjacent values in a sequence using a predicate.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first         A forward iterator.
+   *  @param  __last          A forward iterator.
+   *  @param  __binary_pred   A binary predicate.
+   *  @return   The first iterator @c i such that @c i and @c i+1 are both
+   *  valid iterators in @p [__first,__last) and such that
+   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
+   *  exists.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter
+    adjacent_find(_Iter __first, _Iter __last, _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last)
+        return __last;
+      _Iter __next = __first;
+      while(++__next != __last)
+        {
+          if (__comp(*__first, *__next))
+            return __first;
+          __first = __next;
+        }
+      return __last;
+    }
+
+  /**
+   *  @brief Count the number of copies of a value in a sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __value  The value to be counted.
+   *  @return   The number of iterators @c i in the range @p [__first,__last)
+   *  for which @c *i == @p __value
+  */
+  template<Input_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    Difference_type<_Iter>
+    count(_Iter __first, _Iter __last, const _Tp& __value)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      Difference_type<_Iter> __n = 0;
+      for (; __first != __last; ++__first)
+        if (*__first == __value)
+          ++__n;
+      return __n;
+    }
+
+  /**
+   *  @brief Count the elements of a sequence for which a predicate is true.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __pred   A predicate.
+   *  @return   The number of iterators @c i in the range @p [__first,__last)
+   *  for which @p __pred(*i) is true.
+  */
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    Difference_type<_Iter>
+    count_if(_Iter __first, _Iter __last, _Predicate __pred)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      Difference_type<_Iter> __n = 0;
+      for (; __first != __last; ++__first)
+        if (__pred(*__first))
+          ++__n;
+      return __n;
+    }
+
+  /**
+   *  @brief Search a sequence for a matching sub-sequence.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  A forward iterator.
+   *  @param  __last1   A forward iterator.
+   *  @param  __first2  A forward iterator.
+   *  @param  __last2   A forward iterator.
+   *  @return The first iterator @c i in the range @p
+   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
+   *  *(__first2+N) for each @c N in the range @p
+   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
+   *
+   *  Searches the range @p [__first1,__last1) for a sub-sequence that
+   *  compares equal value-by-value with the sequence given by @p
+   *  [__first2,__last2) and returns an iterator to the first element
+   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
+   *  found.
+   *
+   *  Because the sub-sequence must lie completely within the range @p
+   *  [__first1,__last1) it must start at a position less than @p
+   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
+   *  length of the sub-sequence.
+   *
+   *  This means that the returned iterator @c i will be in the range
+   *  @p [__first1,__last1-(__last2-__first2))
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      _Iter1
+      search(_Iter1 __first1, _Iter1 __last1,
+       _Iter2 __first2, _Iter2 __last2)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        // Test for empty ranges
+        if (__first1 == __last1 || __first2 == __last2)
+    return __first1;
+
+        // Test for a pattern of length 1.
+        _Iter2 __p1(__first2);
+        if (++__p1 == __last2)
+    return _GLIBCXX_STD_A::find(__first1, __last1, *__first2);
+
+        // General case.
+        _Iter2 __p;
+        _Iter1 __current = __first1;
+
+        for (;;)
+    {
+      __first1 = _GLIBCXX_STD_A::find(__first1, __last1, *__first2);
+      if (__first1 == __last1)
+        return __last1;
+
+      __p = __p1;
+      __current = __first1;
+      if (++__current == __last1)
+        return __last1;
+
+      while (*__current == *__p)
+        {
+          if (++__p == __last2)
+      return __first1;
+          if (++__current == __last1)
+      return __last1;
+        }
+      ++__first1;
+    }
+        return __first1;
+      }
+
+  /**
+   *  @brief Search a sequence for a matching sub-sequence using a predicate.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1     A forward iterator.
+   *  @param  __last1      A forward iterator.
+   *  @param  __first2     A forward iterator.
+   *  @param  __last2      A forward iterator.
+   *  @param  __predicate  A binary predicate.
+   *  @return   The first iterator @c i in the range
+   *  @p [__first1,__last1-(__last2-__first2)) such that
+   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
+   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
+   *
+   *  Searches the range @p [__first1,__last1) for a sub-sequence that
+   *  compares equal value-by-value with the sequence given by @p
+   *  [__first2,__last2), using @p __predicate to determine equality,
+   *  and returns an iterator to the first element of the
+   *  sub-sequence, or @p __last1 if no such iterator exists.
+   *
+   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      _Iter1
+      search(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2, _Iter2 __last2,
+             _Compare  __predicate)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        // Test for empty ranges
+        if (__first1 == __last1 || __first2 == __last2)
+    return __first1;
+
+        // Test for a pattern of length 1.
+        _Iter2 __p1(__first2);
+        if (++__p1 == __last2)
+    {
+      while (__first1 != __last1
+       && !bool(__predicate(*__first1, *__first2)))
+        ++__first1;
+      return __first1;
+    }
+
+        // General case.
+        _Iter2 __p;
+        _Iter1 __current = __first1;
+
+        for (;;)
+    {
+      while (__first1 != __last1
+       && !bool(__predicate(*__first1, *__first2)))
+        ++__first1;
+      if (__first1 == __last1)
+        return __last1;
+
+      __p = __p1;
+      __current = __first1;
+      if (++__current == __last1)
+        return __last1;
+
+      while (__predicate(*__current, *__p))
+        {
+          if (++__p == __last2)
+      return __first1;
+          if (++__current == __last1)
+      return __last1;
+        }
+      ++__first1;
+    }
+        return __first1;
+      }
+
+
+  /**
+   *  @brief Search a sequence for a number of consecutive values.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __last   A forward iterator.
+   *  @param  __count  The number of consecutive values.
+   *  @param  __val    The value to find.
+   *  @return The first iterator @c i in the range @p
+   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
+   *  each @c N in the range @p [0,__count), or @p __last if no such
+   *  iterator exists.
+   *
+   *  Searches the range @p [__first,__last) for @p count consecutive elements
+   *  equal to @p __val.
+  */
+  template<Forward_iterator _Iter, Integral _Integer, 
+           Equality_comparable<Value_type<_Iter>> _Tp>
+    _Iter
+    search_n(_Iter __first, _Iter __last,
+       _Integer __count, const _Tp& __val)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__count <= 0)
+        return __first;
+      if (__count == 1)
+        return _GLIBCXX_STD_A::find(__first, __last, __val);
+      return std::__search_n(__first, __last, __count, __val,
+           std::__iterator_category(__first));
+    }
+
+
+  /**
+   *  @brief Search a sequence for a number of consecutive values using a
+   *         predicate.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first        A forward iterator.
+   *  @param  __last         A forward iterator.
+   *  @param  __count        The number of consecutive values.
+   *  @param  __val          The value to find.
+   *  @param  __comp         A relation.
+   *  @return The first iterator @c i in the range @p
+   *  [__first,__last-__count) such that @p
+   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
+   *  @p [0,__count), or @p __last if no such iterator exists.
+   *
+   *  Searches the range @p [__first,__last) for @p __count
+   *  consecutive elements for which the predicate returns true.
+  */
+  template<Forward_iterator _Iter, Integral _Integer, typename _Tp,
+           Relation<Value_type<_Iter>, _Tp> _Compare>
+    _Iter
+    search_n(_Iter __first, _Iter __last, _Integer __count, 
+             const _Tp& __val, _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__count <= 0)
+        return __first;
+      if (__count == 1)
+        {
+          while (__first != __last && !bool(__comp(*__first, __val)))
+            ++__first;
+          return __first;
+        }
+      return std::__search_n(__first, __last, __count, __val, __comp,
+           std::__iterator_category(__first));
+    }
+
+
+  /**
+   *  @brief Perform an operation on a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first     An input iterator.
+   *  @param  __last      An input iterator.
+   *  @param  __result    An output iterator.
+   *  @param  __unary_op  A unary operator.
+   *  @return   An output iterator equal to @p __result+(__last-__first).
+   *
+   *  Applies the operator to each element in the input range and assigns
+   *  the results to successive elements of the output sequence.
+   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
+   *  range @p [0,__last-__first).
+   *
+   *  @p unary_op must not alter its argument.
+  */
+  template<Input_iterator _In, Advanceable _Out, Function<Value_type<_In>> _Op>
+    requires Writable<_Out, Result_type<_Op(Value_type<_In>)>>()
+      _Out
+      transform(_In __first, _In __last, _Out __result, _Op __op)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        for (; __first != __last; ++__first, ++__result)
+          *__result = __op(*__first);
+        return __result;
+      }
+
+  /**
+   *  @brief Perform an operation on corresponding elements of two sequences.
+   *  @ingroup mutating_algorithms
+   *  @param  __first1     An input iterator.
+   *  @param  __last1      An input iterator.
+   *  @param  __first2     An input iterator.
+   *  @param  __result     An output iterator.
+   *  @param  __binary_op  A binary operator.
+   *  @return   An output iterator equal to @p result+(last-first).
+   *
+   *  Applies the operator to the corresponding elements in the two
+   *  input ranges and assigns the results to successive elements of the
+   *  output sequence.
+   *  Evaluates @p
+   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
+   *  @c N in the range @p [0,__last1-__first1).
+   *
+   *  @p binary_op must not alter either of its arguments.
+  */
+  template<Input_iterator _In1, Input_iterator _In2, Advanceable _Out, 
+           Function<Value_type<_In1>, Value_type<_In2>> _Op>
+    requires Writable<_Out, Result_type<_Op(Value_type<_In1>, Value_type<_In2>)>>()
+    _Out
+    transform(_In1 __first1, _In1 __last1,
+              _In2 __first2, _Out __result,
+              _Op __op)
+    {
+      __glibcxx_requires_valid_range(__first1, __last1);
+
+      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
+       *__result = __op(*__first1, *__first2);
+      return __result;
+    }
+
+  /**
+   *  @brief Replace each occurrence of one value in a sequence with another
+   *         value.
+   *  @ingroup mutating_algorithms
+   *  @param  __first      A forward iterator.
+   *  @param  __last       A forward iterator.
+   *  @param  __old_value  The value to be replaced.
+   *  @param  __new_value  The replacement value.
+   *  @return   replace() returns no value.
+   *
+   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
+   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
+  */
+  template<Forward_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    requires Writable<_Iter, _Tp>()
+      void
+      replace(_Iter __first, _Iter __last, 
+              const _Tp& __old_value, const _Tp& __new_value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        for (; __first != __last; ++__first)
+          if (*__first == __old_value)
+            *__first = __new_value;
+      }
+
+  /**
+   *  @brief Replace each value in a sequence for which a predicate returns
+   *         true with another value.
+   *  @ingroup mutating_algorithms
+   *  @param  __first      A forward iterator.
+   *  @param  __last       A forward iterator.
+   *  @param  __pred       A predicate.
+   *  @param  __new_value  The replacement value.
+   *  @return   replace_if() returns no value.
+   *
+   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
+   *  is true then the assignment @c *i = @p __new_value is performed.
+  */
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate, typename _Tp>
+    requires Writable<_Iter, _Tp>()
+      void
+      replace_if(_Iter __first, _Iter __last,
+                 _Predicate __pred, const _Tp& __new_value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        for (; __first != __last; ++__first)
+          if (__pred(*__first))
+            *__first = __new_value;
+      }
+
+  /**
+   *  @brief Assign the result of a function object to each value in a
+   *         sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __last   A forward iterator.
+   *  @param  __gen    A function object taking no arguments and returning
+   *                 std::iterator_traits<_ForwardIterator>::value_type
+   *  @return   generate() returns no value.
+   *
+   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
+   *  @p [__first,__last).
+  */
+  template<Forward_iterator _Iter, Generator _Generator>
+    requires Writable<_Iter, Result_type<_Generator>>()
+    void
+    generate(_Iter __first, _Iter __last, _Generator __gen)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      for (; __first != __last; ++__first)
+        *__first = __gen();
+    }
+
+  /**
+   *  @brief Assign the result of a function object to each value in a
+   *         sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __n      The length of the sequence.
+   *  @param  __gen    A function object taking no arguments and returning
+   *                 std::iterator_traits<_ForwardIterator>::value_type
+   *  @return   The end of the sequence, @p __first+__n
+   *
+   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
+   *  @p [__first,__first+__n).
+   *
+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+   *  DR 865. More algorithms that throw away information
+  */
+  template<Advanceable _Iter, Integral _Size, Generator _Generator>
+    requires Writable<_Iter, Result_type<_Generator>>()
+      _Iter
+      generate_n(_Iter __first, _Size __n, _Generator __gen)
+      {
+        for (__decltype(__n + 0) __niter = __n; __niter > 0; --__niter, ++__first)
+          *__first = __gen();
+        return __first;
+      }
+
+
+  /**
+   *  @brief Copy a sequence, removing consecutive duplicate values.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   An input iterator.
+   *  @param  __last    An input iterator.
+   *  @param  __result  An output iterator.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  Copies each element in the range @p [__first,__last) to the range
+   *  beginning at @p __result, except that only the first element is copied
+   *  from groups of consecutive elements that compare equal.
+   *  unique_copy() is stable, so the relative order of elements that are
+   *  copied is unchanged.
+   *
+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
+   *  
+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
+   *  Assignable?
+  */
+  template<Input_iterator _In, Advanceable _Out>
+    requires Equality_comparable<Value_type<_In>>()
+          && Indirectly_copyable<_In, _Out>()
+    inline _Out
+    unique_copy(_In __first, _In __last, _Out __result)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last)
+        return __result;
+      return std::__unique_copy(__first, __last, __result,
+        std::__iterator_category(__first),
+        std::__iterator_category(__result));
+    }
+
+  /**
+   *  @brief Copy a sequence, removing consecutive values using a predicate.
+   *  @ingroup mutating_algorithms
+   *  @param  __first        An input iterator.
+   *  @param  __last         An input iterator.
+   *  @param  __result       An output iterator.
+   *  @param  __binary_pred  A binary predicate.
+   *  @return   An iterator designating the end of the resulting sequence.
+   *
+   *  Copies each element in the range @p [__first,__last) to the range
+   *  beginning at @p __result, except that only the first element is copied
+   *  from groups of consecutive elements for which @p __binary_pred returns
+   *  true.
+   *  unique_copy() is stable, so the relative order of elements that are
+   *  copied is unchanged.
+   *
+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
+  */
+  template<Input_iterator _In, Advanceable _Out, Relation<Value_type<_In>> _Compare>
+    requires Indirectly_copyable<_In, _Out>()
+      inline _Out
+      unique_copy(_In __first, _In __last, _Out __result, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+          return __result;
+        return std::__unique_copy(__first, __last, __result, __comp,
+          std::__iterator_category(__first),
+          std::__iterator_category(__result));
+      }
+
+
+  /**
+   *  @brief Randomly shuffle the elements of a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @return  Nothing.
+   *
+   *  Reorder the elements in the range @p [__first,__last) using a random
+   *  distribution, so that every possible ordering of the sequence is
+   *  equally likely.
+  */
+  template<Random_access_iterator _Iter>
+    inline void
+    random_shuffle(_Iter __first, _Iter __last)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first != __last)
+        for (_Iter __i = __first + 1; __i != __last; ++__i)
+          std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
+    }
+
+  /**
+   *  @brief Shuffle the elements of a sequence using a random number
+   *         generator.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @param  __rand    The RNG functor or function.
+   *  @return  Nothing.
+   *
+   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
+   *  provide a random distribution. Calling @p __rand(N) for a positive
+   *  integer @p N should return a randomly chosen integer from the
+   *  range [0,N).
+  */
+  template<Random_access_iterator _Iter, typename _RandomNumberGenerator>
+    void
+    random_shuffle(_Iter __first, _Iter __last, _RandomNumberGenerator&& __rand)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last)
+        return;
+      for (_Iter __i = __first + 1; __i != __last; ++__i)
+        std::iter_swap(__i, __first + __rand((__i - __first) + 1));
+    }
+
+
+  /**
+   *  @brief Move elements for which a predicate is true to the beginning
+   *         of a sequence.
+   *  @ingroup mutating_algorithms
+   *  @param  __first   A forward iterator.
+   *  @param  __last    A forward iterator.
+   *  @param  __pred    A predicate functor.
+   *  @return  An iterator @p middle such that @p __pred(i) is true for each
+   *  iterator @p i in the range @p [__first,middle) and false for each @p i
+   *  in the range @p [middle,__last).
+   *
+   *  @p __pred must not modify its operand. @p partition() does not preserve
+   *  the relative ordering of elements in each group, use
+   *  @p stable_partition() if this is needed.
+  */
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    requires Permutable<_Iter>()
+      inline _Iter
+      partition(_Iter __first, _Iter __last, _Predicate   __pred)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        return std::__partition(__first, __last, __pred,
+              std::__iterator_category(__first));
+      }
+
+
+
+  /**
+   *  @brief Sort the smallest elements of a sequence.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __middle  Another iterator.
+   *  @param  __last    Another iterator.
+   *  @return  Nothing.
+   *
+   *  Sorts the smallest @p (__middle-__first) elements in the range
+   *  @p [first,last) and moves them to the range @p [__first,__middle). The
+   *  order of the remaining elements in the range @p [__middle,__last) is
+   *  undefined.
+   *  After the sort if @e i and @e j are iterators in the range
+   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
+   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      inline void
+      partial_sort(_Iter __first, _Iter __middle, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __middle);
+        __glibcxx_requires_valid_range(__middle, __last);
+
+        std::__heap_select(__first, __middle, __last);
+        std::sort_heap(__first, __middle);
+      }
+
+  /**
+   *  @brief Sort the smallest elements of a sequence using a predicate
+   *         for comparison.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __middle  Another iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return  Nothing.
+   *
+   *  Sorts the smallest @p (__middle-__first) elements in the range
+   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
+   *  order of the remaining elements in the range @p [__middle,__last) is
+   *  undefined.
+   *  After the sort if @e i and @e j are iterators in the range
+   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
+   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
+   *  are both false.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      inline void
+      partial_sort(_Iter __first, _Iter __middle, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __middle);
+        __glibcxx_requires_valid_range(__middle, __last);
+
+        std::__heap_select(__first, __middle, __last, __comp);
+        std::sort_heap(__first, __middle, __comp);
+      }
+
+  /**
+   *  @brief Sort a sequence just enough to find a particular position.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __nth     Another iterator.
+   *  @param  __last    Another iterator.
+   *  @return  Nothing.
+   *
+   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
+   *  is the same element that would have been in that position had the
+   *  whole sequence been sorted. The elements either side of @p *__nth are
+   *  not completely sorted, but for any iterator @e i in the range
+   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
+   *  holds that *j < *i is false.
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      inline void
+      nth_element(_Iter __first, _Iter __nth, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __nth);
+        __glibcxx_requires_valid_range(__nth, __last);
+
+        if (__first == __last || __nth == __last)
+          return;
+
+        std::__introselect(__first, __nth, __last,
+            std::__lg(__last - __first) * 2);
+      }
+
+  /**
+   *  @brief Sort a sequence just enough to find a particular position
+   *         using a predicate for comparison.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __nth     Another iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return  Nothing.
+   *
+   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
+   *  is the same element that would have been in that position had the
+   *  whole sequence been sorted. The elements either side of @p *__nth are
+   *  not completely sorted, but for any iterator @e i in the range
+   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
+   *  holds that @p __comp(*j,*i) is false.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      inline void
+      nth_element(_Iter __first, _Iter __nth, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __nth);
+        __glibcxx_requires_valid_range(__nth, __last);
+
+        if (__first == __last || __nth == __last)
+          return;
+
+        std::__introselect(__first, __nth, __last,
+            std::__lg(__last - __first) * 2, __comp);
+      }
+
+
+  /**
+   *  @brief Sort the elements of a sequence.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @return  Nothing.
+   *
+   *  Sorts the elements in the range @p [__first,__last) in ascending order,
+   *  such that for each iterator @e i in the range @p [__first,__last-1),  
+   *  *(i+1)<*i is false.
+   *
+   *  The relative ordering of equivalent elements is not preserved, use
+   *  @p stable_sort() if this is needed.
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      inline void
+      sort(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first != __last)
+          {
+            std::__introsort_loop(__first, __last, 
+                std::__lg(__last - __first) * 2);
+            std::__final_insertion_sort(__first, __last);
+          }
+      }
+
+  /**
+   *  @brief Sort the elements of a sequence using a predicate for comparison.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return  Nothing.
+   *
+   *  Sorts the elements in the range @p [__first,__last) in ascending order,
+   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
+   *  range @p [__first,__last-1).
+   *
+   *  The relative ordering of equivalent elements is not preserved, use
+   *  @p stable_sort() if this is needed.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      inline void
+      sort(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first != __last)
+          {
+            std::__introsort_loop(__first, __last,
+                std::__lg(__last - __first) * 2, __comp);
+            std::__final_insertion_sort(__first, __last, __comp);
+          }
+      }
+
+  /**
+   *  @brief Merges two sorted ranges.
+   *  @ingroup sorting_algorithms
+   *  @param  __first1  An iterator.
+   *  @param  __first2  Another iterator.
+   *  @param  __last1   Another iterator.
+   *  @param  __last2   Another iterator.
+   *  @param  __result  An iterator pointing to the end of the merged range.
+   *  @return         An iterator pointing to the first element <em>not less
+   *                  than</em> @e val.
+   *
+   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
+   *  the sorted range @p [__result, __result + (__last1-__first1) +
+   *  (__last2-__first2)).  Both input ranges must be sorted, and the
+   *  output range must not overlap with either of the input ranges.
+   *  The sort is @e stable, that is, for equivalent elements in the
+   *  two ranges, elements from the first range will always come
+   *  before elements from the second.
+  */
+  template<Input_iterator _In1, Input_iterator _In2, Advanceable _Out>
+    requires Mergeable<_In1, _In2, _Out>()
+      _Out
+      merge(_In1 __first1, _In1 __last1,
+            _In2 __first2, _In2 __last2,
+            _Out __result)
+      {
+        __glibcxx_requires_sorted_set(__first1, __last1, __first2);
+        __glibcxx_requires_sorted_set(__first2, __last2, __first1);
+
+        while (__first1 != __last1 && __first2 != __last2)
+    {
+      if (*__first2 < *__first1)
+        {
+          *__result = *__first2;
+          ++__first2;
+        }
+      else
+        {
+          *__result = *__first1;
+          ++__first1;
+        }
+      ++__result;
+    }
+        return std::copy(__first2, __last2, std::copy(__first1, __last1,
+                  __result));
+      }
+
+  /**
+   *  @brief Merges two sorted ranges.
+   *  @ingroup sorting_algorithms
+   *  @param  __first1  An iterator.
+   *  @param  __first2  Another iterator.
+   *  @param  __last1   Another iterator.
+   *  @param  __last2   Another iterator.
+   *  @param  __result  An iterator pointing to the end of the merged range.
+   *  @param  __comp    A functor to use for comparisons.
+   *  @return         An iterator pointing to the first element "not less
+   *                  than" @e val.
+   *
+   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
+   *  the sorted range @p [__result, __result + (__last1-__first1) +
+   *  (__last2-__first2)).  Both input ranges must be sorted, and the
+   *  output range must not overlap with either of the input ranges.
+   *  The sort is @e stable, that is, for equivalent elements in the
+   *  two ranges, elements from the first range will always come
+   *  before elements from the second.
+   *
+   *  The comparison function should have the same effects on ordering as
+   *  the function used for the initial sort.
+  */
+  template<Input_iterator _In1, Input_iterator _In2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_In1, _In2, _Out, _Compare>()
+      _Out
+      merge(_In1 __first1, _In1 __last1, 
+            _In2 __first2, _In2 __last2,
+            _Out __result, _Compare __comp)
+      {
+        __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
+        __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
+
+        while (__first1 != __last1 && __first2 != __last2)
+    {
+      if (__comp(*__first2, *__first1))
+        {
+          *__result = *__first2;
+          ++__first2;
+        }
+      else
+        {
+          *__result = *__first1;
+          ++__first1;
+        }
+      ++__result;
+    }
+        return std::copy(__first2, __last2, std::copy(__first1, __last1,
+                  __result));
+      }
+
+
+  /**
+   *  @brief Sort the elements of a sequence, preserving the relative order
+   *         of equivalent elements.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @return  Nothing.
+   *
+   *  Sorts the elements in the range @p [__first,__last) in ascending order,
+   *  such that for each iterator @p i in the range @p [__first,__last-1),
+   *  @p *(i+1)<*i is false.
+   *
+   *  The relative ordering of equivalent elements is preserved, so any two
+   *  elements @p x and @p y in the range @p [__first,__last) such that
+   *  @p x<y is false and @p y<x is false will have the same relative
+   *  ordering after calling @p stable_sort().
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      inline void
+      stable_sort(_Iter __first, _Iter __last)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_requires_valid_range(__first, __last);
+
+        _Temporary_buffer<_Iter, _ValueType> __buf(__first,
+                   __last);
+        if (__buf.begin() == 0)
+          std::__inplace_stable_sort(__first, __last);
+        else
+          std::__stable_sort_adaptive(__first, __last, __buf.begin(),
+              _DistanceType(__buf.size()));
+      }
+
+  /**
+   *  @brief Sort the elements of a sequence using a predicate for comparison,
+   *         preserving the relative order of equivalent elements.
+   *  @ingroup sorting_algorithms
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __comp    A comparison functor.
+   *  @return  Nothing.
+   *
+   *  Sorts the elements in the range @p [__first,__last) in ascending order,
+   *  such that for each iterator @p i in the range @p [__first,__last-1),
+   *  @p __comp(*(i+1),*i) is false.
+   *
+   *  The relative ordering of equivalent elements is preserved, so any two
+   *  elements @p x and @p y in the range @p [__first,__last) such that
+   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
+   *  relative ordering after calling @p stable_sort().
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      inline void
+      stable_sort(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_requires_valid_range(__first, __last);
+
+        _Temporary_buffer<_Iter, _ValueType> __buf(__first,
+                   __last);
+        if (__buf.begin() == 0)
+          std::__inplace_stable_sort(__first, __last, __comp);
+        else
+          std::__stable_sort_adaptive(__first, __last, __buf.begin(),
+              _DistanceType(__buf.size()), __comp);
+      }
+
+
+  /**
+   *  @brief Return the union of two sorted ranges.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  each range in order to the output range.  Iterators increment for each
+   *  range.  When the current element of one range is less than the other,
+   *  that element is copied and the iterator advanced.  If an element is
+   *  contained in both ranges, the element from the first range is copied and
+   *  both ranges advance.  The output range may not overlap either input
+   *  range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out
+      set_union(_Iter1 __first1, _Iter1 __last1,
+                _Iter2 __first2, _Iter2 __last2,
+                _Out __result)
+      {
+        __glibcxx_requires_sorted_set(__first1, __last1, __first2);
+        __glibcxx_requires_sorted_set(__first2, __last2, __first1);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          {
+            if (*__first1 < *__first2)
+              {
+                *__result = *__first1;
+                ++__first1;
+              }
+            else if (*__first2 < *__first1)
+              {
+                *__result = *__first2;
+                ++__first2;
+              }
+            else
+              {
+                *__result = *__first1;
+                ++__first1;
+                ++__first2;
+              }
+            ++__result;
+          }
+        return std::copy(__first2, __last2, std::copy(__first1, __last1,
+                  __result));
+      }
+
+  /**
+   *  @brief Return the union of two sorted ranges using a comparison functor.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @param  __comp    The comparison functor.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  each range in order to the output range.  Iterators increment for each
+   *  range.  When the current element of one range is less than the other
+   *  according to @p __comp, that element is copied and the iterator advanced.
+   *  If an equivalent element according to @p __comp is contained in both
+   *  ranges, the element from the first range is copied and both ranges
+   *  advance.  The output range may not overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out
+      set_union(_Iter1 __first1, _Iter1 __last1,
+                _Iter2 __first2, _Iter2 __last2,
+                _Out __result, _Compare __comp)
+      {
+        __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
+        __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
+
+        while (__first1 != __last1 && __first2 != __last2)
+    {
+      if (__comp(*__first1, *__first2))
+        {
+          *__result = *__first1;
+          ++__first1;
+        }
+      else if (__comp(*__first2, *__first1))
+        {
+          *__result = *__first2;
+          ++__first2;
+        }
+      else
+        {
+          *__result = *__first1;
+          ++__first1;
+          ++__first2;
+        }
+      ++__result;
+    }
+        return std::copy(__first2, __last2, std::copy(__first1, __last1,
+                  __result));
+      }
+
+  /**
+   *  @brief Return the intersection of two sorted ranges.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  both ranges in order to the output range.  Iterators increment for each
+   *  range.  When the current element of one range is less than the other,
+   *  that iterator advances.  If an element is contained in both ranges, the
+   *  element from the first range is copied and both ranges advance.  The
+   *  output range may not overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out
+      set_intersection(_Iter1 __first1, _Iter1 __last1,
+                       _Iter2 __first2, _Iter2 __last2,
+                      _Out __result)
+      {
+        __glibcxx_requires_sorted_set(__first1, __last1, __first2);
+        __glibcxx_requires_sorted_set(__first2, __last2, __first1);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          if (*__first1 < *__first2)
+            ++__first1;
+          else if (*__first2 < *__first1)
+            ++__first2;
+          else
+            {
+              *__result = *__first1;
+              ++__first1;
+              ++__first2;
+              ++__result;
+            }
+        return __result;
+      }
+
+  /**
+   *  @brief Return the intersection of two sorted ranges using comparison
+   *  functor.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @param  __comp    The comparison functor.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  both ranges in order to the output range.  Iterators increment for each
+   *  range.  When the current element of one range is less than the other
+   *  according to @p __comp, that iterator advances.  If an element is
+   *  contained in both ranges according to @p __comp, the element from the
+   *  first range is copied and both ranges advance.  The output range may not
+   *  overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out
+      set_intersection(_Iter1 __first1, _Iter1 __last1,
+                       _Iter2 __first2, _Iter2 __last2,
+                       _Out __result, _Compare __comp)
+      {
+        __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
+        __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          if (__comp(*__first1, *__first2))
+            ++__first1;
+          else if (__comp(*__first2, *__first1))
+            ++__first2;
+          else
+            {
+              *__result = *__first1;
+              ++__first1;
+              ++__first2;
+              ++__result;
+            }
+        return __result;
+      }
+
+  /**
+   *  @brief Return the difference of two sorted ranges.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  the first range but not the second in order to the output range.
+   *  Iterators increment for each range.  When the current element of the
+   *  first range is less than the second, that element is copied and the
+   *  iterator advances.  If the current element of the second range is less,
+   *  the iterator advances, but no element is copied.  If an element is
+   *  contained in both ranges, no elements are copied and both ranges
+   *  advance.  The output range may not overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out
+      set_difference(_Iter1 __first1, _Iter1 __last1,
+                     _Iter2 __first2, _Iter2 __last2,
+                     _Out __result)
+      {
+        __glibcxx_requires_sorted_set(__first1, __last1, __first2);
+        __glibcxx_requires_sorted_set(__first2, __last2, __first1);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          if (*__first1 < *__first2)
+            {
+              *__result = *__first1;
+              ++__first1;
+              ++__result;
+            }
+          else if (*__first2 < *__first1)
+            ++__first2;
+          else
+            {
+              ++__first1;
+              ++__first2;
+            }
+        return std::copy(__first1, __last1, __result);
+      }
+
+  /**
+   *  @brief  Return the difference of two sorted ranges using comparison
+   *  functor.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @param  __comp    The comparison functor.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  the first range but not the second in order to the output range.
+   *  Iterators increment for each range.  When the current element of the
+   *  first range is less than the second according to @p __comp, that element
+   *  is copied and the iterator advances.  If the current element of the
+   *  second range is less, no element is copied and the iterator advances.
+   *  If an element is contained in both ranges according to @p __comp, no
+   *  elements are copied and both ranges advance.  The output range may not
+   *  overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, 
+           typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out
+      set_difference(_Iter1 __first1, _Iter1 __last1,
+         _Iter2 __first2, _Iter2 __last2,
+         _Out __result, _Compare __comp)
+      {
+        __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
+        __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          if (__comp(*__first1, *__first2))
+            {
+              *__result = *__first1;
+              ++__first1;
+              ++__result;
+            }
+          else if (__comp(*__first2, *__first1))
+            ++__first2;
+          else
+            {
+              ++__first1;
+              ++__first2;
+            }
+        return std::copy(__first1, __last1, __result);
+      }
+
+  /**
+   *  @brief  Return the symmetric difference of two sorted ranges.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  one range but not the other in order to the output range.  Iterators
+   *  increment for each range.  When the current element of one range is less
+   *  than the other, that element is copied and the iterator advances.  If an
+   *  element is contained in both ranges, no elements are copied and both
+   *  ranges advance.  The output range may not overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out
+      set_symmetric_difference(_Iter1 __first1, _Iter1 __last1,
+                               _Iter2 __first2, _Iter2 __last2,
+                               _Out __result)
+      {
+        __glibcxx_requires_sorted_set(__first1, __last1, __first2);
+        __glibcxx_requires_sorted_set(__first2, __last2, __first1);
+
+        while (__first1 != __last1 && __first2 != __last2)
+    if (*__first1 < *__first2)
+      {
+        *__result = *__first1;
+        ++__first1;
+        ++__result;
+      }
+    else if (*__first2 < *__first1)
+      {
+        *__result = *__first2;
+        ++__first2;
+        ++__result;
+      }
+    else
+      {
+        ++__first1;
+        ++__first2;
+      }
+        return std::copy(__first2, __last2, std::copy(__first1,
+                  __last1, __result));
+      }
+
+  /**
+   *  @brief  Return the symmetric difference of two sorted ranges using
+   *  comparison functor.
+   *  @ingroup set_algorithms
+   *  @param  __first1  Start of first range.
+   *  @param  __last1   End of first range.
+   *  @param  __first2  Start of second range.
+   *  @param  __last2   End of second range.
+   *  @param  __comp    The comparison functor.
+   *  @return  End of the output range.
+   *  @ingroup set_algorithms
+   *
+   *  This operation iterates over both ranges, copying elements present in
+   *  one range but not the other in order to the output range.  Iterators
+   *  increment for each range.  When the current element of one range is less
+   *  than the other according to @p comp, that element is copied and the
+   *  iterator advances.  If an element is contained in both ranges according
+   *  to @p __comp, no elements are copied and both ranges advance.  The output
+   *  range may not overlap either input range.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, 
+           typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out
+      set_symmetric_difference(_Iter1 __first1, _Iter1 __last1,
+                               _Iter2 __first2, _Iter2 __last2,
+                               _Out __result,
+                               _Compare __comp)
+      {
+        __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
+        __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
+
+        while (__first1 != __last1 && __first2 != __last2)
+          if (__comp(*__first1, *__first2))
+            {
+              *__result = *__first1;
+              ++__first1;
+              ++__result;
+            }
+          else if (__comp(*__first2, *__first1))
+            {
+              *__result = *__first2;
+              ++__first2;
+              ++__result;
+            }
+          else
+            {
+              ++__first1;
+              ++__first2;
+            }
+        return std::copy(__first2, __last2, 
+             std::copy(__first1, __last1, __result));
+      }
+
+
+  /**
+   *  @brief  Return the minimum element in a range.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  Iterator referencing the first instance of the smallest value.
+  */
+  template<Forward_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      _Iter
+      min_element(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+          return __first;
+        _Iter __result = __first;
+        while (++__first != __last)
+          if (*__first < *__result)
+            __result = __first;
+        return __result;
+      }
+
+  /**
+   *  @brief  Return the minimum element in a range using comparison functor.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   Comparison functor.
+   *  @return  Iterator referencing the first instance of the smallest value
+   *  according to __comp.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter
+    min_element(_Iter __first, _Iter __last, _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last)
+        return __first;
+      _Iter __result = __first;
+      while (++__first != __last)
+        if (__comp(*__first, *__result))
+          __result = __first;
+      return __result;
+    }
+
+  /**
+   *  @brief  Return the maximum element in a range.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  Iterator referencing the first instance of the largest value.
+  */
+  template<Forward_iterator _Iter>
+    requires Weakly_ordered<Value_type<_Iter>>()
+      _Iter
+      max_element(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__first == __last)
+          return __first;
+        _Iter __result = __first;
+        while (++__first != __last)
+          if (*__result < *__first)
+            __result = __first;
+        return __result;
+      }
+
+  /**
+   *  @brief  Return the maximum element in a range using comparison functor.
+   *  @ingroup sorting_algorithms
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   Comparison functor.
+   *  @return  Iterator referencing the first instance of the largest value
+   *  according to __comp.
+  */
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter
+    max_element(_Iter __first, _Iter __last, _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      if (__first == __last) return __first;
+      _Iter __result = __first;
+      while (++__first != __last)
+        if (__comp(*__result, *__first))
+          __result = __first;
+      return __result;
+    }
+
+_GLIBCXX_END_NAMESPACE_ALGO
+} // namespace std
+
diff --git a/libstdc++-v3/include/bits/cons_algobase.h b/libstdc++-v3/include/bits/cons_algobase.h
new file mode 100644
index 0000000..bdffa9f
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_algobase.h
@@ -0,0 +1,1099 @@
+// Core algorithmic facilities -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
+// 2011, 2012 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ *
+ * Copyright (c) 1996-1998
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+
+  // See http://gcc.gnu.org/ml/libstdc++/2004-08/msg00167.html: in a
+  // nutshell, we are partially implementing the resolution of DR 187,
+  // when it's safe, i.e., the value_types are equal.
+  template<bool _BoolType>
+    struct __iter_swap
+    {
+      template<typename _ForwardIterator1, typename _ForwardIterator2>
+        static void
+        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
+        {
+          typedef typename iterator_traits<_ForwardIterator1>::value_type
+            _ValueType1;
+          _ValueType1 __tmp = _GLIBCXX_MOVE(*__a);
+          *__a = _GLIBCXX_MOVE(*__b);
+          *__b = _GLIBCXX_MOVE(__tmp);
+  }
+    };
+
+  template<>
+    struct __iter_swap<true>
+    {
+      template<typename _ForwardIterator1, typename _ForwardIterator2>
+        static void 
+        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
+        {
+          swap(*__a, *__b);
+        }
+    };
+
+  /**
+   *  @brief Swaps the contents of two iterators.
+   *  @ingroup mutating_algorithms
+   *  @param  __a  An iterator.
+   *  @param  __b  Another iterator.
+   *  @return   Nothing.
+   *
+   *  This function swaps the values pointed to by two iterators, not the
+   *  iterators themselves.
+  */
+  template<Readable _Iter1, Readable _Iter2>
+    requires Indirectly_swappable<_Iter1, _Iter2>()
+      inline void
+      iter_swap(_Iter1 __a, _Iter2 __b)
+      {
+        using _Ref1 = decltype(*__a);
+        using _Ref2 = decltype(*__b);
+        // constexpr bool __swap = Same<Value_type<_Iter1>, Value_type<_Iter2>>()
+        //                      && Same<Value_type<_Iter1>, _Ref1>()
+        //                      && Same<Value_type<_Iter2>, _Ref2>();
+        std::__iter_swap<false>::iter_swap(__a, __b);
+      }
+
+
+  /**
+   *  @brief Swap the elements of two sequences.
+   *  @ingroup mutating_algorithms
+   *  @param  __first1  A forward iterator.
+   *  @param  __last1   A forward iterator.
+   *  @param  __first2  A forward iterator.
+   *  @return   An iterator equal to @p first2+(last1-first1).
+   *
+   *  Swaps each element in the range @p [first1,last1) with the
+   *  corresponding element in the range @p [first2,(last1-first1)).
+   *  The ranges must not overlap.
+  */
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_swappable<_Iter1, _Iter2>()
+    _Iter2
+    swap_ranges(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2)
+    {
+      __glibcxx_requires_valid_range(__first1, __last1);
+
+      for (; __first1 != __last1; ++__first1, ++__first2)
+        std::iter_swap(__first1, __first2);
+      return __first2;
+    }
+
+
+  /**
+   *  @brief This does what you think it does.
+   *  @ingroup sorting_algorithms
+   *  @param  __a  A thing of arbitrary type.
+   *  @param  __b  Another thing of arbitrary type.
+   *  @return   The lesser of the parameters.
+   *
+   *  This is the simple classic generic implementation.  It will work on
+   *  temporary expressions, since they are only evaluated once, unlike a
+   *  preprocessor macro.
+  */
+  template<Totally_ordered _Tp>
+    inline const _Tp&
+    min(const _Tp& __a, const _Tp& __b)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
+      //return __b < __a ? __b : __a;
+      if (__b < __a)
+        return __b;
+      return __a;
+    }
+
+  /**
+   *  @brief This does what you think it does.
+   *  @ingroup sorting_algorithms
+   *  @param  __a  A thing of arbitrary type.
+   *  @param  __b  Another thing of arbitrary type.
+   *  @return   The greater of the parameters.
+   *
+   *  This is the simple classic generic implementation.  It will work on
+   *  temporary expressions, since they are only evaluated once, unlike a
+   *  preprocessor macro.
+  */
+  template<Totally_ordered _Tp>
+    inline const _Tp&
+    max(const _Tp& __a, const _Tp& __b)
+    {
+      // concept requirements
+      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
+      //return  __a < __b ? __b : __a;
+      if (__a < __b)
+  return __b;
+      return __a;
+    }
+
+  /**
+   *  @brief This does what you think it does.
+   *  @ingroup sorting_algorithms
+   *  @param  __a  A thing of arbitrary type.
+   *  @param  __b  Another thing of arbitrary type.
+   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
+   *  @return   The lesser of the parameters.
+   *
+   *  This will work on temporary expressions, since they are only evaluated
+   *  once, unlike a preprocessor macro.
+  */
+  template<typename _Tp, Relation<_Tp> _Compare>
+    inline const _Tp&
+    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
+    {
+      //return __comp(__b, __a) ? __b : __a;
+      if (__comp(__b, __a))
+  return __b;
+      return __a;
+    }
+
+  /**
+   *  @brief This does what you think it does.
+   *  @ingroup sorting_algorithms
+   *  @param  __a  A thing of arbitrary type.
+   *  @param  __b  Another thing of arbitrary type.
+   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
+   *  @return   The greater of the parameters.
+   *
+   *  This will work on temporary expressions, since they are only evaluated
+   *  once, unlike a preprocessor macro.
+  */
+  template<typename _Tp, Relation<_Tp> _Compare>
+    inline const _Tp&
+    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
+    {
+      //return __comp(__a, __b) ? __b : __a;
+      if (__comp(__a, __b))
+  return __b;
+      return __a;
+    }
+
+  // If _Iterator is a __normal_iterator return its base (a plain pointer,
+  // normally) otherwise return it untouched.  See copy, fill, ... 
+  template<typename _Iterator>
+    struct _Niter_base
+    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
+    { };
+
+  template<typename _Iterator>
+    inline typename _Niter_base<_Iterator>::iterator_type
+    __niter_base(_Iterator __it)
+    { return std::_Niter_base<_Iterator>::_S_base(__it); }
+
+  // Likewise, for move_iterator.
+  template<typename _Iterator>
+    struct _Miter_base
+    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
+    { };
+
+  template<typename _Iterator>
+    inline typename _Miter_base<_Iterator>::iterator_type
+    __miter_base(_Iterator __it)
+    { return std::_Miter_base<_Iterator>::_S_base(__it); }
+
+  // All of these auxiliary structs serve two purposes.  (1) Replace
+  // calls to copy with memmove whenever possible.  (Memmove, not memcpy,
+  // because the input and output ranges are permitted to overlap.)
+  // (2) If we're using random access iterators, then write the loop as
+  // a for loop with an explicit count.
+
+  template<bool, bool, typename>
+    struct __copy_move
+    {
+      template<typename _II, typename _OI>
+        static _OI
+        __copy_m(_II __first, _II __last, _OI __result)
+        {
+    for (; __first != __last; ++__result, ++__first)
+      *__result = *__first;
+    return __result;
+  }
+    };
+
+  template<typename _Category>
+    struct __copy_move<true, false, _Category>
+    {
+      template<typename _II, typename _OI>
+        static _OI
+        __copy_m(_II __first, _II __last, _OI __result)
+        {
+    for (; __first != __last; ++__result, ++__first)
+      *__result = std::move(*__first);
+    return __result;
+  }
+    };
+
+  template<>
+    struct __copy_move<false, false, random_access_iterator_tag>
+    {
+      template<typename _II, typename _OI>
+        static _OI
+        __copy_m(_II __first, _II __last, _OI __result)
+        { 
+    typedef typename iterator_traits<_II>::difference_type _Distance;
+    for(_Distance __n = __last - __first; __n > 0; --__n)
+      {
+        *__result = *__first;
+        ++__first;
+        ++__result;
+      }
+    return __result;
+  }
+    };
+
+  template<>
+    struct __copy_move<true, false, random_access_iterator_tag>
+    {
+      template<typename _II, typename _OI>
+        static _OI
+        __copy_m(_II __first, _II __last, _OI __result)
+        { 
+    typedef typename iterator_traits<_II>::difference_type _Distance;
+    for(_Distance __n = __last - __first; __n > 0; --__n)
+      {
+        *__result = std::move(*__first);
+        ++__first;
+        ++__result;
+      }
+    return __result;
+  }
+    };
+
+  template<bool _IsMove>
+    struct __copy_move<_IsMove, true, random_access_iterator_tag>
+    {
+      template<typename _Tp>
+        static _Tp*
+        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
+        {
+    const ptrdiff_t _Num = __last - __first;
+    if (_Num)
+      __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
+    return __result + _Num;
+  }
+    };
+
+  template<bool _IsMove, typename _II, typename _OI>
+    inline _OI
+    __copy_move_a(_II __first, _II __last, _OI __result)
+    {
+      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
+      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
+      typedef typename iterator_traits<_II>::iterator_category _Category;
+      const bool __simple = (__is_trivial(_ValueTypeI)
+                       && __is_pointer<_II>::__value
+                       && __is_pointer<_OI>::__value
+           && __are_same<_ValueTypeI, _ValueTypeO>::__value);
+
+      return std::__copy_move<_IsMove, __simple,
+                        _Category>::__copy_m(__first, __last, __result);
+    }
+
+  // Helpers for streambuf iterators (either istream or ostream).
+  // NB: avoid including <iosfwd>, relatively large.
+  template<typename _CharT>
+    struct char_traits;
+
+  template<typename _CharT, typename _Traits>
+    class istreambuf_iterator;
+
+  template<typename _CharT, typename _Traits>
+    class ostreambuf_iterator;
+
+  template<bool _IsMove, typename _CharT>
+    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
+       ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
+    __copy_move_a2(_CharT*, _CharT*,
+       ostreambuf_iterator<_CharT, char_traits<_CharT> >);
+
+  template<bool _IsMove, typename _CharT>
+    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, 
+       ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
+    __copy_move_a2(const _CharT*, const _CharT*,
+       ostreambuf_iterator<_CharT, char_traits<_CharT> >);
+
+  template<bool _IsMove, typename _CharT>
+    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
+            _CharT*>::__type
+    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
+       istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
+
+  template<bool _IsMove, typename _II, typename _OI>
+    inline _OI
+    __copy_move_a2(_II __first, _II __last, _OI __result)
+    {
+      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
+               std::__niter_base(__last),
+               std::__niter_base(__result)));
+    }
+
+  /**
+   *  @brief Copies the range [first,last) into result.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __result An output iterator.
+   *  @return   result + (first - last)
+   *
+   *  This inline function will boil down to a call to @c memmove whenever
+   *  possible.  Failing that, if random access iterators are passed, then the
+   *  loop count will be known (and therefore a candidate for compiler
+   *  optimizations such as unrolling).  Result may not be contained within
+   *  [first,last); the copy_backward function should be used instead.
+   *
+   *  Note that the end of the output range is permitted to be contained
+   *  within [first,last).
+  */
+  template<Input_iterator _In, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      inline _Out
+      copy(_In __first, _In __last, _Out __result)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        return (std::__copy_move_a2<__is_move_iterator<_In>::__value>
+          (std::__miter_base(__first), std::__miter_base(__last),
+           __result));
+      }
+
+  /**
+   *  @brief Moves the range [first,last) into result.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  An input iterator.
+   *  @param  __last   An input iterator.
+   *  @param  __result An output iterator.
+   *  @return   result + (first - last)
+   *
+   *  This inline function will boil down to a call to @c memmove whenever
+   *  possible.  Failing that, if random access iterators are passed, then the
+   *  loop count will be known (and therefore a candidate for compiler
+   *  optimizations such as unrolling).  Result may not be contained within
+   *  [first,last); the move_backward function should be used instead.
+   *
+   *  Note that the end of the output range is permitted to be contained
+   *  within [first,last).
+  */
+  template<Input_iterator _In, Advanceable _Out>
+    requires Indirectly_movable<_In, _Out>()
+    inline _Out
+    move(_In __first, _In __last, _Out __result)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      return std::__copy_move_a2<true>(std::__miter_base(__first),
+               std::__miter_base(__last), __result);
+    }
+
+#define _GLIBCXX_MOVE3(_Tp, _Up, _Vp) std::move(_Tp, _Up, _Vp)
+
+  template<bool, bool, typename>
+    struct __copy_move_backward
+    {
+      template<typename _BI1, typename _BI2>
+        static _BI2
+        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
+        {
+    while (__first != __last)
+      *--__result = *--__last;
+    return __result;
+  }
+    };
+
+  template<typename _Category>
+    struct __copy_move_backward<true, false, _Category>
+    {
+      template<typename _BI1, typename _BI2>
+        static _BI2
+        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
+        {
+    while (__first != __last)
+      *--__result = std::move(*--__last);
+    return __result;
+  }
+    };
+
+  template<>
+    struct __copy_move_backward<false, false, random_access_iterator_tag>
+    {
+      template<typename _BI1, typename _BI2>
+        static _BI2
+        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
+        {
+    typename iterator_traits<_BI1>::difference_type __n;
+    for (__n = __last - __first; __n > 0; --__n)
+      *--__result = *--__last;
+    return __result;
+  }
+    };
+
+  template<>
+    struct __copy_move_backward<true, false, random_access_iterator_tag>
+    {
+      template<typename _BI1, typename _BI2>
+        static _BI2
+        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
+        {
+    typename iterator_traits<_BI1>::difference_type __n;
+    for (__n = __last - __first; __n > 0; --__n)
+      *--__result = std::move(*--__last);
+    return __result;
+  }
+    };
+
+  template<bool _IsMove>
+    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
+    {
+      template<typename _Tp>
+        static _Tp*
+        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
+        {
+    const ptrdiff_t _Num = __last - __first;
+    if (_Num)
+      __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
+    return __result - _Num;
+  }
+    };
+
+  template<bool _IsMove, typename _BI1, typename _BI2>
+    inline _BI2
+    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
+    {
+      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
+      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
+      typedef typename iterator_traits<_BI1>::iterator_category _Category;
+      const bool __simple = (__is_trivial(_ValueType1)
+                       && __is_pointer<_BI1>::__value
+                       && __is_pointer<_BI2>::__value
+           && __are_same<_ValueType1, _ValueType2>::__value);
+
+      return std::__copy_move_backward<_IsMove, __simple,
+                                 _Category>::__copy_move_b(__first,
+                 __last,
+                 __result);
+    }
+
+  template<bool _IsMove, typename _BI1, typename _BI2>
+    inline _BI2
+    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
+    {
+      return _BI2(std::__copy_move_backward_a<_IsMove>
+      (std::__niter_base(__first), std::__niter_base(__last),
+       std::__niter_base(__result)));
+    }
+
+  /**
+   *  @brief Copies the range [first,last) into result.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A bidirectional iterator.
+   *  @param  __last   A bidirectional iterator.
+   *  @param  __result A bidirectional iterator.
+   *  @return   result - (first - last)
+   *
+   *  The function has the same effect as copy, but starts at the end of the
+   *  range and works its way to the start, returning the start of the result.
+   *  This inline function will boil down to a call to @c memmove whenever
+   *  possible.  Failing that, if random access iterators are passed, then the
+   *  loop count will be known (and therefore a candidate for compiler
+   *  optimizations such as unrolling).
+   *
+   *  Result may not be in the range [first,last).  Use copy instead.  Note
+   *  that the start of the output range may overlap [first,last).
+  */
+  template<Bidirectional_iterator _In, Bidirectional_iterator _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      inline _Out
+      copy_backward(_In __first, _In __last, _Out __result)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        return (std::__copy_move_backward_a2<__is_move_iterator<_In>::__value>
+          (std::__miter_base(__first), std::__miter_base(__last),
+           __result));
+      }
+
+  /**
+   *  @brief Moves the range [first,last) into result.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A bidirectional iterator.
+   *  @param  __last   A bidirectional iterator.
+   *  @param  __result A bidirectional iterator.
+   *  @return   result - (first - last)
+   *
+   *  The function has the same effect as move, but starts at the end of the
+   *  range and works its way to the start, returning the start of the result.
+   *  This inline function will boil down to a call to @c memmove whenever
+   *  possible.  Failing that, if random access iterators are passed, then the
+   *  loop count will be known (and therefore a candidate for compiler
+   *  optimizations such as unrolling).
+   *
+   *  Result may not be in the range (first,last].  Use move instead.  Note
+   *  that the start of the output range may overlap [first,last).
+  */
+  template<Bidirectional_iterator _In, Bidirectional_iterator _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      inline _Out
+      move_backward(_In __first, _In __last, _Out __result)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
+              std::__miter_base(__last),
+              __result);
+      }
+
+#define _GLIBCXX_MOVE_BACKWARD3(_Tp, _Up, _Vp) std::move_backward(_Tp, _Up, _Vp)
+
+
+  template<typename _ForwardIterator, typename _Tp>
+    inline typename
+    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
+    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
+       const _Tp& __value)
+    {
+      for (; __first != __last; ++__first)
+  *__first = __value;
+    }
+    
+  template<typename _ForwardIterator, typename _Tp>
+    inline typename
+    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
+    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
+       const _Tp& __value)
+    {
+      const _Tp __tmp = __value;
+      for (; __first != __last; ++__first)
+  *__first = __tmp;
+    }
+
+  // Specialization: for char types we can use memset.
+  template<typename _Tp>
+    inline typename
+    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
+    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
+    {
+      const _Tp __tmp = __c;
+      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
+           __last - __first);
+    }
+
+  /**
+   *  @brief Fills the range [first,last) with copies of value.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  A forward iterator.
+   *  @param  __last   A forward iterator.
+   *  @param  __value  A reference-to-const of arbitrary type.
+   *  @return   Nothing.
+   *
+   *  This function fills a range with copies of the same value.  For char
+   *  types filling contiguous areas of memory, this becomes an inline call
+   *  to @c memset or @c wmemset.
+  */
+  template<Forward_iterator _Iter, typename _Tp>
+    requires Writable<_Iter, _Tp>()
+      inline void
+      fill(_Iter __first, _Iter __last, const _Tp& __value)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
+          __value);
+      }
+
+  template<typename _OutputIterator, typename _Size, typename _Tp>
+    inline typename
+    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
+    {
+      for (__decltype(__n + 0) __niter = __n;
+     __niter > 0; --__niter, ++__first)
+  *__first = __value;
+      return __first;
+    }
+
+  template<typename _OutputIterator, typename _Size, typename _Tp>
+    inline typename
+    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
+    {
+      const _Tp __tmp = __value;
+      for (__decltype(__n + 0) __niter = __n;
+     __niter > 0; --__niter, ++__first)
+  *__first = __tmp;
+      return __first;
+    }
+
+  template<typename _Size, typename _Tp>
+    inline typename
+    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
+    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
+    {
+      std::__fill_a(__first, __first + __n, __c);
+      return __first + __n;
+    }
+
+  /**
+   *  @brief Fills the range [first,first+n) with copies of value.
+   *  @ingroup mutating_algorithms
+   *  @param  __first  An output iterator.
+   *  @param  __n      The count of copies to perform.
+   *  @param  __value  A reference-to-const of arbitrary type.
+   *  @return   The iterator at first+n.
+   *
+   *  This function fills a range with copies of the same value.  For char
+   *  types filling contiguous areas of memory, this becomes an inline call
+   *  to @c memset or @ wmemset.
+   *
+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
+   *  DR 865. More algorithms that throw away information
+  */
+  template<Advanceable _Iter, Integral _Size, typename _Tp>
+    requires Writable<_Iter, _Tp>()
+      inline _Iter
+      fill_n(_Iter __first, _Size __n, const _Tp& __value)
+      {
+        return _Iter(std::__fill_n_a(std::__niter_base(__first), __n, __value));
+      }
+
+  template<bool _BoolType>
+    struct __equal
+    {
+      template<typename _II1, typename _II2>
+        static bool
+        equal(_II1 __first1, _II1 __last1, _II2 __first2)
+        {
+    for (; __first1 != __last1; ++__first1, ++__first2)
+      if (!(*__first1 == *__first2))
+        return false;
+    return true;
+  }
+    };
+
+  template<>
+    struct __equal<true>
+    {
+      template<typename _Tp>
+        static bool
+        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
+        {
+    return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
+           * (__last1 - __first1));
+  }
+    };
+
+  template<typename _II1, typename _II2>
+    inline bool
+    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
+    {
+      typedef typename iterator_traits<_II1>::value_type _ValueType1;
+      typedef typename iterator_traits<_II2>::value_type _ValueType2;
+      const bool __simple = ((__is_integer<_ValueType1>::__value
+            || __is_pointer<_ValueType1>::__value)
+                       && __is_pointer<_II1>::__value
+                       && __is_pointer<_II2>::__value
+           && __are_same<_ValueType1, _ValueType2>::__value);
+
+      return std::__equal<__simple>::equal(__first1, __last1, __first2);
+    }
+
+
+  template<typename, typename>
+    struct __lc_rai
+    {
+      template<typename _II1, typename _II2>
+        static _II1
+        __newlast1(_II1, _II1 __last1, _II2, _II2)
+        { return __last1; }
+
+      template<typename _II>
+        static bool
+        __cnd2(_II __first, _II __last)
+        { return __first != __last; }
+    };
+
+  template<>
+    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
+    {
+      template<typename _RAI1, typename _RAI2>
+        static _RAI1
+        __newlast1(_RAI1 __first1, _RAI1 __last1,
+       _RAI2 __first2, _RAI2 __last2)
+        {
+    const typename iterator_traits<_RAI1>::difference_type
+      __diff1 = __last1 - __first1;
+    const typename iterator_traits<_RAI2>::difference_type
+      __diff2 = __last2 - __first2;
+    return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
+  }
+
+      template<typename _RAI>
+        static bool
+        __cnd2(_RAI, _RAI)
+        { return true; }
+    };
+
+  template<bool _BoolType>
+    struct __lexicographical_compare
+    {
+      template<typename _II1, typename _II2>
+        static bool __lc(_II1, _II1, _II2, _II2);
+    };
+
+  template<bool _BoolType>
+    template<typename _II1, typename _II2>
+      bool
+      __lexicographical_compare<_BoolType>::
+      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
+      {
+  typedef typename iterator_traits<_II1>::iterator_category _Category1;
+  typedef typename iterator_traits<_II2>::iterator_category _Category2;
+  typedef std::__lc_rai<_Category1, _Category2>   __rai_type;
+  
+  __last1 = __rai_type::__newlast1(__first1, __last1,
+           __first2, __last2);
+  for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
+       ++__first1, ++__first2)
+    {
+      if (*__first1 < *__first2)
+        return true;
+      if (*__first2 < *__first1)
+        return false;
+    }
+  return __first1 == __last1 && __first2 != __last2;
+      }
+
+  template<>
+    struct __lexicographical_compare<true>
+    {
+      template<typename _Tp, typename _Up>
+        static bool
+        __lc(const _Tp* __first1, const _Tp* __last1,
+       const _Up* __first2, const _Up* __last2)
+  {
+    const size_t __len1 = __last1 - __first1;
+    const size_t __len2 = __last2 - __first2;
+    const int __result = __builtin_memcmp(__first1, __first2,
+            std::min(__len1, __len2));
+    return __result != 0 ? __result < 0 : __len1 < __len2;
+  }
+    };
+
+  template<typename _II1, typename _II2>
+    inline bool
+    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
+          _II2 __first2, _II2 __last2)
+    {
+      typedef typename iterator_traits<_II1>::value_type _ValueType1;
+      typedef typename iterator_traits<_II2>::value_type _ValueType2;
+      const bool __simple =
+  (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
+   && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
+   && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
+   && __is_pointer<_II1>::__value
+   && __is_pointer<_II2>::__value);
+
+      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
+                  __first2, __last2);
+    }
+
+  /**
+   *  @brief Finds the first position in which @a val could be inserted
+   *         without changing the ordering.
+   *  @param  __first   An iterator.
+   *  @param  __last    Another iterator.
+   *  @param  __val     The search term.
+   *  @return         An iterator pointing to the first element <em>not less
+   *                  than</em> @a val, or end() if every element is less than 
+   *                  @a val.
+   *  @ingroup binary_search_algorithms
+  */
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    _Iter
+    lower_bound(_Iter __first, _Iter __last,
+    const _Tp& __val)
+    {
+      __glibcxx_requires_partitioned_lower(__first, __last, __val);
+
+      auto __len = std::distance(__first, __last);
+      while (__len > 0)
+        {
+          auto  __half = __len >> 1;
+          _Iter __middle = __first;
+          std::advance(__middle, __half);
+          if (*__middle < __val)
+            {
+              __first = __middle;
+              ++__first;
+              __len = __len - __half - 1;
+            }
+          else
+            __len = __half;
+        }
+      return __first;
+    }
+
+  /// This is a helper function for the sort routines and for random.tcc.
+  //  Precondition: __n > 0.
+  inline _GLIBCXX_CONSTEXPR int
+  __lg(int __n)
+  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
+
+  inline _GLIBCXX_CONSTEXPR unsigned
+  __lg(unsigned __n)
+  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
+
+  inline _GLIBCXX_CONSTEXPR long
+  __lg(long __n)
+  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
+
+  inline _GLIBCXX_CONSTEXPR unsigned long
+  __lg(unsigned long __n)
+  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
+
+  inline _GLIBCXX_CONSTEXPR long long
+  __lg(long long __n)
+  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
+
+  inline _GLIBCXX_CONSTEXPR unsigned long long
+  __lg(unsigned long long __n)
+  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+
+_GLIBCXX_BEGIN_NAMESPACE_ALGO
+
+  /**
+   *  @brief Tests a range for element-wise equality.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  An input iterator.
+   *  @param  __last1   An input iterator.
+   *  @param  __first2  An input iterator.
+   *  @return   A boolean true or false.
+   *
+   *  This compares the elements of two ranges using @c == and returns true or
+   *  false depending on whether all of the corresponding elements of the
+   *  ranges are equal.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      inline bool
+      equal(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+
+        return std::__equal_aux(std::__niter_base(__first1),
+              std::__niter_base(__last1),
+              std::__niter_base(__first2));
+      }
+
+  /**
+   *  @brief Tests a range for element-wise equality.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  An input iterator.
+   *  @param  __last1   An input iterator.
+   *  @param  __first2  An input iterator.
+   *  @param __binary_pred A binary predicate @link functors
+   *                  functor@endlink.
+   *  @return         A boolean true or false.
+   *
+   *  This compares the elements of two ranges using the binary_pred
+   *  parameter, and returns true or
+   *  false depending on whether all of the corresponding elements of the
+   *  ranges are equal.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      inline bool
+      equal(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+
+        for (; __first1 != __last1; ++__first1, ++__first2)
+          if (!bool(__comp(*__first1, *__first2)))
+            return false;
+        return true;
+      }
+
+  /**
+   *  @brief Performs @b dictionary comparison on ranges.
+   *  @ingroup sorting_algorithms
+   *  @param  __first1  An input iterator.
+   *  @param  __last1   An input iterator.
+   *  @param  __first2  An input iterator.
+   *  @param  __last2   An input iterator.
+   *  @return   A boolean true or false.
+   *
+   *  <em>Returns true if the sequence of elements defined by the range
+   *  [first1,last1) is lexicographically less than the sequence of elements
+   *  defined by the range [first2,last2).  Returns false otherwise.</em>
+   *  (Quoted from [25.3.8]/1.)  If the iterators are all character pointers,
+   *  then this is an inline call to @c memcmp.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_ordered<_Iter1, _Iter2>()
+      inline bool
+      lexicographical_compare(_Iter1 __first1, _Iter1 __last1, 
+                              _Iter2 __first2, _Iter2 __last2)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        return std::__lexicographical_compare_aux(std::__niter_base(__first1),
+              std::__niter_base(__last1),
+              std::__niter_base(__first2),
+              std::__niter_base(__last2));
+      }
+
+  /**
+   *  @brief Performs @b dictionary comparison on ranges.
+   *  @ingroup sorting_algorithms
+   *  @param  __first1  An input iterator.
+   *  @param  __last1   An input iterator.
+   *  @param  __first2  An input iterator.
+   *  @param  __last2   An input iterator.
+   *  @param  __comp  A @link comparison_functors comparison functor@endlink.
+   *  @return   A boolean true or false.
+   *
+   *  The same as the four-parameter @c lexicographical_compare, but uses the
+   *  comp parameter instead of @c <.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      bool
+      lexicographical_compare(_Iter1 __first1, _Iter1 __last1,
+                              _Iter2 __first2, _Iter2 __last2, 
+                              _Compare __comp)
+      {
+        typedef Iterator_category<_Iter1> _Category1;
+        typedef Iterator_category<_Iter2> _Category2;
+        typedef std::__lc_rai<_Category1, _Category2> __rai_type;
+
+        __glibcxx_requires_valid_range(__first1, __last1);
+        __glibcxx_requires_valid_range(__first2, __last2);
+
+        __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
+        for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
+            ++__first1, ++__first2)
+          {
+            if (__comp(*__first1, *__first2))
+              return true;
+            if (__comp(*__first2, *__first1))
+              return false;
+          }
+        return __first1 == __last1 && __first2 != __last2;
+      }
+
+  /**
+   *  @brief Finds the places in ranges which don't match.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  An input iterator.
+   *  @param  __last1   An input iterator.
+   *  @param  __first2  An input iterator.
+   *  @return   A pair of iterators pointing to the first mismatch.
+   *
+   *  This compares the elements of two ranges using @c == and returns a pair
+   *  of iterators.  The first iterator points into the first range, the
+   *  second iterator points into the second range, and the elements pointed
+   *  to by the iterators are not equal.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      pair<_Iter1, _Iter2>
+      mismatch(_Iter1 __first1, _Iter1 __last1,
+         _Iter2 __first2)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+
+        while (__first1 != __last1 && *__first1 == *__first2)
+          {
+            ++__first1;
+            ++__first2;
+          }
+        return pair<_Iter1, _Iter2>(__first1, __first2);
+      }
+
+  /**
+   *  @brief Finds the places in ranges which don't match.
+   *  @ingroup non_mutating_algorithms
+   *  @param  __first1  An input iterator.
+   *  @param  __last1   An input iterator.
+   *  @param  __first2  An input iterator.
+   *  @param __binary_pred A binary predicate @link functors
+   *         functor@endlink.
+   *  @return   A pair of iterators pointing to the first mismatch.
+   *
+   *  This compares the elements of two ranges using the binary_pred
+   *  parameter, and returns a pair
+   *  of iterators.  The first iterator points into the first range, the
+   *  second iterator points into the second range, and the elements pointed
+   *  to by the iterators are not equal.
+  */
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      pair<_Iter1, _Iter2>
+      mismatch(_Iter1 __first1, _Iter1 __last1, _Iter2 __first2, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first1, __last1);
+
+        while (__first1 != __last1 && bool(__comp(*__first1, *__first2)))
+          {
+            ++__first1;
+            ++__first2;
+          }
+        return pair<_Iter1, _Iter2>(__first1, __first2);
+      }
+
+_GLIBCXX_END_NAMESPACE_ALGO
+} // namespace std
+
diff --git a/libstdc++-v3/include/bits/cons_algofwd.h b/libstdc++-v3/include/bits/cons_algofwd.h
new file mode 100644
index 0000000..40c4907
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_algofwd.h
@@ -0,0 +1,861 @@
+// <algorithm> declarations  -*- C++ -*-
+
+// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /*
+    adjacent_find
+    all_of (C++0x)
+    any_of (C++0x)
+    binary_search
+    copy
+    copy_backward
+    copy_if (C++0x)
+    copy_n (C++0x)
+    count
+    count_if
+    equal
+    equal_range
+    fill
+    fill_n
+    find
+    find_end
+    find_first_of
+    find_if
+    find_if_not (C++0x)
+    for_each
+    generate
+    generate_n
+    includes
+    inplace_merge
+    is_heap (C++0x)
+    is_heap_until (C++0x)
+    is_partitioned (C++0x)
+    is_sorted (C++0x)
+    is_sorted_until (C++0x)
+    iter_swap
+    lexicographical_compare
+    lower_bound
+    make_heap
+    max
+    max_element
+    merge
+    min
+    min_element
+    minmax (C++0x)
+    minmax_element (C++0x)
+    mismatch
+    next_permutation
+    none_of (C++0x)
+    nth_element
+    partial_sort
+    partial_sort_copy
+    partition
+    partition_copy (C++0x)
+    partition_point (C++0x)
+    pop_heap
+    prev_permutation
+    push_heap
+    random_shuffle
+    remove
+    remove_copy
+    remove_copy_if
+    remove_if
+    replace
+    replace_copy
+    replace_copy_if
+    replace_if
+    reverse
+    reverse_copy
+    rotate
+    rotate_copy
+    search
+    search_n
+    set_difference
+    set_intersection
+    set_symmetric_difference
+    set_union
+    shuffle (C++0x)
+    sort
+    sort_heap
+    stable_partition
+    stable_sort
+    swap
+    swap_ranges
+    transform
+    unique
+    unique_copy
+    upper_bound
+  */
+
+  /**
+   * @defgroup algorithms Algorithms
+   *
+   * Components for performing algorithmic operations. Includes
+   * non-modifying sequence, modifying (mutating) sequence, sorting,
+   * searching, merge, partition, heap, set, minima, maxima, and
+   * permutation operations.
+   */
+
+  /**
+   * @defgroup mutating_algorithms Mutating
+   * @ingroup algorithms
+   */
+
+  /**
+   * @defgroup non_mutating_algorithms Non-Mutating
+   * @ingroup algorithms
+   */
+
+  /**
+   * @defgroup sorting_algorithms Sorting
+   * @ingroup algorithms
+   */
+
+  /**
+   * @defgroup set_algorithms Set Operation
+   * @ingroup sorting_algorithms
+   *
+   * These algorithms are common set operations performed on sequences
+   * that are already sorted. The number of comparisons will be
+   * linear.
+   */
+
+  /**
+   * @defgroup binary_search_algorithms Binary Search
+   * @ingroup sorting_algorithms
+   *
+   * These algorithms are variations of a classic binary search, and
+   * all assume that the sequence being searched is already sorted.
+   * 
+   * The number of comparisons will be logarithmic (and as few as
+   * possible).  The number of steps through the sequence will be
+   * logarithmic for random-access iterators (e.g., pointers), and
+   * linear otherwise.
+   * 
+   * The LWG has passed Defect Report 270, which notes: <em>The
+   * proposed resolution reinterprets binary search. Instead of
+   * thinking about searching for a value in a sorted range, we view
+   * that as an important special case of a more general algorithm:
+   * searching for the partition point in a partitioned range.  We
+   * also add a guarantee that the old wording did not: we ensure that
+   * the upper bound is no earlier than the lower bound, that the pair
+   * returned by equal_range is a valid range, and that the first part
+   * of that pair is the lower bound.</em>
+   *
+   * The actual effect of the first sentence is that a comparison
+   * functor passed by the user doesn't necessarily need to induce a
+   * strict weak ordering relation.  Rather, it partitions the range.
+   */
+
+  // adjacent_find
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    bool
+    all_of(_Iter, _Iter, _Predicate);
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    bool
+    any_of(_Iter, _Iter, _Predicate);
+
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    bool 
+    binary_search(_Iter, _Iter, const _Tp&);
+
+  template<Forward_iterator _Iter, typename _Tp, Relation<Value_type<_Iter>, _Tp> _Compare>
+    bool 
+    binary_search(_Iter, _Iter, const _Tp&, _Compare);
+
+  template<Input_iterator _In, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out 
+      copy(_In, _In, _Out);
+
+  template<Bidirectional_iterator _In, Bidirectional_iterator _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out
+      copy_backward(_In, _In, _Out);
+
+  template<Input_iterator _In, Advanceable _Out, Predicate<Value_type<_In>> _Predicate>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out
+      copy_if(_In, _In, _Out, _Predicate);
+
+  template<Input_iterator _In, Integral _Size, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out
+      copy_n(_In, _Size, _Out);
+
+  // count
+  // count_if
+
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    pair<_Iter, _Iter>
+    equal_range(_Iter, _Iter, const _Tp&);
+
+  template<Forward_iterator _Iter, typename _Tp, Relation<Value_type<_Iter>, _Tp> _Compare>
+    pair<_Iter, _Iter>
+    equal_range(_Iter, _Iter, const _Tp&, _Compare);
+
+  template<Forward_iterator _Iter, typename _Tp>
+    requires Writable<_Iter, _Tp>()
+      void 
+      fill(_Iter, _Iter, const _Tp&);
+
+  template<Advanceable _Iter, Integral _Size, typename _Tp>
+    requires Writable<_Iter, _Tp>()
+      _Iter
+      fill_n(_Iter, _Size, const _Tp&);
+
+  // find
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      _Iter1
+      find_end(_Iter1, _Iter1, _Iter2, _Iter2);
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      _Iter1
+      find_end(_Iter1, _Iter1, _Iter2, _Iter2, _Compare);
+
+  // find_first_of
+  // find_if
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    _Iter
+    find_if_not(_Iter, _Iter, _Predicate);
+
+  // for_each
+  // generate
+  // generate_n
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_ordered<_Iter1, _Iter2>()
+      bool 
+      includes(_Iter1, _Iter1, _Iter2, _Iter2);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      bool 
+      includes(_Iter1, _Iter1, _Iter2, _Iter2, _Compare);
+
+  template<Bidirectional_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      inplace_merge(_Iter, _Iter, _Iter);
+
+  template<Bidirectional_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      inplace_merge(_Iter, _Iter, _Iter, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      bool 
+      is_heap(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    bool 
+    is_heap(_Iter, _Iter, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      _Iter 
+      is_heap_until(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter 
+    is_heap_until(_Iter, _Iter, _Compare);
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    bool
+    is_partitioned(_Iter, _Iter, _Predicate);
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      bool
+      is_permutation(_Iter1, _Iter1, _Iter2);
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2>()
+      bool
+      is_permutation(_Iter1, _Iter1, _Iter2, _Compare);
+
+  template<Forward_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      bool 
+      is_sorted(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    bool 
+    is_sorted(_Iter, _Iter, _Compare);
+
+  template<Forward_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      _Iter 
+      is_sorted_until(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter 
+    is_sorted_until(_Iter, _Iter, _Compare);
+
+  template<Readable _Iter1, Readable _Iter2>
+    requires Indirectly_swappable<_Iter1, _Iter2>()
+      void 
+      iter_swap(_Iter1, _Iter2);
+
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    _Iter 
+    lower_bound(_Iter, _Iter, const _Tp&);
+
+  template<Forward_iterator _Iter, typename _Tp, Relation<Value_type<_Iter>, _Tp> _Compare>
+    _Iter 
+    lower_bound(_Iter, _Iter, const _Tp&, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      make_heap(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      make_heap(_Iter, _Iter, _Compare);
+
+  template<Weakly_ordered _Tp> 
+    const _Tp& 
+    max(const _Tp&, const _Tp&);
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    const _Tp& 
+    max(const _Tp&, const _Tp&, _Compare);
+
+  // max_element
+  // merge
+
+  template<Weakly_ordered _Tp> 
+    const _Tp& 
+    min(const _Tp&, const _Tp&);
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    const _Tp& 
+    min(const _Tp&, const _Tp&, _Compare);
+
+  // min_element
+
+  template<Weakly_ordered _Tp>
+    pair<const _Tp&, const _Tp&> 
+    minmax(const _Tp&, const _Tp&);
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    pair<const _Tp&, const _Tp&>
+    minmax(const _Tp&, const _Tp&, _Compare);
+
+  template<Forward_iterator _Iter>
+    requires Weakly_ordered<Value_type<_Iter>>()
+      pair<_Iter, _Iter>
+      minmax_element(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    pair<_Iter, _Iter>
+    minmax_element(_Iter, _Iter, _Compare);
+
+  template<Weakly_ordered _Tp>
+    _Tp
+    min(initializer_list<_Tp>);
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    _Tp
+    min(initializer_list<_Tp>, _Compare);
+
+  template<Weakly_ordered _Tp>
+    _Tp
+    max(initializer_list<_Tp>);
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    _Tp
+    max(initializer_list<_Tp>, _Compare);
+
+  template<Weakly_ordered _Tp>
+    pair<_Tp, _Tp>
+    minmax(initializer_list<_Tp>);
+
+  template<typename _Tp, Relation<_Tp> _Compare>
+    pair<_Tp, _Tp>
+    minmax(initializer_list<_Tp>, _Compare);
+
+  // mismatch
+
+  template<Bidirectional_iterator _Iter>
+    requires Sortable<_Iter>()
+      bool 
+      next_permutation(_Iter, _Iter);
+
+  template<Bidirectional_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      bool 
+      next_permutation(_Iter, _Iter, _Compare);
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    bool
+    none_of(_Iter, _Iter, _Predicate);
+
+  // nth_element
+  // partial_sort
+
+  template<Input_iterator _In, Random_access_iterator _Out>
+    requires Indirectly_copyable<_In, _Out>()
+          && Indirectly_ordered<_In,_Out>()
+          && Sortable<_Out>()
+      _Out
+      partial_sort_copy(_In, _In, _Out, _Out);
+
+  template<Input_iterator _In, Random_access_iterator _Out, typename _Compare>
+    requires Indirectly_copyable<_In, _Out>()
+          && Indirectly_comparable<_In, _Out, _Compare>()
+          && Sortable<_Out, _Compare>()
+      _Out
+      partial_sort_copy(_In, _In, _Out, _Out, _Compare);
+
+  // partition
+
+  template<Input_iterator _In, Advanceable _Out1, Advanceable _Out2, Predicate<Value_type<_In>> _Predicate>
+    requires Indirectly_copyable<_In, _Out1>() && Indirectly_copyable<_In, _Out2>()
+      pair<_Out1, _Out2>
+      partition_copy(_In, _In, _Out1, _Out2, _Predicate);
+
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    _Iter
+    partition_point(_Iter, _Iter, _Predicate);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      pop_heap(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      pop_heap(_Iter, _Iter, _Compare);
+
+  template<Bidirectional_iterator _Iter>
+    requires Sortable<_Iter>()
+      bool 
+      prev_permutation(_Iter, _Iter);
+
+  template<Bidirectional_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      bool 
+      prev_permutation(_Iter, _Iter, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      push_heap(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      push_heap(_Iter, _Iter, _Compare);
+
+  // random_shuffle
+
+  template<Forward_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    requires Permutable<_Iter>()
+      _Iter 
+      remove(_Iter, _Iter, const _Tp&);
+
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    requires Permutable<_Iter>()
+      _Iter 
+      remove_if(_Iter, _Iter, _Predicate);
+
+  template<Input_iterator _In, Advanceable _Out, Equality_comparable<Value_type<_In>> _Tp>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out
+      remove_copy(_In, _In, _Out, const _Tp&);
+
+  template<Input_iterator _In, Advanceable _Out, Predicate<Value_type<_In>> _Predicate>
+    requires Indirectly_copyable<_In, _Out>()
+    _Out 
+    remove_copy_if(_In, _In, _Out, _Predicate);
+
+  // replace
+
+  template<Input_iterator _In, Advanceable _Out, Equality_comparable<Value_type<_In>> _Tp>
+    requires Indirectly_copyable<_In, _Out>() && Writable<_Out, _Tp>()
+      _Out
+      replace_copy(_In, _In, _Out, const _Tp&, const _Tp&);
+
+  template<Input_iterator _In, Advanceable _Out, 
+           Predicate<Value_type<_In>> _Predicate, typename _Tp>
+    requires Indirectly_copyable<_In, _Out>() && Writable<_Out, _Tp>()
+      _Out 
+      replace_copy_if(_In, _In, _Out, _Predicate, const _Tp&);
+
+  // replace_if
+
+  template<Bidirectional_iterator _Iter>
+    requires Permutable<_Iter>()
+      void 
+      reverse(_Iter, _Iter);
+
+  template<Bidirectional_iterator _In, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out 
+      reverse_copy(_In, _In, _Out);
+
+  template<Forward_iterator _Iter>
+    requires Permutable<_Iter>()
+      void 
+      rotate(_Iter, _Iter, _Iter);
+
+  template<Forward_iterator _In, Advanceable _Out>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out 
+      rotate_copy(_In, _In, _In, _Out);
+
+  // search
+  // search_n
+  // set_difference
+  // set_intersection
+  // set_symmetric_difference
+  // set_union
+
+  template<Random_access_iterator _Iter, typename _UGenerator>
+    void
+    shuffle(_Iter, _Iter, _UGenerator&&);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      sort_heap(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      sort_heap(_Iter, _Iter, _Compare);
+
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    requires Permutable<_Iter>()
+      _Iter 
+      stable_partition(_Iter, _Iter, _Predicate);
+
+  template<typename _Tp> 
+    void 
+    swap(_Tp&, _Tp&) noexcept(Nothrow_movable<_Tp>());
+
+  template<typename _Tp, size_t _Nm>
+    void
+    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm]) noexcept(noexcept(swap(*__a, *__b)));
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_swappable<_Iter1, _Iter2>()
+      _Iter2 
+      swap_ranges(_Iter1, _Iter1, _Iter2);
+
+  // transform
+
+  template<Forward_iterator _Iter>
+    requires Permutable<_Iter>() && Equality_comparable<Value_type<_Iter>>()
+      _Iter 
+      unique(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    requires Permutable<_Iter>()
+      _Iter 
+      unique(_Iter, _Iter, _Compare);
+
+  // unique_copy
+
+  template<Forward_iterator _Iter, Weakly_ordered<Value_type<_Iter>> _Tp>
+    _Iter 
+    upper_bound(_Iter, _Iter, const _Tp&);
+
+  template<Forward_iterator _Iter, typename _Tp, Relation<Value_type<_Iter>, _Tp> _Compare>
+    _Iter 
+    upper_bound(_Iter, _Iter, const _Tp&, _Compare);
+
+_GLIBCXX_END_NAMESPACE_VERSION
+
+_GLIBCXX_BEGIN_NAMESPACE_ALGO
+
+  template<Forward_iterator _Iter>
+    requires Equality_comparable<Value_type<_Iter>>()
+      _Iter
+      adjacent_find(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter 
+    adjacent_find(_Iter, _Iter, _Compare);
+
+  template<Input_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    Difference_type<_Iter>
+    count(_Iter, _Iter, const _Tp&);
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    Difference_type<_Iter>
+    count_if(_Iter, _Iter, _Predicate);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      bool 
+      equal(_Iter1, _Iter1, _Iter2);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      bool 
+      equal(_Iter1, _Iter1, _Iter2, _Compare);
+
+  template<Input_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    _Iter 
+    find(_Iter, _Iter, const _Tp&);
+
+  template<Input_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      _Iter1
+      find_first_of(_Iter1, _Iter1, _Iter2, _Iter2);
+
+  template<Input_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      _Iter1
+      find_first_of(_Iter1, _Iter1, _Iter2, _Iter2, _Compare);
+
+  template<Input_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    _Iter
+    find_if(_Iter, _Iter, _Predicate);
+
+  template<Input_iterator _Iter, Function<Value_type<_Iter>> _Fn>
+    _Fn 
+    for_each(_Iter, _Iter, _Fn);
+
+  template<Forward_iterator _Iter, Generator _Generator>
+    // requires Writable<_Iter, Result_type<_Generator>>()
+      void 
+      generate(_Iter, _Iter, _Generator);
+
+  template<Advanceable _Iter, Integral _Size, Generator _Generator>
+    // requires Writable<_Iter, Result_type<_Generator>>()
+      _Iter
+      generate_n(_Iter, _Size, _Generator);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_ordered<_Iter1, _Iter2>()
+      bool 
+      lexicographical_compare(_Iter1, _Iter1, _Iter2, _Iter2);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      bool 
+      lexicographical_compare(_Iter1, _Iter1, _Iter2, _Iter2, _Compare);
+
+  template<Forward_iterator _Iter>
+    requires Weakly_ordered<Value_type<_Iter>>()
+      _Iter 
+      max_element(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter 
+    max_element(_Iter, _Iter, _Compare);
+
+  template<Input_iterator _In1, Input_iterator _In2, Advanceable _Out>
+    requires Mergeable<_In1, _In2, _Out>()
+      _Out 
+      merge(_In1, _In1, _In2, _In2, _Out);
+
+  template<Input_iterator _In1, Input_iterator _In2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_In1, _In2, _Out, _Compare>()
+      _Out 
+      merge(_In1, _In1, _In2, _In2, _Out, _Compare);
+
+  template<Forward_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      _Iter 
+      min_element(_Iter, _Iter);
+
+  template<Forward_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    _Iter 
+    min_element(_Iter, _Iter, _Compare);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      pair<_Iter1, _Iter2>
+      mismatch(_Iter1, _Iter1, _Iter2);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2, _Compare>()
+      pair<_Iter1, _Iter2>
+      mismatch(_Iter1, _Iter1, _Iter2, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      nth_element(_Iter, _Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      nth_element(_Iter, _Iter, _Iter, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      partial_sort(_Iter, _Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      partial_sort(_Iter, _Iter, _Iter, _Compare);
+
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate>
+    _Iter 
+    partition(_Iter, _Iter, _Predicate);
+
+  template<Random_access_iterator _Iter>
+    void 
+    random_shuffle(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Generator>
+    void 
+    random_shuffle(_Iter, _Iter, _Generator&&);
+
+  template<Forward_iterator _Iter, Equality_comparable<Value_type<_Iter>> _Tp>
+    requires Writable<_Iter, _Tp>()
+      void 
+      replace(_Iter, _Iter, const _Tp&, const _Tp&);
+
+  template<Forward_iterator _Iter, Predicate<Value_type<_Iter>> _Predicate, typename _Tp>
+    requires Writable<_Iter, _Tp>()
+      void 
+      replace_if(_Iter, _Iter, _Predicate, const _Tp&);
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2>
+    requires Indirectly_equal<_Iter1, _Iter2>()
+      _Iter1 
+      search(_Iter1, _Iter1, _Iter2, _Iter2);
+
+  template<Forward_iterator _Iter1, Forward_iterator _Iter2, typename _Compare>
+    requires Indirectly_comparable<_Iter1, _Iter2>()
+      _Iter1 
+      search(_Iter1, _Iter1, _Iter2, _Iter2, _Compare);
+
+  template<Forward_iterator _Iter, Integral _Size, 
+           Equality_comparable<Value_type<_Iter>> _Tp>
+    _Iter 
+    search_n(_Iter, _Iter, _Size, const _Tp&);
+
+  template<Forward_iterator _Iter, Integral _Size, typename _Tp, 
+           Relation<Value_type<_Iter>, _Tp> _Compare>
+    _Iter 
+    search_n(_Iter, _Iter, _Size, const _Tp&, _Compare);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out 
+      set_difference(_Iter1, _Iter1, _Iter2, _Iter2, _Out);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out 
+      set_difference(_Iter1, _Iter1, _Iter2, _Iter2, _Out, _Compare);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out 
+      set_intersection(_Iter1, _Iter1, _Iter2, _Iter2, _Out);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out 
+      set_intersection(_Iter1, _Iter1, _Iter2, _Iter2, _Out, _Compare);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+    _Out
+    set_symmetric_difference(_Iter1, _Iter1, _Iter2, _Iter2, _Out);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out
+      set_symmetric_difference(_Iter1, _Iter1, _Iter2, _Iter2, _Out, _Compare);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out>
+    requires Mergeable<_Iter1, _Iter2, _Out>()
+      _Out 
+      set_union(_Iter1, _Iter1, _Iter2, _Iter2, _Out);
+
+  template<Input_iterator _Iter1, Input_iterator _Iter2, Advanceable _Out, typename _Compare>
+    requires Mergeable<_Iter1, _Iter2, _Out, _Compare>()
+      _Out 
+      set_union(_Iter1, _Iter1, _Iter2, _Iter2, _Out, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      sort(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      sort(_Iter, _Iter, _Compare);
+
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void 
+      stable_sort(_Iter, _Iter);
+
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void 
+      stable_sort(_Iter, _Iter, _Compare);
+
+  template<Input_iterator _In, Advanceable _Out, Function<Value_type<_In>> _Op>
+    requires Writable<_Out, Result_type< _Op(Value_type<_In>)>>()
+    _Out 
+    transform(_In, _In, _Out, _Op);
+
+  template<Input_iterator _In1, Input_iterator _In2, Advanceable _Out, 
+           Function<Value_type<_In1>, Value_type<_In2>> _Op>
+    requires Writable<_Out, Result_type<_Op(Value_type<_In1>, Value_type<_In2>)>>()
+    _Out 
+    transform(_In1, _In1, _In2, _Out, _Op);
+
+  template<Input_iterator _In, Advanceable _Out>
+    requires Equality_comparable<Value_type<_In>>() 
+          && Indirectly_copyable<_In, _Out>()
+      _Out 
+      unique_copy(_In, _In, _Out);
+
+  template<Input_iterator _In, Advanceable _Out, Relation<Value_type<_In>> _Compare>
+    requires Indirectly_copyable<_In, _Out>()
+      _Out 
+      unique_copy(_In, _In, _Out, _Compare);
+
+_GLIBCXX_END_NAMESPACE_ALGO
+} // namespace std
+
diff --git a/libstdc++-v3/include/bits/cons_heap.h b/libstdc++-v3/include/bits/cons_heap.h
new file mode 100644
index 0000000..11911f8
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_heap.h
@@ -0,0 +1,529 @@
+// Heap implementation -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
+// 2011 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+/*
+ *
+ * Copyright (c) 1994
+ * Hewlett-Packard Company
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Hewlett-Packard Company makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ *
+ * Copyright (c) 1997
+ * Silicon Graphics Computer Systems, Inc.
+ *
+ * Permission to use, copy, modify, distribute and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and
+ * that both that copyright notice and this permission notice appear
+ * in supporting documentation.  Silicon Graphics makes no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied warranty.
+ */
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /**
+   * @defgroup heap_algorithms Heap
+   * @ingroup sorting_algorithms
+   */
+
+  template<typename _RandomAccessIterator, typename _Distance>
+    _Distance
+    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
+    {
+      _Distance __parent = 0;
+      for (_Distance __child = 1; __child < __n; ++__child)
+  {
+    if (__first[__parent] < __first[__child])
+      return __child;
+    if ((__child & 1) == 0)
+      ++__parent;
+  }
+      return __n;
+    }
+
+  template<typename _RandomAccessIterator, typename _Distance,
+     typename _Compare>
+    _Distance
+    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
+        _Compare __comp)
+    {
+      _Distance __parent = 0;
+      for (_Distance __child = 1; __child < __n; ++__child)
+  {
+    if (__comp(__first[__parent], __first[__child]))
+      return __child;
+    if ((__child & 1) == 0)
+      ++__parent;
+  }
+      return __n;
+    }
+
+  // __is_heap, a predicate testing whether or not a range is a heap.
+  // This function is an extension, not part of the C++ standard.
+  template<typename _RandomAccessIterator, typename _Distance>
+    inline bool
+    __is_heap(_RandomAccessIterator __first, _Distance __n)
+    { return std::__is_heap_until(__first, __n) == __n; }
+
+  template<typename _RandomAccessIterator, typename _Compare,
+     typename _Distance>
+    inline bool
+    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
+    { return std::__is_heap_until(__first, __n, __comp) == __n; }
+
+  template<typename _RandomAccessIterator>
+    inline bool
+    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
+    { return std::__is_heap(__first, std::distance(__first, __last)); }
+
+  template<typename _RandomAccessIterator, typename _Compare>
+    inline bool
+    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
+        _Compare __comp)
+    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }
+
+  // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap,
+  // + is_heap and is_heap_until in C++0x.
+
+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
+    void
+    __push_heap(_RandomAccessIterator __first,
+    _Distance __holeIndex, _Distance __topIndex, _Tp __value)
+    {
+      _Distance __parent = (__holeIndex - 1) / 2;
+      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
+  {
+    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));
+    __holeIndex = __parent;
+    __parent = (__holeIndex - 1) / 2;
+  }
+      *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);
+    }
+
+  /**
+   *  @brief  Push an element onto a heap.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap + element.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation pushes the element at last-1 onto the valid heap
+   *  over the range [__first,__last-1).  After completion,
+   *  [__first,__last) is a valid heap.
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      inline void
+      push_heap(_Iter __first, _Iter __last)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_heap(__first, __last - 1);
+
+        _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
+        std::__push_heap(__first, _DistanceType((__last - __first) - 1),
+             _DistanceType(0), _GLIBCXX_MOVE(__value));
+      }
+
+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
+     typename _Compare>
+    void
+    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
+    _Distance __topIndex, _Tp __value, _Compare __comp)
+    {
+      _Distance __parent = (__holeIndex - 1) / 2;
+      while (__holeIndex > __topIndex
+       && __comp(*(__first + __parent), __value))
+  {
+    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));
+    __holeIndex = __parent;
+    __parent = (__holeIndex - 1) / 2;
+  }
+      *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);
+    }
+
+  /**
+   *  @brief  Push an element onto a heap using comparison functor.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap + element.
+   *  @param  __comp   Comparison functor.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation pushes the element at __last-1 onto the valid
+   *  heap over the range [__first,__last-1).  After completion,
+   *  [__first,__last) is a valid heap.  Compare operations are
+   *  performed using comp.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      inline void
+      push_heap(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_heap_pred(__first, __last - 1, __comp);
+
+        _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
+        std::__push_heap(__first, _DistanceType((__last - __first) - 1),
+             _DistanceType(0), _GLIBCXX_MOVE(__value), __comp);
+      }
+
+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
+    void
+    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
+      _Distance __len, _Tp __value)
+    {
+      const _Distance __topIndex = __holeIndex;
+      _Distance __secondChild = __holeIndex;
+      while (__secondChild < (__len - 1) / 2)
+  {
+    __secondChild = 2 * (__secondChild + 1);
+    if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
+      __secondChild--;
+    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));
+    __holeIndex = __secondChild;
+  }
+      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
+  {
+    __secondChild = 2 * (__secondChild + 1);
+    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first
+                 + (__secondChild - 1)));
+    __holeIndex = __secondChild - 1;
+  }
+      std::__push_heap(__first, __holeIndex, __topIndex,
+           _GLIBCXX_MOVE(__value));
+    }
+
+  template<typename _RandomAccessIterator>
+    inline void
+    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
+         _RandomAccessIterator __result)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
+  _DistanceType;
+
+      _ValueType __value = _GLIBCXX_MOVE(*__result);
+      *__result = _GLIBCXX_MOVE(*__first);
+      std::__adjust_heap(__first, _DistanceType(0),
+       _DistanceType(__last - __first),
+       _GLIBCXX_MOVE(__value));
+    }
+
+  /**
+   *  @brief  Pop an element off a heap.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap.
+   *  @pre    [__first, __last) is a valid, non-empty range.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation pops the top of the heap.  The elements __first
+   *  and __last-1 are swapped and [__first,__last-1) is made into a
+   *  heap.
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      inline void
+      pop_heap(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_non_empty_range(__first, __last);
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_heap(__first, __last);
+
+        --__last;
+        std::__pop_heap(__first, __last, __last);
+      }
+
+  template<typename _RandomAccessIterator, typename _Distance,
+     typename _Tp, typename _Compare>
+    void
+    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
+      _Distance __len, _Tp __value, _Compare __comp)
+    {
+      const _Distance __topIndex = __holeIndex;
+      _Distance __secondChild = __holeIndex;
+      while (__secondChild < (__len - 1) / 2)
+  {
+    __secondChild = 2 * (__secondChild + 1);
+    if (__comp(*(__first + __secondChild),
+         *(__first + (__secondChild - 1))))
+      __secondChild--;
+    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));
+    __holeIndex = __secondChild;
+  }
+      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
+  {
+    __secondChild = 2 * (__secondChild + 1);
+    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first
+                 + (__secondChild - 1)));
+    __holeIndex = __secondChild - 1;
+  }
+      std::__push_heap(__first, __holeIndex, __topIndex, 
+           _GLIBCXX_MOVE(__value), __comp);      
+    }
+
+  template<typename _RandomAccessIterator, typename _Compare>
+    inline void
+    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
+         _RandomAccessIterator __result, _Compare __comp)
+    {
+      typedef typename iterator_traits<_RandomAccessIterator>::value_type
+  _ValueType;
+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
+  _DistanceType;
+
+      _ValueType __value = _GLIBCXX_MOVE(*__result);
+      *__result = _GLIBCXX_MOVE(*__first);
+      std::__adjust_heap(__first, _DistanceType(0),
+       _DistanceType(__last - __first),
+       _GLIBCXX_MOVE(__value), __comp);
+    }
+
+  /**
+   *  @brief  Pop an element off a heap using comparison functor.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap.
+   *  @param  __comp   Comparison functor to use.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation pops the top of the heap.  The elements __first
+   *  and __last-1 are swapped and [__first,__last-1) is made into a
+   *  heap.  Comparisons are made using comp.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      inline void
+      pop_heap(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_non_empty_range(__first, __last);
+        __glibcxx_requires_heap_pred(__first, __last, __comp);
+
+        --__last;
+        std::__pop_heap(__first, __last, __last, __comp);
+      }
+
+  /**
+   *  @brief  Construct a heap over a range.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation makes the elements in [__first,__last) into a heap.
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void
+      make_heap(_Iter __first, _Iter __last)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__last - __first < 2)
+    return;
+
+        const _DistanceType __len = __last - __first;
+        _DistanceType __parent = (__len - 2) / 2;
+        while (true)
+    {
+      _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));
+      std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value));
+      if (__parent == 0)
+        return;
+      __parent--;
+    }
+      }
+
+  /**
+   *  @brief  Construct a heap over a range using comparison functor.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap.
+   *  @param  __comp   Comparison functor to use.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation makes the elements in [__first,__last) into a heap.
+   *  Comparisons are made using __comp.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void
+      make_heap(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        typedef Value_type<_Iter> _ValueType;
+        typedef Difference_type<_Iter> _DistanceType;
+
+        __glibcxx_requires_valid_range(__first, __last);
+
+        if (__last - __first < 2)
+    return;
+
+        const _DistanceType __len = __last - __first;
+        _DistanceType __parent = (__len - 2) / 2;
+        while (true)
+    {
+      _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));
+      std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value),
+             __comp);
+      if (__parent == 0)
+        return;
+      __parent--;
+    }
+      }
+
+  /**
+   *  @brief  Sort a heap.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation sorts the valid heap in the range [__first,__last).
+  */
+  template<Random_access_iterator _Iter>
+    requires Sortable<_Iter>()
+      void
+      sort_heap(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_heap(__first, __last);
+
+        while (__last - __first > 1)
+    {
+      --__last;
+      std::__pop_heap(__first, __last, __last);
+    }
+      }
+
+  /**
+   *  @brief  Sort a heap using comparison functor.
+   *  @param  __first  Start of heap.
+   *  @param  __last   End of heap.
+   *  @param  __comp   Comparison functor to use.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation sorts the valid heap in the range [__first,__last).
+   *  Comparisons are made using __comp.
+  */
+  template<Random_access_iterator _Iter, typename _Compare>
+    requires Sortable<_Iter, _Compare>()
+      void
+      sort_heap(_Iter __first, _Iter __last, _Compare __comp)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+        __glibcxx_requires_heap_pred(__first, __last, __comp);
+
+        while (__last - __first > 1)
+    {
+      --__last;
+      std::__pop_heap(__first, __last, __last, __comp);
+    }
+      }
+
+  /**
+   *  @brief  Search the end of a heap.
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  An iterator pointing to the first element not in the heap.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation returns the last iterator i in [__first, __last) for which
+   *  the range [__first, i) is a heap.
+  */
+  template<Random_access_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      inline _Iter
+      is_heap_until(_Iter __first, _Iter __last)
+      {
+        __glibcxx_requires_valid_range(__first, __last);
+
+        return __first + std::__is_heap_until(__first, std::distance(__first,
+                     __last));
+      }
+
+  /**
+   *  @brief  Search the end of a heap using comparison functor.
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   Comparison functor to use.
+   *  @return  An iterator pointing to the first element not in the heap.
+   *  @ingroup heap_algorithms
+   *
+   *  This operation returns the last iterator i in [__first, __last) for which
+   *  the range [__first, i) is a heap.  Comparisons are made using __comp.
+  */
+  template<Random_access_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    inline _Iter
+    is_heap_until(_Iter __first, _Iter __last, _Compare __comp)
+    {
+      __glibcxx_requires_valid_range(__first, __last);
+
+      return __first + std::__is_heap_until(__first, std::distance(__first,
+                   __last),
+              __comp);
+    }
+
+  /**
+   *  @brief  Determines whether a range is a heap.
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @return  True if range is a heap, false otherwise.
+   *  @ingroup heap_algorithms
+  */
+  template<Random_access_iterator _Iter>
+    requires Totally_ordered<Value_type<_Iter>>()
+      inline bool
+      is_heap(_Iter __first, _Iter __last)
+      { return std::is_heap_until(__first, __last) == __last; }
+
+  /**
+   *  @brief  Determines whether a range is a heap using comparison functor.
+   *  @param  __first  Start of range.
+   *  @param  __last   End of range.
+   *  @param  __comp   Comparison functor to use.
+   *  @return  True if range is a heap, false otherwise.
+   *  @ingroup heap_algorithms
+  */
+  template<Random_access_iterator _Iter, Relation<Value_type<_Iter>> _Compare>
+    inline bool
+    is_heap(_Iter __first, _Iter __last, _Compare __comp)
+    { return std::is_heap_until(__first, __last, __comp) == __last; }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/include/bits/cons_iterator_base_funcs.h b/libstdc++-v3/include/bits/cons_iterator_base_funcs.h
new file mode 100644
index 0000000..ac491ea
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_iterator_base_funcs.h
@@ -0,0 +1,133 @@
+// C++11 type_traits -*- C++ -*-
+
+// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012
+// Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /**
+   *  @brief A generalization of pointer arithmetic.
+   *  @param  __first  An input iterator.
+   *  @param  __last  An input iterator.
+   *  @return  The distance between them.
+   *
+   *  Returns @c n such that __first + n == __last.  This requires
+   *  that @p __last must be reachable from @p __first.  Note that @c
+   *  n may be negative.
+   *
+   *  For random access iterators, this uses their @c + and @c - operations
+   *  and are constant time.  For other %iterator classes they are linear time.
+  */
+  template<Input_iterator _Iter>
+    inline Difference_type<_Iter>
+    distance(_Iter __first, _Iter __last)
+    {
+      Difference_type<_Iter> __n = 0;
+      while (__first != __last)
+        {
+          ++__first;
+          ++__n;
+        }
+      return __n;
+    }
+
+  template<Random_access_iterator _Iter>
+    inline Difference_type<_Iter>
+    distance(_Iter __first, _Iter __last)
+    {
+      return __last - __first;
+    }
+
+
+  /**
+   *  @brief A generalization of pointer arithmetic.
+   *  @param  __i  An input iterator.
+   *  @param  __n  The @a delta by which to change @p __i.
+   *  @return  Nothing.
+   *
+   *  This increments @p i by @p n.  For bidirectional and random access
+   *  iterators, @p __n may be negative, in which case @p __i is decremented.
+   *
+   *  For random access iterators, this uses their @c + and @c - operations
+   *  and are constant time.  For other %iterator classes they are linear time.
+  */
+  template<Input_iterator _Iter, Integral _Distance>
+    inline void
+    advance(_Iter& __i, _Distance __n)
+    {
+      while (__n--)
+        ++__i;
+    }
+
+  template<Bidirectional_iterator _Iter, Integral _Distance>
+    inline void
+    advance(_Iter& __i, _Distance __n)
+    {
+      if (__n > 0)
+        while (__n--)
+          ++__i;
+      else
+        while (__n++)
+          --__i;
+    }
+
+  template<Random_access_iterator _Iter, Integral _Distance>
+    inline void
+    advance(_Iter& __i, _Distance __n)
+    {
+      __i += __n;
+    }
+
+  /**
+   *  @brief A generalization of pointer arithmetic.
+   *  @param  __i  An input iterator.
+   *  @param  __n  The @a delta by which to change @p __i.
+   *  @return  The iterator past @p __i.
+   */
+  template<Forward_iterator _Iter>
+    inline _Iter
+    next(_Iter __x, Difference_type<_Iter> __n = 1)
+    {
+      std::advance(__x, __n);
+      return __x;
+    }
+
+  /**
+   *  @brief A generalization of pointer arithmetic.
+   *  @param  __i  An input iterator.
+   *  @param  __n  The @a delta by which to change @p __i.
+   *  @return  The iterator before @p __i.
+   */
+  template<typename _Iter>
+    inline _Iter
+    prev(_Iter __x, Difference_type<_Iter> __n = 1) 
+    {
+      std::advance(__x, -__n);
+      return __x;
+    }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/include/bits/cons_iterator_base_types.h b/libstdc++-v3/include/bits/cons_iterator_base_types.h
new file mode 100644
index 0000000..567b869
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_iterator_base_types.h
@@ -0,0 +1,299 @@
+// C++11 type_traits -*- C++ -*-
+
+// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012
+// Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+#include <bits/move.h>
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  // Iterator category
+  template<typename>
+    struct __iterator_kind 
+    { using type = __subst_fail; };
+
+  template<typename _Tp>
+    struct __iterator_kind<_Tp*> 
+    { using type = std::random_access_iterator_tag; };
+
+  template<typename _Iter>
+    requires __is_valid_type(typename _Iter::iterator_category)
+      struct __iterator_kind<_Iter> 
+      { using type = typename _Iter::iterator_category; };
+
+  template<typename _Iter>
+    using Iterator_category = typename __iterator_kind<_Iter>::type;
+
+
+  // Value type
+  template<typename _Tp>
+    struct __value_type 
+    { using type = __subst_fail; };
+
+  template<typename _Tp>
+    requires __is_valid_type(typename _Tp::value_type)
+      struct __value_type<_Tp> 
+      { using type = typename _Tp::value_type; };
+
+  // Any type claiming that their value type is void lies.
+  template<typename _Tp>
+    requires __is_valid_type(typename _Tp::value_type) 
+          && __is_same(typename _Tp::value_type, void)
+    struct __value_type<_Tp>
+    { using type = __subst_fail; };
+
+  template<typename _Tp>
+    struct __value_type<_Tp*>
+    { using type = _Tp; };
+
+  template<typename _Tp>
+    struct __value_type<const _Tp*>
+    { using type = _Tp; };
+
+  // Value_type
+  template<typename _Tp>
+    using Value_type = typename __value_type<_Tp>::type;
+
+
+  // Difference type
+  template<typename _Tp>
+    struct __difference_type
+    { using type = __subst_fail; };
+
+  template<typename _Tp>
+    requires __is_valid_type(typename _Tp::difference_type)
+      struct __difference_type<_Tp>
+      { using type = typename _Tp::difference_type; };
+
+  template<typename _Tp>
+    struct __difference_type<_Tp*>
+    { using type = std::ptrdiff_t; };
+
+  template<typename _Tp>
+    using Difference_type = typename __difference_type<_Tp>::type;
+
+
+  // Read/write concepts
+  template<typename _Iter>
+    constexpr bool Readable()
+    {
+      __declval _Iter __i;
+      return Valid_type<Value_type<_Iter>>()
+          && __is_valid_expr(const Value_type<_Iter>& = {*__i});
+    }
+
+  template<typename _Iter, typename _Tp>
+    constexpr bool Writable()
+    {
+      __declval _Iter __i;
+      __declval _Tp __x;
+      return __is_valid_expr(*__i = std::forward<_Tp>(__x));
+    }
+
+  template<typename _Iter>
+    constexpr bool Permutable()
+    {
+      return Readable<_Iter>()
+          && Movable<Value_type<_Iter>>()
+          && Writable<_Iter, Value_type<_Iter>&&>();
+    }
+
+  template<typename _Iter>
+    constexpr bool Mutable()
+    {
+      return Permutable<_Iter>()
+          && Copyable<Value_type<_Iter>>()
+          && Writable<_Iter, const Value_type<_Iter>&>();
+    }
+
+
+  // Traversal concepts
+
+  // Similar to WeaklyIncrementable from Palo Alto, but further weakened so
+  // that we require no associated difference type.
+  template<typename _Iter>
+    constexpr bool Advanceable()
+    {
+      __declval _Iter __i;
+      return __is_valid_expr(_Iter& == {++__i})
+          && __is_valid_expr(__i++);
+    }
+
+  template<typename _Iter>
+    constexpr bool Incrementable()
+    {
+      __declval _Iter __i;
+      return __is_valid_expr(_Iter& == {++__i})
+          && __is_valid_expr(_Iter == {__i++})
+          && Equality_comparable<_Iter>()
+          && Valid_type<Difference_type<_Iter>>();
+    }
+
+
+  // Iterator concepts
+  template<typename _Iter>
+    constexpr bool Input_iterator()
+    {
+      return Readable<_Iter>() 
+          && Advanceable<_Iter>() 
+          && Equality_comparable<_Iter>()
+          && Valid_type<Difference_type<_Iter>>();
+    }
+
+  template<typename _Iter, typename _Tp>
+    constexpr bool Output_iterator()
+    {
+      return Writable<_Iter, _Tp>() && Advanceable<_Iter>();
+    }
+
+  template<typename _Iter>
+    constexpr bool Forward_iterator()
+    {
+      return Readable<_Iter>() 
+          && Incrementable<_Iter>()
+          && Derived<Iterator_category<_Iter>, std::forward_iterator_tag>();
+    }
+
+  template<typename _Iter>
+    constexpr bool Bidirectional_iterator()
+    {
+      __declval _Iter __i;
+      return Forward_iterator<_Iter>()
+          && __is_valid_expr(_Iter& == {--__i})
+          && __is_valid_expr(_Iter == {__i--});
+    }
+
+  template<typename _Iter>
+    constexpr bool Random_access_iterator()
+    {
+      __declval _Iter __i, __j;
+      __declval Difference_type<_Iter> __n;
+      return Bidirectional_iterator<_Iter>()
+          && __is_valid_expr(_Iter& == {__i += __n})
+          && __is_valid_expr(_Iter == {__i +  __n})
+          && __is_valid_expr(_Iter == {__n +  __i})
+          && __is_valid_expr(_Iter& == {__i -= __n})
+          && __is_valid_expr(_Iter == {__i - __n})
+          && __is_valid_expr(Difference_type<_Iter> == {__i - __j})
+          && __is_valid_expr(decltype(*__i) == {__i[__n]});
+    }
+
+
+  // Algorithm-specific concepts
+
+
+
+  // TODO: Should it be the case that move assigning through an iterator also
+  // requires the underlying value type to be movable?
+  template<typename _In, typename _Out>
+    constexpr bool Indirectly_movable()
+    {
+      return Input_iterator<_In>()
+          && Output_iterator<_Out, Value_type<_In>&&>();
+    }
+
+  // True when values can be copied from In to Out. 
+  template<typename _In, typename _Out>
+    constexpr bool Indirectly_copyable()
+    {
+      return Indirectly_movable<_In, _Out>()
+          && Output_iterator<_Out, Value_type<_In>>();
+    }
+
+  // This was cut from the Palo Alto TR, but it seems reasonable to
+  // include it here.
+  //
+  // FIXME: The std requirements only require that the value types
+  // are swappable, not that either type is specifically move assignable.
+  // This implementation will fail wherever swap is explicitly overloaded
+  // for non-copyable/non-movable types (see movable.cc in the swap_ranges
+  // test).
+  template<typename _Iter1, typename _Iter2>
+    constexpr bool Indirectly_swappable()
+    {
+      return Indirectly_movable<_Iter1, _Iter2>()
+          && Indirectly_movable<_Iter2, _Iter1>()
+          && Movable<Value_type<_Iter1>>() 
+          && Movable<Value_type<_Iter2>>();
+    }
+
+  template<typename _Iter1, typename _Iter2>
+    constexpr bool Indirectly_equal()
+    {
+      return Input_iterator<_Iter1>() 
+          && Input_iterator<_Iter2>()
+          && Equality_comparable<Value_type<_Iter1>, Value_type<_Iter2>>();
+    }
+
+  template<typename _Iter1, typename _Iter2>
+    constexpr bool Indirectly_ordered()
+    {
+      return Input_iterator<_Iter1>() 
+          && Input_iterator<_Iter2>()
+          && Weakly_ordered<Value_type<_Iter1>, Value_type<_Iter2>>();
+    }
+
+  template<typename _Iter1, typename _Iter2, typename _Compare>
+    constexpr bool Indirectly_comparable()
+    {
+      return Input_iterator<_Iter1>() 
+          && Input_iterator<_Iter2>()
+          && Relation<_Compare, Value_type<_Iter1>, Value_type<_Iter2>>();
+    }
+
+  template<typename _Iter>
+    constexpr bool Sortable()
+    {
+      return Forward_iterator<_Iter>()
+          && Permutable<_Iter>()
+          && Weakly_ordered<Value_type<_Iter>>();
+    }
+
+  template<typename _Iter, typename _Compare>
+    constexpr bool Sortable()
+    {
+      return Forward_iterator<_Iter>()
+          && Permutable<_Iter>()
+          && Relation<_Compare, Value_type<_Iter>>();
+    }
+
+  template<typename _Iter1, typename _Iter2, typename _Out>
+    constexpr bool Mergeable()
+    {
+      return Indirectly_ordered<_Iter1, _Iter2>()
+          && Indirectly_copyable<_Iter1, _Out>()
+          && Indirectly_copyable<_Iter2, _Out>();
+    }
+
+  template<typename _Iter1, typename _Iter2, typename _Out, typename _Comp>
+    constexpr bool Mergeable()
+    {
+      return Indirectly_comparable<_Iter1, _Iter2, _Comp>()
+          && Indirectly_copyable<_Iter1, _Out>()
+          && Indirectly_copyable<_Iter2, _Out>();
+    }
+
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/include/bits/cons_type_traits.h b/libstdc++-v3/include/bits/cons_type_traits.h
new file mode 100644
index 0000000..7017842
--- /dev/null
+++ b/libstdc++-v3/include/bits/cons_type_traits.h
@@ -0,0 +1,1976 @@
+// C++11 type_traits -*- C++ -*-
+
+// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012
+// Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// Under Section 7 of GPL version 3, you are granted additional
+// permissions described in the GCC Runtime Library Exception, version
+// 3.1, as published by the Free Software Foundation.
+
+// You should have received a copy of the GNU General Public License and
+// a copy of the GCC Runtime Library Exception along with this program;
+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+// <http://www.gnu.org/licenses/>.
+
+
+namespace std _GLIBCXX_VISIBILITY(default)
+{
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+
+  /**
+   * @defgroup metaprogramming Metaprogramming and type traits
+   * @ingroup utilities
+   *
+   * Template utilities for compile-time introspection and modification,
+   * including type classification traits, type property inspection traits
+   * and type transformation traits.
+   *
+   * @{
+   */
+
+  /// integral_constant
+  template<typename _Tp, _Tp __v>
+    struct integral_constant
+    {
+      static constexpr _Tp                  value = __v;
+      typedef _Tp                           value_type;
+      typedef integral_constant<_Tp, __v>   type;
+      constexpr operator value_type() { return value; }
+    };
+  
+  /// The type used as a compile-time boolean with true value.
+  typedef integral_constant<bool, true>     true_type;
+
+  /// The type used as a compile-time boolean with false value.
+  typedef integral_constant<bool, false>    false_type;
+
+  template<typename _Tp, _Tp __v>
+    constexpr _Tp integral_constant<_Tp, __v>::value;
+
+  // Meta programming helper types.
+
+  // FIXME: These should go away.
+
+  template<bool, typename, typename>
+    struct conditional;
+
+  template<typename...>
+    struct __or_;
+
+  template<>
+    struct __or_<>
+    : public false_type
+    { };
+
+  template<typename _B1>
+    struct __or_<_B1>
+    : public _B1
+    { };
+
+  template<typename _B1, typename _B2>
+    struct __or_<_B1, _B2>
+    : public conditional<_B1::value, _B1, _B2>::type
+    { };
+
+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
+    struct __or_<_B1, _B2, _B3, _Bn...>
+    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
+    { };
+
+  template<typename...>
+    struct __and_;
+
+  template<>
+    struct __and_<>
+    : public true_type
+    { };
+
+  template<typename _B1>
+    struct __and_<_B1>
+    : public _B1
+    { };
+
+  template<typename _B1, typename _B2>
+    struct __and_<_B1, _B2>
+    : public conditional<_B1::value, _B2, _B1>::type
+    { };
+
+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
+    struct __and_<_B1, _B2, _B3, _Bn...>
+    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
+    { };
+
+  template<typename _Pp>
+    struct __not_
+    : public integral_constant<bool, !_Pp::value>
+    { };
+
+  // FIXME: Get rid of this too!
+  struct __sfinae_types
+  {
+    typedef char __one;
+    typedef struct { char __arr[2]; } __two;
+  };
+
+  // Indicates substitution failure.
+  struct __subst_fail 
+  { using type = __subst_fail; };
+
+  template<typename>
+    struct add_const;
+
+  template<typename>
+    struct add_lvalue_reference;
+
+  template<typename>
+    struct add_rvalue_reference;
+
+  template<typename>
+    struct remove_cv;
+
+  template<typename>
+    struct remove_reference;
+
+  template<typename>
+    struct __remove_cv_reference;
+
+  template<typename>
+    struct remove_all_extents;
+
+  template<typename>
+    struct decay;
+
+  // Helper transformations. Some of these have corresponding public
+  // type functions.
+
+  template<typename _Tp>
+    using __referent = typename remove_reference<_Tp>::type;
+
+  template<typename _Tp>
+    using __decay = typename decay<_Tp>::type;
+
+  template<typename _Tp>
+    using __make_lref = typename add_lvalue_reference<_Tp>::type;
+
+  template<typename _Tp>
+    using __make_cref = __make_lref<typename add_const<_Tp>::type>;
+
+  template<typename _Tp>
+    using __make_rref = typename add_rvalue_reference<_Tp>::type;
+
+  template<typename _Tp>
+    using __unqualified_type = typename remove_cv<_Tp>::type;
+
+  template<typename _Tp>
+    using __object_type = typename __remove_cv_reference<_Tp>::type;
+
+  template<typename _Tp>
+    using __element_type = typename remove_all_extents<_Tp>::type;
+
+  // primary type categories.
+
+  // is_void
+  template<typename _Tp>
+    constexpr bool __check_void() { return __is_same(_Tp, void); }
+
+  template<typename _Tp>
+    struct is_void 
+    : integral_constant<bool, __check_void<__unqualified_type<_Tp>>()>
+    { };
+
+
+  template<typename _Tp>
+    constexpr bool __check_integral()
+    {
+      return __is_same(_Tp, bool)
+          || __is_same(_Tp, char)
+          || __is_same(_Tp, signed char)
+          || __is_same(_Tp, unsigned char)
+#ifdef _GLIBCXX_USE_WCHAR_T
+          || __is_same(_Tp, wchar_t)
+#endif
+          || __is_same(_Tp, char16_t)
+          || __is_same(_Tp, char32_t)
+          || __is_same(_Tp, short)
+          || __is_same(_Tp, unsigned short)
+          || __is_same(_Tp, int)
+          || __is_same(_Tp, unsigned int)
+          || __is_same(_Tp, long)
+          || __is_same(_Tp, unsigned long)
+          || __is_same(_Tp, long long)
+          || __is_same(_Tp, unsigned long long)
+#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
+          || __is_same(_Tp, __int128_t)
+          || __is_same(_Tp, unsigned __int128_t)
+#endif
+          ;
+    }
+
+  /// is_integral
+  template<typename _Tp>
+    struct is_integral
+    : integral_constant<bool, __check_integral<__unqualified_type<_Tp>>()>
+    { };
+
+
+
+  template<typename _Tp>
+    constexpr bool __check_floating_point()
+    {
+      return __is_same(_Tp, float)
+          || __is_same(_Tp, double)
+          || __is_same(_Tp, long double)
+#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_FLOAT128)
+          || __is_same(_Tp, __float128)
+#endif
+          ;
+    }
+
+  /// is_floating_point
+  template<typename _Tp>
+    struct is_floating_point
+    : integral_constant<bool, __check_floating_point<__unqualified_type<_Tp>>()>
+    { };
+
+
+  /// is_array
+  template<typename>
+    struct is_array
+    : false_type { };
+
+  template<typename _Tp, std::size_t _Size>
+    struct is_array<_Tp[_Size]>
+    : true_type { };
+
+  template<typename _Tp>
+    struct is_array<_Tp[]>
+    : true_type { };
+
+
+  template<typename>
+    struct __is_pointer_helper
+    : false_type { };
+
+  template<typename _Tp>
+    struct __is_pointer_helper<_Tp*>
+    : true_type { };
+
+
+  /// is_pointer
+  template<typename _Tp>
+    struct is_pointer
+    : integral_constant<bool, __is_pointer_helper<__unqualified_type<_Tp>>::value>
+    { };
+
+
+  /// is_lvalue_reference
+  template<typename>
+    struct is_lvalue_reference
+    : false_type { };
+
+  template<typename _Tp>
+    struct is_lvalue_reference<_Tp&>
+    : true_type { };
+
+
+  /// is_rvalue_reference
+  template<typename>
+    struct is_rvalue_reference
+    : false_type 
+    { };
+
+  template<typename _Tp>
+    struct is_rvalue_reference<_Tp&&>
+    : true_type { };
+
+  template<typename>
+    struct is_function;
+
+  template<typename>
+    struct __is_member_object_pointer_helper
+    : false_type { };
+
+  template<typename _Tp, typename _Cp>
+    struct __is_member_object_pointer_helper<_Tp _Cp::*>
+    : integral_constant<bool, !is_function<_Tp>::value> 
+    { };
+
+
+  /// is_member_object_pointer
+  template<typename _Tp>
+    struct is_member_object_pointer
+    : integral_constant<bool, __is_member_object_pointer_helper<__unqualified_type<_Tp>>::value>
+    { };
+
+  template<typename>
+    struct __is_member_function_pointer_helper
+    : false_type { };
+
+  template<typename _Tp, typename _Cp>
+    struct __is_member_function_pointer_helper<_Tp _Cp::*>
+    : integral_constant<bool, is_function<_Tp>::value> { };
+
+
+  /// is_member_function_pointer
+  template<typename _Tp>
+    struct is_member_function_pointer
+    : integral_constant<bool, (__is_member_function_pointer_helper<__unqualified_type<_Tp>>::value)>
+    { };
+
+
+  /// is_enum
+  template<typename _Tp>
+    struct is_enum
+    : integral_constant<bool, __is_enum(_Tp)>
+    { };
+
+
+  /// is_union
+  template<typename _Tp>
+    struct is_union
+    : integral_constant<bool, __is_union(_Tp)>
+    { };
+
+
+  /// is_class
+  template<typename _Tp>
+    struct is_class
+    : integral_constant<bool, __is_class(_Tp)>
+    { };
+
+
+  /// is_function
+  template<typename>
+    struct is_function
+    : false_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes...)>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes......)>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes...) const>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes......) const>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes...) volatile>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes......) volatile>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes...) const volatile>
+    : true_type { };
+
+  template<typename _Res, typename... _ArgTypes>
+    struct is_function<_Res(_ArgTypes......) const volatile>
+    : true_type { };
+
+  template<typename>
+    struct __is_nullptr_t_helper
+    : false_type { };
+
+  template<>
+    struct __is_nullptr_t_helper<std::nullptr_t>
+    : true_type { };
+
+  // __is_nullptr_t (extension).
+  template<typename _Tp>
+    struct __is_nullptr_t
+    : integral_constant<bool, __is_nullptr_t_helper<__unqualified_type<_Tp>>::value>
+    { };
+
+
+  // composite type categories.
+
+  /// is_reference
+  template<typename _Tp>
+    struct is_reference
+    : integral_constant<bool, is_lvalue_reference<_Tp>::value ||
+                              is_rvalue_reference<_Tp>::value>
+    { };
+
+
+  /// is_arithmetic
+  template<typename _Tp>
+    struct is_arithmetic
+    : integral_constant<bool, is_integral<_Tp>::value || 
+                              is_floating_point<_Tp>::value>
+    { };
+
+
+  /// is_fundamental
+  template<typename _Tp>
+    struct is_fundamental
+    : integral_constant<bool, is_arithmetic<_Tp>::value || is_void<_Tp>::value>
+    { };
+
+
+  /// is_object
+  template<typename _Tp>
+    struct is_object
+    : integral_constant<bool, !(is_function<_Tp>::value  || 
+                                is_reference<_Tp>::value || 
+                                is_void<_Tp>::value)>
+    { };
+
+  template<typename>
+    struct is_member_pointer;
+
+  /// is_scalar
+  template<typename _Tp>
+    struct is_scalar
+    : integral_constant<bool, is_arithmetic<_Tp>::value     || 
+                              is_enum<_Tp>::value           ||
+                              is_pointer<_Tp>::value        ||
+                              is_member_pointer<_Tp>::value ||
+                              __is_nullptr_t<_Tp>::value>
+    { };
+
+  
+  /// is_compound
+  template<typename _Tp>
+    struct is_compound
+    : integral_constant<bool, !is_fundamental<_Tp>::value> { };
+
+  
+  template<typename _Tp>
+    struct __is_member_pointer_helper
+    : false_type { };
+
+  template<typename _Tp, typename _Cp>
+    struct __is_member_pointer_helper<_Tp _Cp::*>
+    : true_type { };
+
+  /// is_member_pointer
+  template<typename _Tp>
+    struct is_member_pointer
+    : integral_constant<bool, __is_member_pointer_helper<__unqualified_type<_Tp>>::value>
+    { };
+
+
+  // type properties.
+
+  /// is_const
+  template<typename>
+    struct is_const
+    : false_type { };
+
+  template<typename _Tp>
+    struct is_const<_Tp const>
+    : true_type { };
+  
+
+  /// is_volatile
+  template<typename>
+    struct is_volatile
+    : false_type { };
+
+  template<typename _Tp>
+    struct is_volatile<_Tp volatile>
+    : true_type { };
+
+
+  ///__ is_qualified
+  template<typename _Tp>
+    struct __is_qualified 
+    : integral_constant<bool, is_const<_Tp>::value || 
+                              is_volatile<_Tp>::value> 
+    { };
+
+
+  /// __is_unqualified
+  template<typename _Tp>
+    struct __is_unqualified 
+    : integral_constant<bool, !__is_qualified<_Tp>::value> { };
+
+
+  /// is_trivial
+  template<typename _Tp>
+    struct is_trivial
+    : integral_constant<bool, __is_trivial(_Tp)>
+    { };
+
+  
+  // is_trivially_copyable (still unimplemented)
+
+  
+  /// is_standard_layout
+  template<typename _Tp>
+    struct is_standard_layout
+    : integral_constant<bool, __is_standard_layout(_Tp)>
+    { };
+
+  
+  /// is_pod
+  // Could use is_standard_layout && is_trivial instead of the builtin.
+  template<typename _Tp>
+    struct is_pod
+    : integral_constant<bool, __is_pod(_Tp)>
+    { };
+
+  
+  /// is_literal_type
+  template<typename _Tp>
+    struct is_literal_type
+    : integral_constant<bool, __is_literal_type(_Tp)>
+    { };
+
+  
+  /// is_empty
+  template<typename _Tp>
+    struct is_empty
+    : integral_constant<bool, __is_empty(_Tp)>
+    { };
+
+  
+  /// is_polymorphic
+  template<typename _Tp>
+    struct is_polymorphic
+    : integral_constant<bool, __is_polymorphic(_Tp)>
+    { };
+
+  
+  /// is_abstract
+  template<typename _Tp>
+    struct is_abstract
+    : integral_constant<bool, __is_abstract(_Tp)>
+    { };
+
+
+  /// is_signed
+  template<typename _Tp>
+    struct is_signed 
+    : false_type { };
+
+  template<typename _Tp>
+    requires is_integral<_Tp>::value
+      struct is_signed<_Tp> 
+      : integral_constant<bool, (_Tp(-1) < _Tp(0))> { };
+
+  template<typename _Tp>
+    requires is_floating_point<_Tp>::value
+      struct is_signed<_Tp> 
+      : true_type { };
+
+
+  /// is_unsigned
+  template<typename _Tp>
+    struct is_unsigned 
+    : false_type { };
+
+  template<typename _Tp>
+    requires is_integral<_Tp>::value
+      struct is_unsigned<_Tp> 
+      : integral_constant<bool, (_Tp(0) < _Tp(-1))> { };
+
+
+
+  // destructible and constructible type properties
+
+  template<typename>
+    struct add_rvalue_reference;
+
+  /**
+   *  @brief  Utility to simplify expressions used in unevaluated operands
+   *  @ingroup utilities
+   */
+  template<typename _Tp>
+    typename add_rvalue_reference<_Tp>::type declval() noexcept;
+
+
+  template<typename, unsigned = 0>
+    struct extent;
+
+  template<typename>
+    struct remove_all_extents;
+
+
+  template<typename _Tp>
+    struct __is_array_known_bounds
+    : integral_constant<bool, (extent<_Tp>::value > 0)>
+    { };
+
+  template<typename _Tp>
+    struct __is_array_unknown_bounds
+    : integral_constant<bool, is_array<_Tp>::value && !extent<_Tp>::value>
+    { };
+    
+
+  // In N3290 is_destructible does not say anything about function
+  // types and abstract types, see LWG 2049. This implementation
+  // describes function types as non-destructible and all complete
+  // object types as destructible, iff the explicit destructor
+  // call expression is wellformed.
+  template<typename _Tp>
+    constexpr bool __check_destructible()
+    {
+      return __is_valid_expr(declval<_Tp&>().~_Tp());
+    }
+
+  template<typename _Tp>
+    struct is_destructible
+    : integral_constant<bool, __check_destructible<__element_type<_Tp>>()> { };
+
+  template<typename _Tp>
+    requires is_void<_Tp>::value
+          || is_function<_Tp>::value
+          || __is_array_unknown_bounds<_Tp>::value
+      struct is_destructible<_Tp>
+      : false_type { };
+
+  template<typename _Tp>
+    requires is_reference<_Tp>::value
+    struct is_destructible<_Tp>
+    : true_type { };
+
+
+  // is_nothrow_destructible requires that is_destructible is
+  // satisfied as well. We realize this by specialing the trait
+  // for the cases where _Tp is and is not destructible.
+
+  template<typename _Tp>
+    constexpr bool __check_nothrow_destructible()
+    {
+      return noexcept(declval<_Tp&>().~_Tp());
+    }
+
+  template<typename _Tp>
+    struct __is_nothrow_destructible_impl
+    : integral_constant<bool, __check_nothrow_destructible<__element_type<_Tp>>()> { };
+
+  template<typename _Tp>
+    requires is_reference<_Tp>::value
+      struct __is_nothrow_destructible_impl<_Tp>
+      : true_type { };
+
+  template<typename _Tp>
+    struct is_nothrow_destructible
+    : false_type { };
+
+  template<typename _Tp>
+    requires is_destructible<_Tp>::value
+      struct is_nothrow_destructible<_Tp>
+      : __is_nothrow_destructible_impl<_Tp> { };
+
+
+
+
+  // True when _Tp is the base of _Up, but not the same as _Up.
+  template<typename _Tp, typename _Up>
+    constexpr bool __is_strict_base_of()
+    {
+      return __is_base_of(_Tp, _Up) && !__is_same(_Tp, _Up);
+    }
+
+  // True when the conversion from _From to _To is an invalid downcast.
+  template<typename _From, typename _To>
+    constexpr bool __is_base_to_derived_ref()
+    {
+      using _Src = __object_type<_From>;
+      using _Tgt = __object_type<_To>;
+      return !is_function<_Src>::value && __is_strict_base_of<_Src, _Tgt>();
+    }
+
+  // True when the conversion from _From to _To is from an lvalue to rvalue.
+  template<typename _From, typename _To>
+    constexpr bool __is_lvalue_to_rvalue_ref()
+    {
+      using _Src = __object_type<_From>;
+      using _Tgt = __object_type<_To>;
+      return is_lvalue_reference<_From>::value
+          && is_rvalue_reference<_To>::value
+          && !is_function<_Src>::value
+          && (__is_same(_Src, _Tgt) || __is_base_of(_Tgt, _Src));
+    }
+
+  // True if the conversion from reference types _From to _To is invalid.
+  template<typename _From, typename _To>
+    constexpr bool __is_convertible_ref()
+    {
+      return !__is_base_to_derived_ref<_From, _To>()
+          && !__is_lvalue_to_rvalue_ref<_From, _To>();
+    }
+
+
+
+  template<typename _Tp, typename... _Args>
+    constexpr bool __check_constructible()
+    {
+      return __is_valid_expr(::new _Tp(std::declval<_Args>()...));
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool __check_static_castable()
+    {
+      return __is_valid_expr(static_cast<_Up>(std::declval<_Tp>()));
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool __check_constructible_ref()
+    {
+      return __check_static_castable<_Up, _Tp>() 
+          && __is_convertible_ref<_Up, _Tp>();
+    }
+
+
+  template<typename _Tp, typename... _Args>
+    struct __is_constructible_impl
+    : integral_constant<bool,__check_constructible<_Tp, _Args...>()> { };
+
+  template<typename _Tp, typename _Up>
+    requires std::is_reference<_Tp>::value
+      struct __is_constructible_impl<_Tp, _Up>
+      : integral_constant<bool,  __check_constructible_ref<_Tp, _Up>()> { };
+
+
+  template<typename _Tp, typename... _Args>
+    struct is_constructible
+    : integral_constant<bool, is_destructible<_Tp>::value &&
+                              __is_constructible_impl<_Tp, _Args...>::value>
+    { };
+
+
+  template<typename _Tp>
+    struct is_default_constructible
+    : is_constructible<_Tp>
+    { };
+
+
+  /// is_copy_constructible
+  template<typename _Tp>
+    struct is_copy_constructible
+    : is_constructible<_Tp, const _Tp&>
+    { };
+
+  template<typename _Tp>
+    requires is_void<_Tp>::value
+      struct is_copy_constructible<_Tp>
+      : false_type { };
+
+
+  template<typename _Tp, bool = is_void<_Tp>::value>
+    struct __is_move_constructible_impl;
+
+  template<typename _Tp>
+    struct __is_move_constructible_impl<_Tp, true>
+    : public false_type { };
+
+
+  /// is_move_constructible
+  template<typename _Tp>
+    struct is_move_constructible
+    : public is_constructible<_Tp, _Tp&&>
+    { };
+
+  template<typename _Tp>
+    requires is_void<_Tp>::value
+      struct is_move_constructible<_Tp>
+      : false_type { };
+
+
+  template<typename _Tp, typename... _Args>
+    struct is_nothrow_constructible_impl
+    : integral_constant<bool, noexcept(::new _Tp(declval<_Args>()...))> { };
+
+  template<typename _Tp, typename _Up>
+    struct is_nothrow_constructible_impl<_Tp, _Up>
+    : integral_constant<bool, noexcept(static_cast<_Tp>(declval<_Up>()))> { };
+
+  /// is_nothrow_constructible
+  template<typename _Tp, typename... _Args>
+    struct is_nothrow_constructible
+    : false_type { };
+
+  template<typename _Tp, typename... _Args>
+    requires is_constructible<_Tp, _Args...>::value
+      struct is_nothrow_constructible<_Tp, _Args...>
+      : is_nothrow_constructible_impl<_Tp, _Args...> { };
+
+
+  /// is_nothrow_default_constructible
+  template<typename _Tp>
+    struct is_nothrow_default_constructible
+    : is_nothrow_constructible<_Tp> { };
+
+  
+  /// is_nothrow_copy_constructible
+  template<typename _Tp>
+    struct is_nothrow_copy_constructible
+    : is_nothrow_constructible<_Tp, __make_cref<_Tp>> { };
+
+
+  /// is_nothrow_move_constructible
+  template<typename _Tp>
+    struct is_nothrow_move_constructible
+    : is_nothrow_constructible<_Tp, __make_rref<_Tp>> { };
+
+
+
+  template<typename _Tp, typename _Up>
+    constexpr bool __check_assignable()
+    {
+      return __is_valid_expr(declval<_Tp>() = declval<_Up>());
+    }
+
+  /// is_assignable
+  template<typename _Tp, typename _Up>
+    struct is_assignable
+    : integral_constant<bool, __check_assignable<_Tp, _Up>()> { };
+
+
+  /// is_copy_assignable
+  template<typename _Tp>
+    struct is_copy_assignable
+    : is_assignable<__make_lref<_Tp>, __make_cref<_Tp>> { };
+
+
+  /// is_move_assignable
+  template<typename _Tp>
+    struct is_move_assignable
+    : is_assignable<__make_lref<_Tp>, __make_rref<_Tp>> { };
+
+
+  /// is_nothrow_assignable
+  template<typename _Tp, typename _Up>
+    struct is_nothrow_assignable
+    : false_type { };
+
+  template<typename _Tp, typename _Up>
+    requires is_assignable<_Tp, _Up>::value
+      struct is_nothrow_assignable<_Tp, _Up>
+      : integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())> { };
+
+
+  /// is_nothrow_copy_assignable
+  template<typename _Tp>
+    struct is_nothrow_copy_assignable
+    : is_nothrow_assignable<__make_lref<_Tp>, __make_cref<_Tp>> { };
+
+
+  /// is_nothrow_move_assignable
+  template<typename _Tp>
+    struct is_nothrow_move_assignable
+    : is_nothrow_assignable<__make_lref<_Tp>, __make_rref<_Tp>> { };
+
+
+  /// is_trivially_constructible (still unimplemented)
+  
+  /// is_trivially_default_constructible (still unimplemented)
+
+  /// is_trivially_copy_constructible (still unimplemented)
+
+  /// is_trivially_move_constructible (still unimplemented)
+
+  /// is_trivially_assignable (still unimplemented)
+
+  /// is_trivially_copy_assignable (still unimplemented)
+
+  /// is_trivially_move_assignable (still unimplemented)
+
+  /// is_trivially_destructible
+  template<typename _Tp>
+    struct is_trivially_destructible
+    : integral_constant<bool, is_destructible<_Tp>::value && 
+                              __has_trivial_destructor(_Tp)>
+    { };
+
+  /// has_trivial_default_constructor (temporary legacy)
+  template<typename _Tp>
+    struct has_trivial_default_constructor
+    : integral_constant<bool, __has_trivial_constructor(_Tp)> { };
+
+  /// has_trivial_copy_constructor (temporary legacy)
+  template<typename _Tp>
+    struct has_trivial_copy_constructor
+    : integral_constant<bool, __has_trivial_copy(_Tp)> { };
+
+  /// has_trivial_copy_assign (temporary legacy)
+  template<typename _Tp>
+    struct has_trivial_copy_assign
+    : integral_constant<bool, __has_trivial_assign(_Tp)> { };
+
+  /// has_virtual_destructor
+  template<typename _Tp>
+    struct has_virtual_destructor
+    : integral_constant<bool, __has_virtual_destructor(_Tp)> { };
+
+  
+  // type property queries.
+
+  /// alignment_of
+  template<typename _Tp>
+    struct alignment_of
+    : integral_constant<std::size_t, __alignof__(_Tp)> { };
+  
+  /// rank
+  template<typename>
+    struct rank
+    : integral_constant<std::size_t, 0> { };
+   
+  template<typename _Tp, std::size_t _Size>
+    struct rank<_Tp[_Size]>
+    : integral_constant<std::size_t, 1 + rank<_Tp>::value> { };
+
+  template<typename _Tp>
+    struct rank<_Tp[]>
+    : integral_constant<std::size_t, 1 + rank<_Tp>::value> { };
+
+  /// extent
+  template<typename, unsigned _Uint>
+    struct extent
+    : integral_constant<std::size_t, 0> { };
+  
+  template<typename _Tp, unsigned _Uint, std::size_t _Size>
+    struct extent<_Tp[_Size], _Uint>
+    : integral_constant<std::size_t,
+                        _Uint == 0 ? _Size : extent<_Tp, _Uint - 1>::value>
+    { };
+
+  template<typename _Tp, unsigned _Uint>
+    struct extent<_Tp[], _Uint>
+    : integral_constant<std::size_t, 
+                        _Uint == 0 ? 0 : extent<_Tp, _Uint - 1>::value>
+    { };
+
+
+  // type relations.
+
+  /// is_same
+  template<typename _Tp, typename _Up> 
+    struct is_same
+    : integral_constant<bool, __is_same(_Tp, _Up)> { };
+
+
+  /// is_base_of
+  template<typename _Base, typename _Derived>
+    struct is_base_of
+    : integral_constant<bool, __is_base_of(_Base, _Derived)>
+    { };
+
+
+  /// is_convertible
+  template<typename _From, typename _To>
+    struct is_convertible
+    : integral_constant<bool, __is_convertible_to(_From, _To)> 
+  { };
+
+  // const-volatile modifications.
+
+  /// remove_const
+  template<typename _Tp>
+    struct remove_const
+    { typedef _Tp     type; };
+
+  template<typename _Tp>
+    struct remove_const<_Tp const>
+    { typedef _Tp     type; };
+  
+  /// remove_volatile
+  template<typename _Tp>
+    struct remove_volatile
+    { typedef _Tp     type; };
+
+  template<typename _Tp>
+    struct remove_volatile<_Tp volatile>
+    { typedef _Tp     type; };
+  
+  /// remove_cv
+  template<typename _Tp>
+    struct remove_cv
+    {
+      typedef typename
+      remove_const<typename remove_volatile<_Tp>::type>::type     type;
+    };
+  
+  /// add_const
+  template<typename _Tp>
+    struct add_const
+    { typedef _Tp const     type; };
+   
+  /// add_volatile
+  template<typename _Tp>
+    struct add_volatile
+    { typedef _Tp volatile     type; };
+  
+  /// add_cv
+  template<typename _Tp>
+    struct add_cv
+    {
+      typedef typename
+      add_const<typename add_volatile<_Tp>::type>::type     type;
+    };
+
+
+  // Reference transformations.
+
+  /// remove_reference
+  template<typename _Tp>
+    struct remove_reference
+    { typedef _Tp   type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&>
+    { typedef _Tp   type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&&>
+    { typedef _Tp   type; };
+
+
+  // __remove_cv_reference
+  template<typename _Tp>
+    struct __remove_cv_reference
+    : remove_cv<typename remove_reference<_Tp>::type>
+    { };
+
+
+
+  template<typename _Tp,
+     bool = __and_<__not_<is_reference<_Tp>>,
+                         __not_<is_void<_Tp>>>::value,
+     bool = is_rvalue_reference<_Tp>::value>
+    struct __add_lvalue_reference_helper
+    { typedef _Tp   type; };
+
+  template<typename _Tp>
+    struct __add_lvalue_reference_helper<_Tp, true, false>
+    { typedef _Tp&   type; };
+
+  template<typename _Tp>
+    struct __add_lvalue_reference_helper<_Tp, false, true>
+    { typedef typename remove_reference<_Tp>::type&   type; };
+
+  /// add_lvalue_reference
+  template<typename _Tp>
+    struct add_lvalue_reference
+    : public __add_lvalue_reference_helper<_Tp>
+    { };
+
+  template<typename _Tp,
+           bool = __and_<__not_<is_reference<_Tp>>,
+                         __not_<is_void<_Tp>>>::value>
+    struct __add_rvalue_reference_helper
+    { typedef _Tp   type; };
+
+  template<typename _Tp>
+    struct __add_rvalue_reference_helper<_Tp, true>
+    { typedef _Tp&&   type; };
+
+  /// add_rvalue_reference
+  template<typename _Tp>
+    struct add_rvalue_reference
+    : public __add_rvalue_reference_helper<_Tp>
+    { };
+
+
+  // sign modifications.
+
+  // Utility for constructing identically cv-qualified types.
+  template<typename _Unqualified, bool _IsConst, bool _IsVol>
+    struct __cv_selector;
+
+  template<typename _Unqualified>
+    struct __cv_selector<_Unqualified, false, false>
+    { typedef _Unqualified __type; };
+
+  template<typename _Unqualified>
+    struct __cv_selector<_Unqualified, false, true>
+    { typedef volatile _Unqualified __type; };
+
+  template<typename _Unqualified>
+    struct __cv_selector<_Unqualified, true, false>
+    { typedef const _Unqualified __type; };
+
+  template<typename _Unqualified>
+    struct __cv_selector<_Unqualified, true, true>
+    { typedef const volatile _Unqualified __type; };
+
+  template<typename _Qualified, typename _Unqualified,
+     bool _IsConst = is_const<_Qualified>::value,
+     bool _IsVol = is_volatile<_Qualified>::value>
+    class __match_cv_qualifiers
+    {
+      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
+
+    public:
+      typedef typename __match::__type __type; 
+    };
+
+  // Utility for finding the unsigned versions of signed integral types.
+  template<typename _Tp>
+    struct __make_unsigned
+    { typedef _Tp __type; };
+
+  template<>
+    struct __make_unsigned<char>
+    { typedef unsigned char __type; };
+
+  template<>
+    struct __make_unsigned<signed char>
+    { typedef unsigned char __type; };
+
+  template<>
+    struct __make_unsigned<short>
+    { typedef unsigned short __type; };
+
+  template<>
+    struct __make_unsigned<int>
+    { typedef unsigned int __type; };
+
+  template<>
+    struct __make_unsigned<long>
+    { typedef unsigned long __type; };
+
+  template<>
+    struct __make_unsigned<long long>
+    { typedef unsigned long long __type; };
+
+#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
+  template<>
+    struct __make_unsigned<__int128>
+    { typedef unsigned __int128 __type; };
+#endif
+
+  // Select between integral and enum: not possible to be both.
+  template<typename _Tp, 
+     bool _IsInt = is_integral<_Tp>::value,
+     bool _IsEnum = is_enum<_Tp>::value>
+    class __make_unsigned_selector;
+
+  template<typename _Tp>
+    class __make_unsigned_selector<_Tp, true, false>
+    {
+      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
+      typedef typename __unsignedt::__type __unsigned_type;
+      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;
+
+    public:
+      typedef typename __cv_unsigned::__type __type;
+    };
+
+  template<typename _Tp>
+    class __make_unsigned_selector<_Tp, false, true>
+    {
+      // With -fshort-enums, an enum may be as small as a char.
+      typedef unsigned char __smallest;
+      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
+      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
+      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
+      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
+      typedef typename __cond2::type __cond2_type;
+      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
+      typedef typename __cond1::type __cond1_type;
+
+    public:
+      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
+    };
+
+  // Given an integral/enum type, return the corresponding unsigned
+  // integer type.
+  // Primary template.
+  /// make_unsigned
+  template<typename _Tp>
+    struct make_unsigned 
+    { typedef typename __make_unsigned_selector<_Tp>::__type type; };
+
+  // Integral, but don't define.
+  template<>
+    struct make_unsigned<bool>;
+
+
+  // Utility for finding the signed versions of unsigned integral types.
+  template<typename _Tp>
+    struct __make_signed
+    { typedef _Tp __type; };
+
+  template<>
+    struct __make_signed<char>
+    { typedef signed char __type; };
+
+  template<>
+    struct __make_signed<unsigned char>
+    { typedef signed char __type; };
+
+  template<>
+    struct __make_signed<unsigned short>
+    { typedef signed short __type; };
+
+  template<>
+    struct __make_signed<unsigned int>
+    { typedef signed int __type; };
+
+  template<>
+    struct __make_signed<unsigned long>
+    { typedef signed long __type; };
+
+  template<>
+    struct __make_signed<unsigned long long>
+    { typedef signed long long __type; };
+
+#if !defined(__STRICT_ANSI__) && defined(_GLIBCXX_USE_INT128)
+  template<>
+    struct __make_signed<unsigned __int128>
+    { typedef __int128 __type; };
+#endif
+
+  // Select between integral and enum: not possible to be both.
+  template<typename _Tp, 
+     bool _IsInt = is_integral<_Tp>::value,
+     bool _IsEnum = is_enum<_Tp>::value>
+    class __make_signed_selector;
+
+  template<typename _Tp>
+    class __make_signed_selector<_Tp, true, false>
+    {
+      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
+      typedef typename __signedt::__type __signed_type;
+      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;
+
+    public:
+      typedef typename __cv_signed::__type __type;
+    };
+
+  template<typename _Tp>
+    class __make_signed_selector<_Tp, false, true>
+    {
+      // With -fshort-enums, an enum may be as small as a char.
+      typedef signed char __smallest;
+      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
+      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
+      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
+      typedef conditional<__b2, signed int, signed long> __cond2;
+      typedef typename __cond2::type __cond2_type;
+      typedef conditional<__b1, signed short, __cond2_type> __cond1;
+      typedef typename __cond1::type __cond1_type;
+
+    public:
+      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
+    };
+
+  // Given an integral/enum type, return the corresponding signed
+  // integer type.
+  // Primary template.
+  /// make_signed
+  template<typename _Tp>
+    struct make_signed 
+    { typedef typename __make_signed_selector<_Tp>::__type type; };
+
+  // Integral, but don't define.
+  template<>
+    struct make_signed<bool>;
+
+
+  // array modifications.
+
+  /// remove_extent
+  template<typename _Tp>
+    struct remove_extent
+    { typedef _Tp     type; };
+
+  template<typename _Tp, std::size_t _Size>
+    struct remove_extent<_Tp[_Size]>
+    { typedef _Tp     type; };
+
+  template<typename _Tp>
+    struct remove_extent<_Tp[]>
+    { typedef _Tp     type; };
+
+  /// remove_all_extents
+  template<typename _Tp>
+    struct remove_all_extents
+    { typedef _Tp     type; };
+
+  template<typename _Tp, std::size_t _Size>
+    struct remove_all_extents<_Tp[_Size]>
+    { typedef typename remove_all_extents<_Tp>::type     type; };
+
+  template<typename _Tp>
+    struct remove_all_extents<_Tp[]>
+    { typedef typename remove_all_extents<_Tp>::type     type; };
+
+
+  // pointer modifications.
+
+  template<typename _Tp, typename>
+    struct __remove_pointer_helper
+    { typedef _Tp     type; };
+
+  template<typename _Tp, typename _Up>
+    struct __remove_pointer_helper<_Tp, _Up*>
+    { typedef _Up     type; };
+
+  /// remove_pointer
+  template<typename _Tp>
+    struct remove_pointer
+    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
+    { };
+
+  /// add_pointer
+  template<typename _Tp>
+    struct add_pointer
+    { typedef typename remove_reference<_Tp>::type*     type; };
+
+
+  template<std::size_t _Len>
+    struct __aligned_storage_msa
+    { 
+      union __type
+      {
+  unsigned char __data[_Len];
+  struct __attribute__((__aligned__)) { } __align; 
+      };
+    };
+
+  /**
+   *  @brief Alignment type.
+   *
+   *  The value of _Align is a default-alignment which shall be the
+   *  most stringent alignment requirement for any C++ object type
+   *  whose size is no greater than _Len (3.9). The member typedef
+   *  type shall be a POD type suitable for use as uninitialized
+   *  storage for any object whose size is at most _Len and whose
+   *  alignment is a divisor of _Align.
+  */
+  template<std::size_t _Len, std::size_t _Align =
+     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
+    struct aligned_storage
+    { 
+      union type
+      {
+  unsigned char __data[_Len];
+  struct __attribute__((__aligned__((_Align)))) { } __align; 
+      };
+    };
+
+
+  // Decay trait for arrays and functions, used for perfect forwarding
+  // in make_pair, make_tuple, etc.
+  template<typename _Up, 
+     bool _IsArray = is_array<_Up>::value,
+     bool _IsFunction = is_function<_Up>::value> 
+    struct __decay_selector;
+
+  // NB: DR 705.
+  template<typename _Up> 
+    struct __decay_selector<_Up, false, false>
+    { typedef typename remove_cv<_Up>::type __type; };
+
+  template<typename _Up> 
+    struct __decay_selector<_Up, true, false>
+    { typedef typename remove_extent<_Up>::type* __type; };
+
+  template<typename _Up> 
+    struct __decay_selector<_Up, false, true>
+    { typedef typename add_pointer<_Up>::type __type; };
+
+  /// decay
+  template<typename _Tp> 
+    class decay 
+    { 
+      typedef typename remove_reference<_Tp>::type __remove_type;
+
+    public:
+      typedef typename __decay_selector<__remove_type>::__type type;
+    };
+
+  template<typename _Tp>
+    class reference_wrapper;
+
+  // Helper which adds a reference to a type when given a reference_wrapper
+  template<typename _Tp>
+    struct __strip_reference_wrapper
+    {
+      typedef _Tp __type;
+    };
+
+  template<typename _Tp>
+    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
+    {
+      typedef _Tp& __type;
+    };
+
+  template<typename _Tp>
+    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
+    {
+      typedef _Tp& __type;
+    };
+
+  template<typename _Tp>
+    struct __decay_and_strip
+    {
+      typedef typename __strip_reference_wrapper<
+  typename decay<_Tp>::type>::__type __type;
+    };
+
+
+  // Primary template.
+  /// Define a member typedef @c type only if a boolean constant is true.
+  template<bool, typename _Tp = void>
+    struct enable_if 
+    { };
+
+  // Partial specialization for true.
+  template<typename _Tp>
+    struct enable_if<true, _Tp>
+    { typedef _Tp type; };
+
+
+  // Primary template.
+  /// Define a member typedef @c type to one of two argument types.
+  template<bool _Cond, typename _Iftrue, typename _Iffalse>
+    struct conditional
+    { typedef _Iftrue type; };
+
+  // Partial specialization for false.
+  template<typename _Iftrue, typename _Iffalse>
+    struct conditional<false, _Iftrue, _Iffalse>
+    { typedef _Iffalse type; };
+
+
+  /// common_type
+  template<typename... _Tp>
+    struct common_type;
+
+  template<typename _Tp>
+    struct common_type<_Tp>
+    { typedef _Tp type; };
+
+  template<typename _Tp, typename _Up>
+    struct common_type<_Tp, _Up>
+    { typedef decltype(true ? declval<_Tp>() : declval<_Up>()) type; };
+
+  template<typename _Tp, typename _Up, typename... _Vp>
+    struct common_type<_Tp, _Up, _Vp...>
+    {
+      typedef typename
+        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
+    };
+
+  /// The underlying type of an enum.
+  template<typename _Tp>
+    struct underlying_type
+    {
+      typedef __underlying_type(_Tp) type;
+    };
+
+  template<typename _Tp>
+    struct __declval_protector
+    {
+      static const bool __stop = false;
+      static typename add_rvalue_reference<_Tp>::type __delegate();
+    };
+
+  template<typename _Tp>
+    inline typename add_rvalue_reference<_Tp>::type
+    declval() noexcept
+    {
+      static_assert(__declval_protector<_Tp>::__stop,
+        "declval() must not be used!");
+      return __declval_protector<_Tp>::__delegate();
+    }
+
+  
+  /// result_of
+  // FIXME: This needs to be rewritten with constraints.
+
+  template<typename _Signature>
+    struct result_of;
+
+  template<typename _MemPtr, typename _Arg>
+    struct _Result_of_memobj;
+
+  template<typename _Res, typename _Class, typename _Arg>
+    struct _Result_of_memobj<_Res _Class::*, _Arg>
+    {
+    private:
+      typedef _Res _Class::* _Func;
+
+      template<typename _Tp>
+        static _Tp _S_get(const _Class&);
+      template<typename _Tp>
+        static _Tp _S_get(const volatile _Class&);
+      template<typename _Tp>
+        static decltype(*std::declval<_Tp>()) _S_get(...);
+        
+    public:
+      typedef
+        decltype(_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())
+        __type;
+    };
+
+  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>
+    struct _Result_of_memfun;
+
+  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
+    struct _Result_of_memfun<_Res _Class::*, _Arg, _Args...>
+    {
+    private:
+      typedef _Res _Class::* _Func;
+
+      template<typename _Tp>
+        static _Tp _S_get(const _Class&);
+      template<typename _Tp>
+        static _Tp _S_get(const volatile _Class&);
+      template<typename _Tp>
+        static decltype(*std::declval<_Tp>()) _S_get(...);
+        
+    public:
+      typedef
+        decltype((_S_get<_Arg>(std::declval<_Arg>()).*std::declval<_Func>())
+            (std::declval<_Args>()...) )
+        __type;
+    };
+
+  // B1 Member obj pointer
+  // B2 Member fn pointer
+  template<bool, bool, typename _Functor, typename... _ArgTypes>
+    struct _Result_of_impl;
+
+  template<typename _Fn, typename... _Args>
+    struct _Result_of_impl<false, false, _Fn, _Args...>
+    {
+      using __type = decltype( declval<_Fn>()(declval<_Args>()...) );
+    };
+
+  template<typename _MemPtr, typename _Arg>
+    struct _Result_of_impl<true, false, _MemPtr, _Arg>
+    : _Result_of_memobj<typename decay<_MemPtr>::type, _Arg>
+    { };
+
+  template<typename _MemPtr, typename _Arg, typename... _ArgTypes>
+    struct _Result_of_impl<false, true, _MemPtr, _Arg, _ArgTypes...>
+    : _Result_of_memfun<typename decay<_MemPtr>::type, _Arg, _ArgTypes...>
+    { };
+
+  template<typename _Functor, typename... _Args>
+    struct result_of<_Functor(_Args...)>
+    : _Result_of_impl<is_member_object_pointer<__referent<_Functor>>::value,
+                      is_member_function_pointer<__referent<_Functor>>::value,
+                      _Functor, _Args...>
+    {
+      using type = typename _Result_of_impl<
+          is_member_object_pointer<__referent<_Functor>>::value,
+          is_member_function_pointer<__referent<_Functor>>::value,
+          _Functor, _Args...>::__type;
+    };
+
+  /**
+   *  Use SFINAE to determine if the type _Tp has a publicly-accessible
+   *  member type _NTYPE.
+   */
+#define _GLIBCXX_HAS_NESTED_TYPE(_NTYPE)                         \
+  template<typename _Tp>                                         \
+    class __has_##_NTYPE##_helper                                \
+    : __sfinae_types                                             \
+    {                                                            \
+      template<typename _Up>                                     \
+        struct _Wrap_type                                        \
+  { };                                                     \
+                                                                 \
+      template<typename _Up>                                     \
+        static __one __test(_Wrap_type<typename _Up::_NTYPE>*);  \
+                                                                 \
+      template<typename _Up>                                     \
+        static __two __test(...);                                \
+                                                                 \
+    public:                                                      \
+      static constexpr bool value = sizeof(__test<_Tp>(0)) == 1; \
+    };                                                           \
+                                                                 \
+  template<typename _Tp>                                         \
+    struct __has_##_NTYPE                                        \
+    : integral_constant<bool, __has_##_NTYPE##_helper            \
+      <typename remove_cv<_Tp>::type>::value>  \
+    { };
+
+
+
+  // FIXME: Consider moving all of this stuff into bits/constraints.h.
+
+  /**
+   * Constraints and Type functions 
+   */
+
+  template<typename _Tp>
+   constexpr bool Void() { return is_void<_Tp>::value; }
+
+  template<typename _Tp>
+   constexpr bool Integral() { return is_integral<_Tp>::value; }
+
+  template<typename _Tp>
+   constexpr bool Floating_point() { return is_floating_point<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Array() { return is_array<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Pointer() { return is_pointer<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Lvalue_reference() { return is_lvalue_reference<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Rvalue_reference() { return is_rvalue_reference<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Member_object_pointer() { return is_member_object_pointer<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Member_function_pointer() { return is_member_function_pointer<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Enum() { return __is_enum(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Union() { return __is_union(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Class() { return __is_class(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Function_type() { return is_function<_Tp>::value; }
+
+  // Composite types
+  
+  template<typename _Tp>
+    constexpr bool Reference() { return is_reference<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Arithmetic() { return is_arithmetic<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Fundamental() { return is_fundamental<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Scalar() { return is_scalar<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Compound() { return is_compound<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Member_pointer() { return is_member_pointer<_Tp>::value; }
+
+  // Type properties
+
+  template<typename _Tp>
+    constexpr bool Const() { return is_const<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Volatile() { return is_volatile<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Qualified() { return __is_qualified<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Unqualified() { return __is_unqualified<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Trivial() { return is_trivial<_Tp>::value; }
+
+  // template<typename _Tp>
+  //   constexpr bool Trivally_copyable() { return is_trivially_copyable<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Standard_layout() { return __is_standard_layout(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Pod() { return __is_pod(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Empty() { return __is_empty(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Polymorphic() { return __is_polymorphic(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Abstract() { return __is_abstract(_Tp); }
+
+  template<typename _Tp>
+    constexpr bool Signed() { return is_signed<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Unsigned() { return is_unsigned<_Tp>::value; }
+
+  template<typename _Tp, typename... _Args>
+    constexpr bool Constructible() { return is_constructible<_Tp, _Args...>::value; }
+
+  template<typename _Tp>
+    constexpr bool Default_constructible() { return is_default_constructible<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Copy_constructible() { return is_copy_constructible<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Move_constructible() { return is_move_constructible<_Tp>::value; }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Assignable() { return is_assignable<_Tp, _Up>::value; }
+
+  template<typename _Tp>
+    constexpr bool Copy_assignable() { return is_copy_assignable<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Move_assignable() { return is_move_assignable<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Destructible() { return is_destructible<_Tp>::value; }
+
+  // template<typename _Tp, typename... _Args>
+  //   constexpr bool Trivially_constructible();
+
+  // template<typename _Tp>
+  //   constexpr bool Trivially_default_constructible();
+
+  // template<typename _Tp>
+  //   constexpr bool Trivially_copy_constructible();
+
+  // template<typename _Tp>
+  //   constexpr bool Trivially_move_constructible();
+
+  // template<typename _Tp, typename _Up>
+  //   constexpr bool Trivially_assignable();
+
+  // template<typename _Tp>
+  //   constexpr bool Trivially_copy_assignable();
+
+  // template<typename _Tp>
+  //   constexpr bool Trivially_move_assignable();
+
+  // template<typename _Tp>
+  //   constexpr bool Trivially_destructible();
+
+  template<typename _Tp, typename... _Args>
+    constexpr bool Nothrow_constructible() 
+    { return is_nothrow_constructible<_Tp, _Args...>::value; }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_default_constructible() 
+    { return is_nothrow_default_constructible<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_copy_constructible() 
+    { return is_nothrow_copy_constructible<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_move_constructible()
+    { return is_nothrow_move_constructible<_Tp>::value; }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Nothrow_assignable()
+    { return is_nothrow_assignable<_Tp, _Up>::value; }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_copy_assignable()
+    { return is_nothrow_copy_assignable<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_move_assignable()
+    { return is_nothrow_move_assignable<_Tp>::value; }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_movable()
+    { return Nothrow_move_constructible<_Tp>() && Nothrow_move_assignable<_Tp>(); }
+
+  template<typename _Tp>
+    constexpr bool Nothrow_destructible()
+    { return is_nothrow_destructible<_Tp>::value; }
+
+
+  template<typename _Tp>
+    constexpr bool Has_virtually_destructor() 
+    { return __has_virtual_destructor(_Tp); }
+
+
+  // Type transformations
+  
+  template<typename _Tp>
+    using Remove_cv = typename std::remove_cv<_Tp>::type;
+
+  template<typename _Tp>
+    using Remove_reference = typename std::remove_reference<_Tp>::type;
+
+  template<typename _Tp>
+    using Remove_forwarding = Remove_reference<Remove_cv<_Tp>>;
+
+  template<typename _Tp>
+    using Remove_all_extents = typename remove_all_extents<_Tp>::type;
+
+  template<typename _Call>
+    using Result_type = typename result_of<_Call>::type;
+
+  // Constraints
+
+  // Type relations
+  template<typename _Tp, typename _Up>
+    constexpr bool Same() { return __is_same(_Tp, _Up); }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Convertible() { return __is_convertible_to(_Tp, _Up); }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Derived() { return __is_base_of(_Up, _Tp); }
+
+  template<typename _Tp>
+    constexpr bool Valid_type() { return !__is_same(_Tp, __subst_fail); }
+
+
+
+  // Relational properties
+  template<typename _Tp>
+    constexpr bool Equality_comparable()
+    {
+      __declval _Tp __a, __b;
+      return __is_valid_expr(bool = {__a == __b})
+          && __is_valid_expr(bool = {__a != __b});
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Equality_comparable()
+    {
+      __declval _Tp __t;
+      __declval _Up __u;
+      return Equality_comparable<_Tp>() && Equality_comparable<_Up>()
+          && __is_valid_expr(bool = {__t == __u})
+          && __is_valid_expr(bool = {__u == __t})
+          && __is_valid_expr(bool = {__t != __u})
+          && __is_valid_expr(bool = {__u != __t});
+    }
+
+  template<typename _Tp>
+    constexpr bool Weakly_ordered()
+    {
+      __declval _Tp __a, __b;
+      return __is_valid_expr(bool = {__a < __b})
+          && __is_valid_expr(bool = {__a > __b})
+          && __is_valid_expr(bool = {__a <= __b})
+          && __is_valid_expr(bool = {__a >= __b});
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Weakly_ordered()
+    {
+      __declval _Tp __t;
+      __declval _Up __u;
+      return Weakly_ordered<_Tp>() && Weakly_ordered<_Up>()
+          && __is_valid_expr(bool = {__t < __u})
+          && __is_valid_expr(bool = {__u < __t})
+          && __is_valid_expr(bool = {__t > __u})
+          && __is_valid_expr(bool = {__u > __t})
+          && __is_valid_expr(bool = {__t <= __u})
+          && __is_valid_expr(bool = {__u <= __t})
+          && __is_valid_expr(bool = {__t >= __u})
+          && __is_valid_expr(bool = {__u >= __t});    
+    }
+
+  template<typename _Tp>
+    constexpr bool Totally_ordered()
+    {
+      return Equality_comparable<_Tp>() && Weakly_ordered<_Tp>();
+    }
+
+  template<typename _Tp, typename _Up>
+    constexpr bool Totally_ordered()
+    {
+      return Equality_comparable<_Tp, _Up>() && Weakly_ordered<_Tp, _Up>();
+    }
+
+
+  // Basic types
+
+  template<typename _Tp>
+    constexpr bool Movable()
+    {
+      return Destructible<_Tp>() 
+          && Move_constructible<_Tp>() 
+          && Move_assignable<_Tp>();
+    }
+
+  template<typename _Tp>
+    constexpr bool Copyable()
+    {
+      return Movable<_Tp>() 
+          && Copy_constructible<_Tp>() 
+          && Copy_assignable<_Tp>();
+    }
+
+  template<typename _Tp>
+    constexpr bool Semiregular()
+    {
+      return Copyable<_Tp>() && Default_constructible<_Tp>();
+    }
+
+  template<typename _Tp>
+    constexpr bool Regular()
+    {
+      return Semiregular<_Tp>() && Equality_comparable<_Tp>();
+    }
+
+  template<typename _Tp>
+    constexpr bool Resource()
+    {
+      return Movable<_Tp>() && !Copyable<_Tp>();
+    }
+
+  // Functions
+
+  template<typename _Fn, typename... _Args>
+    constexpr bool Function() 
+    { 
+      __declval _Fn __f;
+      return __is_valid_expr(__f(declval<_Args>()...));
+    }
+
+  template<typename _Fn, typename... _Args>
+    constexpr bool Regular_function() 
+    { 
+      return Function<_Fn, _Args...>(); 
+    }
+
+  template<typename _Pred, typename... _Args>
+    constexpr bool Predicate()
+    {
+      return Regular_function<_Pred, _Args...>() &&
+             Convertible<Result_type<_Pred(_Args...)>, bool>();
+    }
+
+  template<typename _Comp, typename _Tp>
+    constexpr bool Relation()
+    {
+      return Predicate<_Comp, _Tp, _Tp>();
+    }
+
+  template<typename _Comp, typename _Tp, typename _Up>
+    constexpr bool Relation()
+    {
+      return Predicate<_Comp, _Tp, _Up>()
+          && Predicate<_Comp, _Up, _Tp>();
+    }
+
+  template<typename _Gen>
+    constexpr bool Generator() { return Function<_Gen>(); }
+
+  /// @} group metaprogramming
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace
diff --git a/libstdc++-v3/include/bits/stl_algo.h b/libstdc++-v3/include/bits/stl_algo.h
index f337e0c..79149e3 100644
--- a/libstdc++-v3/include/bits/stl_algo.h
+++ b/libstdc++-v3/include/bits/stl_algo.h
@@ -68,6 +68,10 @@
 #include <functional> // for std::bind
 #endif
 
+#ifdef __GXX_EXPERIMENTAL_CXX1Y__
+# include <bits/cons_algo.h>
+#else
+
 // See concept_check.h for the __glibcxx_*_requires macros.
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -6346,4 +6350,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 _GLIBCXX_END_NAMESPACE_ALGO
 } // namespace std
 
+#endif /* __GXX_EXPERIMENTAL_CXX1Y__ */
+
 #endif /* _STL_ALGO_H */
+
diff --git a/libstdc++-v3/include/bits/stl_algobase.h b/libstdc++-v3/include/bits/stl_algobase.h
index fe30f6c..9837a01 100644
--- a/libstdc++-v3/include/bits/stl_algobase.h
+++ b/libstdc++-v3/include/bits/stl_algobase.h
@@ -70,6 +70,10 @@
 #include <debug/debug.h>
 #include <bits/move.h> // For std::swap and _GLIBCXX_MOVE
 
+#if __GXX_EXPERIMENTAL_CXX1Y__
+# include <bits/cons_algobase.h>
+#else
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -1215,6 +1219,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO
 _GLIBCXX_END_NAMESPACE_ALGO
 } // namespace std
 
+#endif // __GXX_EXPERIMENTAL_CXX1Y__
+
 // NB: This file is included within many other C++ includes, as a way
 // of getting the base algorithms. So, make sure that parallel bits
 // come in too if requested. 
diff --git a/libstdc++-v3/include/bits/stl_heap.h b/libstdc++-v3/include/bits/stl_heap.h
index f185610..58a8548 100644
--- a/libstdc++-v3/include/bits/stl_heap.h
+++ b/libstdc++-v3/include/bits/stl_heap.h
@@ -59,6 +59,10 @@
 #include <debug/debug.h>
 #include <bits/move.h>
 
+#ifdef __GXX_EXPERIMENTAL_CXX1Y__
+# include <bits/cons_heap.h>
+#else
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -584,4 +588,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
+#endif /* __GXX_EXPERIMENTAL_CXX1Y__ */
+
 #endif /* _STL_HEAP_H */
diff --git a/libstdc++-v3/include/bits/stl_iterator_base_funcs.h b/libstdc++-v3/include/bits/stl_iterator_base_funcs.h
index 8028fbb..757d880 100644
--- a/libstdc++-v3/include/bits/stl_iterator_base_funcs.h
+++ b/libstdc++-v3/include/bits/stl_iterator_base_funcs.h
@@ -64,6 +64,10 @@
 
 #include <bits/concept_check.h>
 
+#ifdef __GXX_EXPERIMENTAL_CXX1Y__
+#include <bits/cons_iterator_base_funcs.h>
+#else
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -201,4 +205,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
+#endif /* __GXX_EXPERIMENTAL_CXX1Y__ */
+
 #endif /* _STL_ITERATOR_BASE_FUNCS_H */
diff --git a/libstdc++-v3/include/bits/stl_iterator_base_types.h b/libstdc++-v3/include/bits/stl_iterator_base_types.h
index 1f56c06..14b3f90 100644
--- a/libstdc++-v3/include/bits/stl_iterator_base_types.h
+++ b/libstdc++-v3/include/bits/stl_iterator_base_types.h
@@ -231,8 +231,15 @@ _GLIBCXX_HAS_NESTED_TYPE(iterator_category)
 			       input_iterator_tag>::value>::type;
 #endif
 
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
+// Extensions for constrained templates
+#ifdef __GXX_EXPERIMENTAL_CXX1Y__
+#include <bits/cons_iterator_base_types.h>
+#endif
+
+
 #endif /* _STL_ITERATOR_BASE_TYPES_H */
 
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
index 9232af7..f6f1e38 100644
--- a/libstdc++-v3/include/std/type_traits
+++ b/libstdc++-v3/include/std/type_traits
@@ -38,6 +38,10 @@
 
 #include <bits/c++config.h>
 
+#ifdef __GXX_EXPERIMENTAL_CXX1Y__
+# include <bits/cons_type_traits.h>
+#else
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -1935,6 +1939,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
 
+#endif  // __GXX_EXPERIMENTAL_CXX1Y__
+
 #endif  // __GXX_EXPERIMENTAL_CXX0X__
 
 #endif  // _GLIBCXX_TYPE_TRAITS
diff --git a/libstdc++-v3/testsuite/25_algorithms/adjacent_find/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/adjacent_find/check_type.cc
index b0d34e0..6299c0a 100644
--- a/libstdc++-v3/testsuite/25_algorithms/adjacent_find/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/adjacent_find/check_type.cc
@@ -27,6 +27,7 @@ using __gnu_test::forward_iterator_wrapper;
 struct S { };
 
 bool operator==(const S&, const S&) {return true;}
+bool operator!=(const S&, const S&) {return true;}
 
 struct X { };
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/binary_search/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/binary_search/check_type.cc
index 90ed046..d26720a 100644
--- a/libstdc++-v3/testsuite/25_algorithms/binary_search/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/binary_search/check_type.cc
@@ -27,6 +27,9 @@ using __gnu_test::forward_iterator_wrapper;
 struct S { };
 
 bool operator<(const S&, const S&) {return true;}
+bool operator>(const S&, const S&) {return true;}
+bool operator<=(const S&, const S&) {return true;}
+bool operator>=(const S&, const S&) {return true;}
 
 struct X { };
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/copy/34595.cc b/libstdc++-v3/testsuite/25_algorithms/copy/34595.cc
index ebc8d9c..2ccd202 100644
--- a/libstdc++-v3/testsuite/25_algorithms/copy/34595.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/copy/34595.cc
@@ -27,6 +27,7 @@ class Counting_output_iterator
 public:
   Counting_output_iterator() : c(0) {}
   Counting_output_iterator& operator++() { return *this; }
+  Counting_output_iterator operator++(int) { return *this; }
   Counting_output_iterator& operator*() { return *this; }
   
   template <typename T>
diff --git a/libstdc++-v3/testsuite/25_algorithms/count/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/count/check_type.cc
index 9e64b30..2878db6 100644
--- a/libstdc++-v3/testsuite/25_algorithms/count/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/count/check_type.cc
@@ -28,9 +28,18 @@ struct Y { };
 
 using __gnu_test::input_iterator_wrapper;
 
-bool
-operator==(const X&, const Y&)
-{ return true; }
+bool operator==(const X&, const X&) { return true; }
+bool operator!=(const X&, const X&) { return true; }
+
+bool operator==(const Y&, const Y&) { return true; }
+bool operator!=(const Y&, const Y&) { return true; }
+
+bool operator==(const X&, const Y&) { return true; }
+bool operator!=(const X&, const Y&) { return true; }
+
+bool operator==(const Y&, const X&) { return true; }
+bool operator!=(const Y&, const X&) { return true; }
+
 
 typedef std::iterator_traits<input_iterator_wrapper<X> >::difference_type
 	diff_type;
diff --git a/libstdc++-v3/testsuite/25_algorithms/equal_range/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/equal_range/check_type.cc
index f6b2629..383ab4b 100644
--- a/libstdc++-v3/testsuite/25_algorithms/equal_range/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/equal_range/check_type.cc
@@ -28,6 +28,9 @@ using __gnu_test::forward_iterator_wrapper;
 struct S { };
 
 bool operator<(const S&, const S&) {return true;}
+bool operator>(const S&, const S&) {return true;}
+bool operator<=(const S&, const S&) {return true;}
+bool operator>=(const S&, const S&) {return true;}
 
 struct X { };
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/find/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/find/check_type.cc
index 52007f2..34ab6f2 100644
--- a/libstdc++-v3/testsuite/25_algorithms/find/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/find/check_type.cc
@@ -27,9 +27,17 @@ using __gnu_test::input_iterator_wrapper;
 struct Lhs { };
 struct Rhs { };
 
-bool
-operator==(const Lhs&, const Rhs&)
-{ return true; }
+bool operator==(const Lhs&, const Lhs&) { return true; }
+bool operator!=(const Lhs&, const Lhs&) { return true; }
+
+bool operator==(const Rhs&, const Rhs&) { return true; }
+bool operator!=(const Rhs&, const Rhs&) { return true; }
+
+bool operator==(const Lhs&, const Rhs&) { return true; }
+bool operator!=(const Lhs&, const Rhs&) { return true; }
+
+bool operator==(const Rhs&, const Lhs&) { return true; }
+bool operator!=(const Rhs&, const Lhs&) { return true; }
 
 input_iterator_wrapper<Lhs>
 test1(input_iterator_wrapper<Lhs>& begin,
diff --git a/libstdc++-v3/testsuite/25_algorithms/includes/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/includes/check_type.cc
index 36740a6..82c4315 100644
--- a/libstdc++-v3/testsuite/25_algorithms/includes/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/includes/check_type.cc
@@ -30,6 +30,18 @@ bool
 operator<(const S&, const S&) 
 { return true; }
 
+bool 
+operator>(const S&, const S&) 
+{ return true; }
+
+bool 
+operator<=(const S&, const S&) 
+{ return true; }
+
+bool 
+operator>=(const S&, const S&) 
+{ return true; }
+
 struct X { };
 
 bool
diff --git a/libstdc++-v3/testsuite/25_algorithms/inplace_merge/1.cc b/libstdc++-v3/testsuite/25_algorithms/inplace_merge/1.cc
index d4da753..8981bec 100644
--- a/libstdc++-v3/testsuite/25_algorithms/inplace_merge/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/inplace_merge/1.cc
@@ -56,9 +56,11 @@ struct S
   int b;
   S(int _a, int _b) : a(_a), b(_b) { }
   S() { }
-  bool 
-  operator<(const S& _s) const 
-  { return a < _s.a; }
+  
+  bool operator<(const S& _s) const  { return a < _s.a; }
+  bool operator>(const S& _s) const  { return a > _s.a; }
+  bool operator<=(const S& _s) const  { return a <= _s.a; }
+  bool operator>=(const S& _s) const  { return a >= _s.a; }
 };
 
 void 
diff --git a/libstdc++-v3/testsuite/25_algorithms/inplace_merge/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/inplace_merge/check_type.cc
index d4526a8..d0233f5 100644
--- a/libstdc++-v3/testsuite/25_algorithms/inplace_merge/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/inplace_merge/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/is_permutation/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/is_permutation/check_type.cc
index 600c09d..cca977f 100644
--- a/libstdc++-v3/testsuite/25_algorithms/is_permutation/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/is_permutation/check_type.cc
@@ -30,6 +30,7 @@ using __gnu_test::forward_iterator_wrapper;
 
 struct X { };
 bool operator==(const X&, const X) { return true; }
+bool operator!=(const X&, const X) { return true; }
 
 struct Y { };
 bool predicate(const Y&, const Y&) { return true; }
diff --git a/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/check_type.cc
index f8643aa..11b688a 100644
--- a/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/lexicographical_compare/check_type.cc
@@ -30,11 +30,53 @@ struct Lhs1 { };
 struct Rhs1 { };
 
 bool 
+operator<(const Lhs1&, const Lhs1&) {return true;}
+
+bool 
+operator>(const Lhs1&, const Lhs1&) {return true;}
+
+bool 
+operator<=(const Lhs1&, const Lhs1&) {return true;}
+
+bool 
+operator>=(const Lhs1&, const Lhs1&) {return true;}
+
+bool 
+operator<(const Rhs1&, const Rhs1&) {return true;}
+
+bool 
+operator>(const Rhs1&, const Rhs1&) {return true;}
+
+bool 
+operator<=(const Rhs1&, const Rhs1&) {return true;}
+
+bool 
+operator>=(const Rhs1&, const Rhs1&) {return true;}
+
+bool 
 operator<(const Lhs1&, const Rhs1&) {return true;}
 
 bool 
+operator>(const Lhs1&, const Rhs1&) {return true;}
+
+bool 
+operator<=(const Lhs1&, const Rhs1&) {return true;}
+
+bool 
+operator>=(const Lhs1&, const Rhs1&) {return true;}
+
+bool 
 operator<(const Rhs1&, const Lhs1&) {return false;}
 
+bool 
+operator>(const Rhs1&, const Lhs1&) {return false;}
+
+bool 
+operator<=(const Rhs1&, const Lhs1&) {return false;}
+
+bool 
+operator>=(const Rhs1&, const Lhs1&) {return false;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/lower_bound/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/lower_bound/check_type.cc
index a3d770f..9775827 100644
--- a/libstdc++-v3/testsuite/25_algorithms/lower_bound/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/lower_bound/check_type.cc
@@ -29,6 +29,16 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/max_element/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/max_element/check_type.cc
index b7917e2..95f7a8d 100644
--- a/libstdc++-v3/testsuite/25_algorithms/max_element/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/max_element/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/merge/1.cc b/libstdc++-v3/testsuite/25_algorithms/merge/1.cc
index 7b6a1e8..5b026a5 100644
--- a/libstdc++-v3/testsuite/25_algorithms/merge/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/merge/1.cc
@@ -80,6 +80,19 @@ bool
 operator<(const S& s1, const S& s2)
 { return s1.i < s2.i; }
 
+bool 
+operator>(const S& s1, const S& s2)
+{ return s1.i > s2.i; }
+
+bool 
+operator<=(const S& s1, const S& s2)
+{ return s1.i <= s2.i; }
+
+bool 
+operator>=(const S& s1, const S& s2)
+{ return s1.i >= s2.i; }
+
+
 void 
 test3()
 {
diff --git a/libstdc++-v3/testsuite/25_algorithms/merge/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/merge/check_type.cc
index d226935..7242f03 100644
--- a/libstdc++-v3/testsuite/25_algorithms/merge/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/merge/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/minmax_element/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/minmax_element/check_type.cc
index 3cd4625..1409c75 100644
--- a/libstdc++-v3/testsuite/25_algorithms/minmax_element/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/minmax_element/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/next_permutation/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/next_permutation/check_type.cc
index efd3c20..acd849d 100644
--- a/libstdc++-v3/testsuite/25_algorithms/next_permutation/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/next_permutation/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/nth_element/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/nth_element/check_type.cc
index 9f8c3b3..6347ac6 100644
--- a/libstdc++-v3/testsuite/25_algorithms/nth_element/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/nth_element/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/partial_sort/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/partial_sort/check_type.cc
index ff073fc..633b4d0 100644
--- a/libstdc++-v3/testsuite/25_algorithms/partial_sort/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/partial_sort/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/check_type.cc
index 3b5416b..c2248bb 100644
--- a/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/partial_sort_copy/check_type.cc
@@ -37,9 +37,34 @@ operator<(const S1&, const S1&)
 {return true;}
 
 bool 
+operator>(const S1&, const S1&) 
+{return true;}
+
+bool 
+operator<=(const S1&, const S1&) 
+{return true;}
+
+bool 
+operator>=(const S1&, const S1&) 
+{return true;}
+
+bool 
 operator<(const S2&, const S2&) 
 {return true;}
 
+bool 
+operator>(const S2&, const S2&) 
+{return true;}
+
+bool 
+operator<=(const S2&, const S2&) 
+{return true;}
+
+bool 
+operator>=(const S2&, const S2&) 
+{return true;}
+
+
 struct X1 { };
 struct X2 
 {
diff --git a/libstdc++-v3/testsuite/25_algorithms/prev_permutation/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/prev_permutation/check_type.cc
index 5d6bdbf..5fa97f2 100644
--- a/libstdc++-v3/testsuite/25_algorithms/prev_permutation/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/prev_permutation/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/remove/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/remove/check_type.cc
index 27b9c22..50bc70c 100644
--- a/libstdc++-v3/testsuite/25_algorithms/remove/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/remove/check_type.cc
@@ -29,9 +29,37 @@ struct X { };
 struct Y { };
 
 bool
+operator==(const X&, const X&)
+{ return true; }
+
+bool
+operator!=(const X&, const X&)
+{ return true; }
+
+bool
+operator==(const Y&, const Y&)
+{ return true; }
+
+bool
+operator!=(const Y&, const Y&)
+{ return true; }
+
+bool
 operator==(const X&, const Y&)
 { return true; }
 
+bool
+operator!=(const X&, const Y&)
+{ return true; }
+
+bool
+operator==(const Y&, const X&)
+{ return true; }
+
+bool
+operator!=(const Y&, const X&)
+{ return true; }
+
 forward_iterator_wrapper<X>
 test1(forward_iterator_wrapper<X>& begin,
       forward_iterator_wrapper<X>& end, const Y& val)
diff --git a/libstdc++-v3/testsuite/25_algorithms/replace/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/replace/check_type.cc
index 9832dea..dc646fc 100644
--- a/libstdc++-v3/testsuite/25_algorithms/replace/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/replace/check_type.cc
@@ -30,6 +30,10 @@ bool
 operator==(const X&, const X&)
 { return true; }
 
+bool
+operator!=(const X&, const X&)
+{ return true; }
+
 void
 test1(forward_iterator_wrapper<X>& begin,
       forward_iterator_wrapper<X>& end, const X& old_val,
diff --git a/libstdc++-v3/testsuite/25_algorithms/replace_copy/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/replace_copy/check_type.cc
index aa78196..080adfe 100644
--- a/libstdc++-v3/testsuite/25_algorithms/replace_copy/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/replace_copy/check_type.cc
@@ -41,9 +41,38 @@ struct Z
 };
 
 bool
+operator==(const X&, const X&)
+{ return true; }
+
+bool
+operator!=(const X&, const X&)
+{ return true; }
+
+bool
+operator==(const Y&, const Y&)
+{ return true; }
+
+bool
+operator!=(const Y&, const Y&)
+{ return true; }
+
+bool
 operator==(const X&, const Y&)
 { return true; }
 
+bool
+operator!=(const X&, const Y&)
+{ return true; }
+
+bool
+operator==(const Y&, const X&)
+{ return true; }
+
+bool
+operator!=(const Y&, const X&)
+{ return true; }
+
+
 output_iterator_wrapper<Z>
 test1(input_iterator_wrapper<X>& begin,
       input_iterator_wrapper<X>& end,
diff --git a/libstdc++-v3/testsuite/25_algorithms/reverse/moveable.cc b/libstdc++-v3/testsuite/25_algorithms/reverse/moveable.cc
index ec6d241..af2b0e3 100644
--- a/libstdc++-v3/testsuite/25_algorithms/reverse/moveable.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/reverse/moveable.cc
@@ -34,6 +34,8 @@ struct X
   void operator=(const X&) = delete;
 };
 
+// Overloading swap does not satisfy permutation requirements. Should it?
+
 void
 swap(X&, X&) { }
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/search_n/11400.cc b/libstdc++-v3/testsuite/25_algorithms/search_n/11400.cc
index 0160b78..1529c74 100644
--- a/libstdc++-v3/testsuite/25_algorithms/search_n/11400.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/search_n/11400.cc
@@ -22,10 +22,13 @@
 #include <algorithm>
 #include <functional>
 
-struct Integral { operator int() const; };
+// Simply converting to int() does not mean that we've satisfied the
+// convertible requirements.
+
+struct Int { operator int() const; };
 
 namespace std
 {
-  template int* search_n (int*, int*, Integral, const int&);
-  template int* search_n (int*, int*, Integral, const int&, greater<int>);
+  template int* search_n (int*, int*, Int, const int&);
+  template int* search_n (int*, int*, Int, const int&, greater<int>);
 }
diff --git a/libstdc++-v3/testsuite/25_algorithms/search_n/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/search_n/check_type.cc
index 3f15a4f..2c5a64b 100644
--- a/libstdc++-v3/testsuite/25_algorithms/search_n/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/search_n/check_type.cc
@@ -29,9 +29,37 @@ struct X { };
 struct Y { };
 
 bool
+operator==(const X&, const X&)
+{ return true; }
+
+bool
+operator!=(const X&, const X&)
+{ return true; }
+
+bool
+operator==(const Y&, const Y&)
+{ return true; }
+
+bool
+operator!=(const Y&, const Y&)
+{ return true; }
+
+bool
 operator==(const X&, const Y&)
 { return true; }
 
+bool
+operator!=(const X&, const Y&)
+{ return true; }
+
+bool
+operator==(const Y&, const X&)
+{ return true; }
+
+bool
+operator!=(const Y&, const X&)
+{ return true; }
+
 forward_iterator_wrapper<X>
 test1(forward_iterator_wrapper<X>& begin,
       forward_iterator_wrapper<X>& end, int i, Y& value)
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_difference/1.cc b/libstdc++-v3/testsuite/25_algorithms/set_difference/1.cc
index f8695e2..7a523a6 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_difference/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_difference/1.cc
@@ -102,6 +102,18 @@ bool
 operator<(const S& s1, const S& s2)
 { return s1.i < s2.i; }
 
+bool 
+operator>(const S& s1, const S& s2)
+{ return s1.i > s2.i; }
+
+bool 
+operator<=(const S& s1, const S& s2)
+{ return s1.i <= s2.i; }
+
+bool 
+operator>=(const S& s1, const S& s2)
+{ return s1.i >= s2.i; }
+
 typedef test_container<S, input_iterator_wrapper> SIcontainer;
 typedef test_container<S, output_iterator_wrapper> SOcontainer;
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_difference/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/set_difference/check_type.cc
index 8f0f61c..2b62335 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_difference/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_difference/check_type.cc
@@ -29,6 +29,16 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_intersection/1.cc b/libstdc++-v3/testsuite/25_algorithms/set_intersection/1.cc
index 09310ad..c11fa25 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_intersection/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_intersection/1.cc
@@ -102,6 +102,18 @@ bool
 operator<(const S& s1, const S& s2)
 { return s1.i < s2.i; }
 
+bool 
+operator>(const S& s1, const S& s2)
+{ return s1.i > s2.i; }
+
+bool 
+operator<=(const S& s1, const S& s2)
+{ return s1.i <= s2.i; }
+
+bool 
+operator>=(const S& s1, const S& s2)
+{ return s1.i >= s2.i; }
+
 typedef test_container<S, input_iterator_wrapper> SIcontainer;
 typedef test_container<S, output_iterator_wrapper> SOcontainer;
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_intersection/34730.cc b/libstdc++-v3/testsuite/25_algorithms/set_intersection/34730.cc
index e9da465..49ef0c7 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_intersection/34730.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_intersection/34730.cc
@@ -45,6 +45,9 @@ void test01()
   vector<string> vec1;
   vector<intstring> vec2;
   vector<intstring> vec3;
+
+  // NOTE: Fails to check because of a conversion error. I can't assign strings
+  // to intstrings.
   set_intersection(vec2.begin(), vec2.end(),
 		   vec1.begin(), vec1.end(),
 		   back_inserter(vec3), intstrcmp());
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_intersection/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/set_intersection/check_type.cc
index 62aff9a..537e8e9 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_intersection/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_intersection/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/1.cc b/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/1.cc
index 1eb1f1f..773b87c 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/1.cc
@@ -103,6 +103,18 @@ bool
 operator<(const S& s1, const S& s2)
 { return s1.i < s2.i; }
 
+bool 
+operator>(const S& s1, const S& s2)
+{ return s1.i > s2.i; }
+
+bool 
+operator<=(const S& s1, const S& s2)
+{ return s1.i <= s2.i; }
+
+bool 
+operator>=(const S& s1, const S& s2)
+{ return s1.i >= s2.i; }
+
 typedef test_container<S, input_iterator_wrapper> SIcontainer;
 typedef test_container<S, output_iterator_wrapper> SOcontainer;
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/check_type.cc
index daafe6d..b5e7748 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_symmetric_difference/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_union/1.cc b/libstdc++-v3/testsuite/25_algorithms/set_union/1.cc
index f6445e9..21a9edc 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_union/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_union/1.cc
@@ -105,6 +105,18 @@ bool
 operator<(const S& s1, const S& s2)
 { return s1.i < s2.i; }
 
+bool 
+operator>(const S& s1, const S& s2)
+{ return s1.i > s2.i; }
+
+bool 
+operator<=(const S& s1, const S& s2)
+{ return s1.i <= s2.i; }
+
+bool 
+operator>=(const S& s1, const S& s2)
+{ return s1.i >= s2.i; }
+
 typedef test_container<S, input_iterator_wrapper> SIcontainer;
 typedef test_container<S, output_iterator_wrapper> SOcontainer;
 
diff --git a/libstdc++-v3/testsuite/25_algorithms/set_union/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/set_union/check_type.cc
index 8ab069b..d776138 100644
--- a/libstdc++-v3/testsuite/25_algorithms/set_union/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/set_union/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/stable_sort/1.cc b/libstdc++-v3/testsuite/25_algorithms/stable_sort/1.cc
index b8a0571..4933a5c 100644
--- a/libstdc++-v3/testsuite/25_algorithms/stable_sort/1.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/stable_sort/1.cc
@@ -69,6 +69,19 @@ bool
 operator<(const S& s1, const S& s2)
 { return s1.i < s2.i; }
 
+bool 
+operator>(const S& s1, const S& s2)
+{ return s1.i > s2.i; }
+
+bool 
+operator<=(const S& s1, const S& s2)
+{ return s1.i <= s2.i; }
+
+bool 
+operator>=(const S& s1, const S& s2)
+{ return s1.i >= s2.i; }
+
+
 void 
 test3()
 {
diff --git a/libstdc++-v3/testsuite/25_algorithms/stable_sort/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/stable_sort/check_type.cc
index 962807b..28a117b 100644
--- a/libstdc++-v3/testsuite/25_algorithms/stable_sort/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/stable_sort/check_type.cc
@@ -29,6 +29,15 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/25_algorithms/unique_copy/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/unique_copy/check_type.cc
index 9b53420..ca9a7d8 100644
--- a/libstdc++-v3/testsuite/25_algorithms/unique_copy/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/unique_copy/check_type.cc
@@ -35,6 +35,10 @@ struct S2
 bool 
 operator==(const S1&, const S1&) {return true;}
 
+bool 
+operator!=(const S1&, const S1&) {return true;}
+
+
 struct X1 { };
 
 struct X2
diff --git a/libstdc++-v3/testsuite/25_algorithms/upper_bound/check_type.cc b/libstdc++-v3/testsuite/25_algorithms/upper_bound/check_type.cc
index 244c429..0b28874 100644
--- a/libstdc++-v3/testsuite/25_algorithms/upper_bound/check_type.cc
+++ b/libstdc++-v3/testsuite/25_algorithms/upper_bound/check_type.cc
@@ -29,6 +29,16 @@ struct S { };
 bool 
 operator<(const S&, const S&) {return true;}
 
+bool 
+operator<=(const S&, const S&) {return true;}
+
+bool 
+operator>(const S&, const S&) {return true;}
+
+bool 
+operator>=(const S&, const S&) {return true;}
+
+
 struct X { };
 
 bool 
diff --git a/libstdc++-v3/testsuite/util/testsuite_rvalref.h b/libstdc++-v3/testsuite/util/testsuite_rvalref.h
index 73c70e0..7ea76e8 100644
--- a/libstdc++-v3/testsuite/util/testsuite_rvalref.h
+++ b/libstdc++-v3/testsuite/util/testsuite_rvalref.h
@@ -82,9 +82,25 @@ namespace __gnu_test
   { return lhs.val == rhs.val; }
 
   inline bool
+  operator!=(const rvalstruct& lhs, const rvalstruct& rhs)
+  { return lhs.val == rhs.val; }
+
+  inline bool
   operator<(const rvalstruct& lhs, const rvalstruct& rhs)
   { return lhs.val < rhs.val; }
 
+  inline bool
+  operator>(const rvalstruct& lhs, const rvalstruct& rhs)
+  { return lhs.val > rhs.val; }
+
+  inline bool
+  operator<=(const rvalstruct& lhs, const rvalstruct& rhs)
+  { return lhs.val <= rhs.val; }
+
+  inline bool
+  operator>=(const rvalstruct& lhs, const rvalstruct& rhs)
+  { return lhs.val >= rhs.val; }
+
   void
   swap(rvalstruct& lhs, rvalstruct& rhs)
   {
@@ -228,8 +244,7 @@ namespace __gnu_test
   };
 
   inline bool
-  operator<(rvalstruct_compare_by_value lh,
-	    rvalstruct_compare_by_value rh)
+  operator<(rvalstruct_compare_by_value lh, rvalstruct_compare_by_value rh)
   {
     bool test __attribute__((unused)) = true;
     VERIFY( rh.ok );
@@ -238,8 +253,25 @@ namespace __gnu_test
   }
 
   inline bool
-  order(rvalstruct_compare_by_value lh,
-	rvalstruct_compare_by_value rh)
+  operator>(rvalstruct_compare_by_value lh, rvalstruct_compare_by_value rh)
+  {
+    return rh.val < lh.val;
+  }
+
+  inline bool
+  operator<=(rvalstruct_compare_by_value lh, rvalstruct_compare_by_value rh)
+  {
+    return !(rh.val < lh.val);
+  }
+
+  inline bool
+  operator>=(rvalstruct_compare_by_value lh, rvalstruct_compare_by_value rh)
+  {
+    return !(lh.val < rh.val);
+  }
+
+  inline bool
+  order(rvalstruct_compare_by_value lh, rvalstruct_compare_by_value rh)
   {
     bool test __attribute__((unused)) = true;
     VERIFY( rh.ok );
